<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»’ç„”ã®è¿·å®® - Diablo Style Hack & Slash</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-0: #040201;
            --bg-1: #0d0603;
            --bg-2: #140a06;
            --panel-bg: rgba(18,10,5,0.95);
            --panel-bg-strong: rgba(12,6,2,0.98);
            --panel-border: #8b6b3d;
            --panel-border-soft: #5a4a3a;
            --accent: #e5b35a;
            --accent-strong: #ffd270;
            --accent-dim: #aa8855;
            --text: #e8d7b8;
            --muted: #9b8a6f;
            --danger: #d24b4b;
            --good: #40d97b;
            --ui-glow: rgba(229,179,90,0.35);
            --font-title: "Cinzel", "IM Fell English", "Garamond", serif;
            --font-ui: "Spectral", "Garamond", "Georgia", serif;
            --font-mono: "Fira Mono", "Consolas", monospace;
        }
        body {
            font-family: var(--font-ui);
            background: radial-gradient(1200px 800px at 50% 20%, #1b0c08 0%, var(--bg-1) 45%, var(--bg-0) 100%);
            color: var(--text);
            overflow: hidden;
            user-select: none;
            cursor: default;
            position: relative;
        }
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background:
                radial-gradient(circle at 20% 20%, rgba(255,120,60,0.05), transparent 40%),
                radial-gradient(circle at 80% 30%, rgba(120,80,40,0.06), transparent 45%),
                repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0 2px, transparent 2px 6px);
            pointer-events: none;
            opacity: 0.45;
            z-index: 0;
        }
        canvas { display: block; position: relative; z-index: 1; }
        #titleScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: radial-gradient(ellipse at center, #1a0a0a 0%, #0a0503 55%, #000 85%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: pointer;
        }
        #titleScreen::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 30%, rgba(255,120,60,0.08), transparent 55%);
            pointer-events: none;
        }
        #titleScreen h1 {
            font-size: 64px;
            color: #ff5a2a;
            text-shadow: 0 0 30px #ff4400, 0 0 60px #ff2200, 0 0 90px #7a0000;
            letter-spacing: 8px;
            margin-bottom: 20px;
            animation: flicker 3s infinite;
            font-family: var(--font-title);
        }
        #titleScreen h2 {
            font-size: 18px;
            color: var(--accent-dim);
            letter-spacing: 4px;
            margin-bottom: 60px;
        }
        #titleScreen .start-text {
            font-size: 22px;
            color: var(--accent);
            animation: pulse 2s infinite;
            letter-spacing: 6px;
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.9; }
            75% { opacity: 1; }
            80% { opacity: 0.85; }
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        .promo-card {
            display: inline-block;
            width: 45%;
            margin: 8px 2%;
            padding: 15px;
            background: rgba(30,20,10,0.9);
            border: 2px solid var(--panel-border-soft);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            vertical-align: top;
        }
        .promo-card:hover {
            border-color: var(--accent-strong);
            box-shadow: 0 0 20px var(--ui-glow);
            transform: translateY(-3px);
        }
        .skill-slot-pick {
            width: 48px; height: 48px;
            background: rgba(30,25,20,0.9);
            border: 2px solid var(--panel-border-soft);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .skill-slot-pick.selected {
            border-color: var(--accent-strong);
            box-shadow: 0 0 10px var(--ui-glow);
        }
        .skill-pick-item {
            width: 70px;
            padding: 6px 4px;
            background: rgba(40,30,20,0.9);
            border: 1px solid var(--panel-border-soft);
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
        }
        .skill-pick-item:hover:not(.locked) {
            border-color: var(--accent-strong);
            background: rgba(60,40,20,0.9);
        }
        .skill-pick-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .close-btn {
            background: #654321;
            color: var(--accent-strong);
            border: 1px solid var(--panel-border);
            padding: 8px 20px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
        }
        .close-btn:hover { background: #7a5a35; }
        .ui-panel {
            position: absolute;
            background: linear-gradient(180deg, var(--panel-bg), rgba(10,5,2,0.95));
            border: 2px solid var(--panel-border);
            border-image: linear-gradient(180deg, var(--accent), #8b6914, #654321) 1;
            color: var(--accent);
            font-size: 13px;
            padding: 15px;
            display: none;
            z-index: 100;
            max-height: 85vh;
            overflow-y: auto;
            font-family: var(--font-mono);
            box-shadow: 0 0 20px rgba(0,0,0,0.8), inset 0 0 30px rgba(0,0,0,0.5);
        }
        #statsPanel { top: 60px; left: 10px; width: 280px; }
        #inventoryPanel { top: 60px; right: 10px; width: 320px; }
        .panel-header {
            font-size: 16px;
            border-bottom: 1px solid var(--panel-border);
            margin-bottom: 10px;
            padding-bottom: 8px;
            text-align: center;
            color: var(--accent-strong);
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,215,0,0.3);
            font-family: var(--font-title);
        }
        .stat-row {
            margin: 6px 0;
            display: flex;
            justify-content: space-between;
            padding: 2px 5px;
        }
        .stat-row:hover { background: rgba(139,115,85,0.2); }
        .stat-label { color: #aaa; }
        .stat-value { color: #ffd700; font-weight: bold; }
        .stat-btn {
            background: #654321;
            color: #ffd700;
            border: 1px solid #8b7355;
            cursor: pointer;
            padding: 1px 8px;
            font-size: 12px;
            margin-left: 5px;
        }
        .stat-btn:hover { background: #8b6914; }
        .equip-slots {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin: 10px 0;
        }
        .equip-slot {
            height: 50px;
            background: rgba(40,30,20,0.8);
            border: 1px solid #555;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: #888;
            cursor: pointer;
            position: relative;
        }
        .equip-slot:hover { border-color: #daa520; }
        .equip-slot.filled { border-color: #8b7355; }
        .equip-slot .slot-label { font-size: 8px; color: #555; margin-top: 2px; }
        .inv-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 3px;
            margin: 10px 0;
        }
        .inv-cell {
            height: 42px;
            background: rgba(40,30,20,0.6);
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            position: relative;
        }
        .inv-cell:hover { border-color: #daa520; background: rgba(80,60,30,0.5); }
        #tooltip {
            position: absolute;
            background: linear-gradient(180deg, rgba(20,10,5,0.98), rgba(5,2,0,0.98));
            border: 2px solid var(--panel-border);
            color: var(--accent);
            padding: 10px;
            font-size: 12px;
            display: none;
            z-index: 300;
            min-width: 180px;
            max-width: 240px;
            font-family: var(--font-mono);
            box-shadow: 0 0 15px rgba(0,0,0,0.9);
            pointer-events: none;
        }
        .tt-name { font-weight: bold; font-size: 14px; margin-bottom: 5px; }
        .tt-type { color: #888; font-size: 11px; margin-bottom: 6px; }
        .tt-affix { color: #4488ff; margin: 3px 0; font-size: 11px; }
        .tt-rarity { font-size: 10px; margin-top: 6px; font-style: italic; }
        .tt-equip { color: #00cc00; font-size: 10px; margin-top: 4px; }
        #logPanel {
            position: absolute;
            bottom: 90px;
            left: 10px;
            width: 350px;
            max-height: 150px;
            overflow: hidden;
            pointer-events: none;
            z-index: 50;
        }
        .log-msg {
            font-size: 12px;
            padding: 2px 0;
            opacity: 0.9;
            text-shadow: 0 0 3px #000, 1px 1px 2px #000;
        }
        .log-msg.fade { opacity: 0.4; }
        #levelUpNotice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700, 0 0 60px #ff8c00;
            display: none;
            z-index: 200;
            letter-spacing: 4px;
            pointer-events: none;
        }
        #deathScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(80,0,0,0.7);
            display: none;
            z-index: 500;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        #deathScreen h1 { font-size: 72px; color: #ff0000; text-shadow: 0 0 30px #ff0000; margin-bottom: 20px; font-family: var(--font-title); }
        #deathScreen p { font-size: 20px; color: #cc8888; }
        #controls-help {
            display: none;
        }
        .class-card {
            width: 260px;
            background: linear-gradient(180deg, rgba(30,20,10,0.95), rgba(15,10,5,0.95));
            border: 2px solid #5a4a3a;
            padding: 20px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
        }
        .class-card:hover {
            border-color: #daa520;
            background: linear-gradient(180deg, rgba(50,35,15,0.95), rgba(25,18,8,0.95));
            transform: translateY(-5px);
            box-shadow: 0 5px 25px rgba(218,165,32,0.3);
        }
        .class-icon { font-size: 48px; margin-bottom: 10px; }
        .class-name { font-size: 24px; color: #daa520; font-weight: bold; letter-spacing: 4px; font-family: var(--font-title); }
        .class-eng { font-size: 11px; color: #886633; letter-spacing: 3px; margin-bottom: 12px; }
        .class-desc { font-size: 12px; color: #999; line-height: 1.6; margin-bottom: 12px; min-height: 60px; }
        .class-stats { font-size: 11px; color: #aa8844; letter-spacing: 1px; }
        #skillTreePanel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 650px;
            max-height: 85vh;
            overflow-y: auto;
            background: linear-gradient(180deg, rgba(20,10,5,0.97), rgba(10,5,2,0.97));
            border: 2px solid #8b7355;
            border-image: linear-gradient(180deg, #daa520, #8b6914, #654321) 1;
            color: #daa520;
            font-size: 13px;
            padding: 20px;
            display: none;
            z-index: 150;
            box-shadow: 0 0 30px rgba(0,0,0,0.9), inset 0 0 30px rgba(0,0,0,0.5);
        }
        .skill-branch { margin-bottom: 15px; }
        .skill-branch-title { color: #ffd700; font-size: 14px; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #5a4a3a; padding-bottom: 4px; }
        .skill-node {
            display: inline-block;
            width: 180px;
            background: rgba(30,20,10,0.8);
            border: 1px solid #5a4a3a;
            padding: 8px;
            margin: 4px;
            cursor: pointer;
            vertical-align: top;
            transition: border-color 0.2s;
        }
        .skill-node:hover { border-color: #daa520; }
        .skill-node.unlocked { border-color: #8b7355; }
        .skill-node.maxed { border-color: #ffd700; }
        .skill-node.locked { opacity: 0.5; cursor: default; }
        .skill-node .sn-icon { font-size: 20px; }
        .skill-node .sn-name { color: #daa520; font-size: 12px; font-weight: bold; }
        .skill-node .sn-level { color: #888; font-size: 10px; }
        .skill-node .sn-desc { color: #777; font-size: 10px; margin-top: 4px; }
        .skill-node .sn-btn { background: #4a3210; color: #daa520; border: 1px solid #8b7355; padding: 2px 8px; font-size: 10px; cursor: pointer; margin-top: 4px; }
        .skill-node .sn-btn:hover { background: #6a4a18; }
        #pauseOverlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1400;
            text-align: center;
            backdrop-filter: blur(2px);
        }
        #pauseOverlay .pause-card {
            background: linear-gradient(180deg, rgba(25,12,6,0.98), rgba(12,6,2,0.98));
            border: 2px solid var(--panel-border);
            padding: 30px 40px;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            min-width: 320px;
        }
        #pauseOverlay .pause-title {
            font-family: var(--font-title);
            font-size: 32px;
            letter-spacing: 6px;
            color: var(--accent-strong);
            margin-bottom: 8px;
        }
        #pauseOverlay .pause-sub {
            font-size: 12px;
            color: var(--muted);
            letter-spacing: 2px;
        }
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 4px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            gap: 10px;
        }
        .setting-row:last-child { border-bottom: none; }
        .setting-label { color: var(--text); font-size: 12px; }
        .toggle-btn {
            background: #3a2716;
            color: var(--accent-strong);
            border: 1px solid var(--panel-border);
            padding: 4px 10px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
        }
        .toggle-btn.off {
            color: #b68a5d;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="titleScreen">
        <h1>é»’ç„”ã®è¿·å®®</h1>
        <h2>DUNGEON OF BLACK FLAME</h2>
        <div id="classSelect" style="display:none;width:100%;max-width:900px;margin:0 auto">
            <div style="text-align:center;color:#daa520;font-size:16px;margin-bottom:20px;letter-spacing:3px">â”€ â† â†’ ã§ã‚¯ãƒ©ã‚¹ã‚’é¸æŠã€€Enter ã§æ±ºå®š â”€</div>
            <div style="display:flex;gap:20px;justify-content:center">
                <div class="class-card" onclick="selectClass('warrior')">
                    <div class="class-icon">âš”</div>
                    <div class="class-name">æˆ¦å£«</div>
                    <div class="class-eng">WARRIOR</div>
                    <div class="class-desc">è¿‘æ¥æˆ¦é—˜ã®é”äººã€‚é«˜ã„ä½“åŠ›ã¨ç­‹åŠ›ã§æ•µã‚’ãªãå€’ã™ã€‚é‡è£…å‚™ã‚’å¾—æ„ã¨ã—ã€å‰ç·šã§æˆ¦ã†ã€‚</div>
                    <div class="class-stats">STR â˜…â˜…â˜… DEX â˜…â˜†â˜† VIT â˜…â˜…â˜… INT â˜…â˜†â˜†</div>
                </div>
                <div class="class-card" onclick="selectClass('rogue')">
                    <div class="class-icon">ğŸ¹</div>
                    <div class="class-name">ç›—è³Š</div>
                    <div class="class-eng">ROGUE</div>
                    <div class="class-desc">ç´ æ—©ã•ã¨ç²¾å¯†ãªå°„æ’ƒã§æˆ¦ã†ã€‚ç½ ã‚’ä»•æ›ã‘ã€æ•µã®å¼±ç‚¹ã‚’çªãã€‚å›é¿ã«å„ªã‚Œã‚‹ã€‚</div>
                    <div class="class-stats">STR â˜…â˜†â˜† DEX â˜…â˜…â˜… VIT â˜…â˜…â˜† INT â˜…â˜…â˜†</div>
                </div>
                <div class="class-card" onclick="selectClass('sorcerer')">
                    <div class="class-icon">ğŸ”®</div>
                    <div class="class-name">é­”æ³•ä½¿ã„</div>
                    <div class="class-eng">SORCERER</div>
                    <div class="class-desc">å¼·åŠ›ãªé­”æ³•ã‚’æ“ã‚‹ã€‚ç‚ã€é›·ã€æ°·ã®é­”æ³•ã§é è·é›¢ã‹ã‚‰æ®²æ»…ã™ã‚‹ã€‚MPãŒè±Šå¯Œã€‚</div>
                    <div class="class-stats">STR â˜…â˜†â˜† DEX â˜…â˜†â˜† VIT â˜…â˜†â˜† INT â˜…â˜…â˜…</div>
                </div>
            </div>
        </div>
        <div id="titleStartText" class="start-text" style="margin-top:40px">â€• Enter / ã‚¯ãƒªãƒƒã‚¯ã—ã¦é–‹å§‹ â€•</div>
    
    <!-- Promotion Overlay -->
    <div id="promotionOverlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.85);z-index:2000;justify-content:center;align-items:center">
        <div id="promotionContent" style="background:linear-gradient(180deg,rgba(30,15,5,0.98),rgba(15,8,2,0.98));border:2px solid #daa520;padding:25px;max-width:600px;width:90%;border-radius:6px;box-shadow:0 0 40px rgba(218,165,32,0.3)"></div>
    </div>

    <!-- Skill Select Overlay -->
    <div id="skillSelectOverlay" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,0.8);z-index:1500;justify-content:center;align-items:center">
        <div id="skillSelectContent" style="background:linear-gradient(180deg,rgba(20,12,5,0.98),rgba(10,6,2,0.98));border:2px solid #8b7355;padding:20px;max-width:500px;width:90%;border-radius:6px;box-shadow:0 0 30px rgba(0,0,0,0.5);max-height:80vh;overflow-y:auto"></div>
    </div>

    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="statsPanel" class="ui-panel">
        <div class="panel-header">âš” ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</div>
        <div id="statsContent"></div>
    </div>
    <div id="inventoryPanel" class="ui-panel">
        <div class="panel-header">ğŸ’ ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª</div>
        <div id="inventoryContent"></div>
    </div>
    <div id="tooltip"></div>
    <div id="logPanel"></div>
    <div id="levelUpNotice">LEVEL UP!</div>
    <div id="deathScreen">
        <h1>YOU DIED</h1>
        <p>Enter / ã‚¯ãƒªãƒƒã‚¯ã§å¾©æ´»...</p>
    </div>
    <div id="controls-help">
        å·¦ã‚¯ãƒªãƒƒã‚¯:ç§»å‹•/æ”»æ’ƒ | å³ã‚¯ãƒªãƒƒã‚¯:ã‚¹ã‚­ãƒ« | 1~6:ã‚¹ã‚­ãƒ«é¸æŠ | I:ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª | C:ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ | Space:ã‚¢ã‚¤ãƒ†ãƒ æ‹¾ã†
    </div>

    <div id="helpOverlay" class="ui-panel" style="top:50%;left:50%;transform:translate(-50%,-50%);width:500px;max-height:80vh;display:none">
        <div class="panel-header">ğŸ“– æ“ä½œã‚¬ã‚¤ãƒ‰ (H ã§é–‰ã˜ã‚‹)</div>
        <div style="line-height:2;font-size:13px">
            <div style="color:#daa520;font-weight:bold;margin:8px 0 4px">åŸºæœ¬æ“ä½œ</div>
            <div><span style="color:#ffd700">å·¦ã‚¯ãƒªãƒƒã‚¯</span> â”€ ç§»å‹• / æ•µã‚’æ”»æ’ƒ</div>
            <div><span style="color:#ffd700">å³ã‚¯ãƒªãƒƒã‚¯</span> â”€ é¸æŠä¸­ã®ã‚¹ã‚­ãƒ«ã‚’ç™ºå‹•</div>
            <div><span style="color:#ffd700">Spaceã‚­ãƒ¼</span> â”€ è¿‘ãã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‹¾ã†</div>
            <div style="color:#daa520;font-weight:bold;margin:12px 0 4px">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</div>
            <div><span style="color:#ffd700">Iã‚­ãƒ¼</span> â”€ ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªé–‹é–‰</div>
            <div><span style="color:#ffd700">Cã‚­ãƒ¼</span> â”€ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢é–‹é–‰</div>
            <div><span style="color:#ffd700">Hã‚­ãƒ¼</span> â”€ ã“ã®ãƒ˜ãƒ«ãƒ—ç”»é¢ã®é–‹é–‰</div>
            <div><span style="color:#ffd700">Oã‚­ãƒ¼</span> â”€ è¨­å®šç”»é¢ã®é–‹é–‰</div>
            <div><span style="color:#ffd700">Esc</span> â”€ ä¸€æ™‚åœæ­¢</div>
            <div style="color:#daa520;font-weight:bold;margin:12px 0 4px">ã‚¹ã‚­ãƒ« (1~6ã‚­ãƒ¼ã§é¸æŠ)</div>
            <div><span style="color:#ffd700">1</span> â”€ ğŸ”¥ ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ« (15MP) â”€ ç‚ã®å¼¾ã‚’ç™ºå°„</div>
            <div><span style="color:#ffd700">2</span> â”€ ğŸŒ€ æ—‹é¢¨æ–¬ (20MP) â”€ å‘¨å›²ã®æ•µã‚’æ–¬ã‚‹</div>
            <div><span style="color:#ffd700">3</span> â”€ ğŸ’š ãƒ’ãƒ¼ãƒ« (25MP) â”€ HPã‚’å›å¾©</div>
            <div><span style="color:#ffd700">4</span> â”€ â„ï¸ ãƒ•ãƒ­ã‚¹ãƒˆãƒãƒ´ã‚¡ (30MP) â”€ æ•µã‚’å‡çµ</div>
            <div><span style="color:#ffd700">5</span> â”€ ğŸ›¡ï¸ é­”æ³•ã‚·ãƒ¼ãƒ«ãƒ‰ (35MP) â”€ ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›</div>
            <div><span style="color:#ffd700">6</span> â”€ â˜„ï¸ ãƒ¡ãƒ†ã‚ª (50MP) â”€ åºƒç¯„å›²å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸</div>
            <div style="color:#daa520;font-weight:bold;margin:12px 0 4px">ãƒ’ãƒ³ãƒˆ</div>
            <div style="color:#999;font-size:12px">ãƒ»æ•µã‚’å…¨æ»…ã•ã›ã‚‹ã¨éšæ®µãŒä½¿ãˆã‚‹</div>
            <div style="color:#999;font-size:12px">ãƒ»æ·±ã„éšå±¤ã»ã©å¼·æ•µã¨è‰¯ã„ã‚¢ã‚¤ãƒ†ãƒ ãŒå‡ºç¾</div>
            <div style="color:#999;font-size:12px">ãƒ»è£…å‚™ã®ãƒ¬ã‚¢ãƒªãƒ†ã‚£: <span style="color:#ccc">ã‚³ãƒ¢ãƒ³</span> < <span style="color:#68f">ãƒã‚¸ãƒƒã‚¯</span> < <span style="color:#fd4">ãƒ¬ã‚¢</span> < <span style="color:#f80">ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼</span> < <span style="color:#0d6">ãƒ¦ãƒ‹ãƒ¼ã‚¯</span></div>
        </div>
    </div>

    <div id="settingsPanel" class="ui-panel" style="top:50%;left:50%;transform:translate(-50%,-50%);width:420px;max-height:80vh;display:none">
        <div class="panel-header">âš™ è¨­å®š (O ã§é–‰ã˜ã‚‹)</div>
        <div id="settingsContent"></div>
    </div>

    <div id="pauseOverlay">
        <div class="pause-card">
            <div class="pause-title">PAUSED</div>
            <div class="pause-sub">Esc ã§å†é–‹ | O ã§è¨­å®š</div>
        </div>
    </div>

    <div id="skillTreePanel">
        <div class="panel-header">ğŸŒ³ ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ (T ã§é–‰ã˜ã‚‹)</div>
        <div id="skillTreeContent"></div>
    </div>

    <script>
    // ========================================
    // é»’ç„”ã®è¿·å®® - Diablo Style Hack & Slash
    // ========================================
    'use strict';

    // --- Audio System (Web Audio API with Dungeon Reverb) ---
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx, reverbNode, masterGain, reverbSend, dryGain;
    let bgmNodes = null;

    // --- Sprite Sheet Loading ---
    const SPRITES = {};
    let spritesLoaded = false;
    function loadSprites() {
        const sheets = {
            tiles: 'asset/32rogues/tiles.png',
            monsters: 'asset/32rogues/monsters.png',
            rogues: 'asset/32rogues/rogues.png',
            items: 'asset/32rogues/items.png',
            animTiles: 'asset/32rogues/animated-tiles.png'
        };
        let loaded = 0;
        const total = Object.keys(sheets).length;
        for (const [key, src] of Object.entries(sheets)) {
            const img = new Image();
            img.onload = () => {
                SPRITES[key] = img;
                if (++loaded === total) {
                    spritesLoaded = true;
                    console.log('All sprites loaded successfully');
                    // Re-generate tile textures now that sprites are loaded
                    try {
                        if (typeof tileTexturesReady !== 'undefined' && tileTexturesReady && typeof generateTileTextures === 'function') {
                            tileTexturesReady = false;
                            generateTileTextures();
                            tileTexturesReady = true;
                            console.log('Tile textures regenerated with sprites');
                        }
                    } catch(e) { console.warn('Sprite texture override deferred:', e); }
                }
            };
            img.onerror = () => { console.warn('Sprite fail:', src); if (++loaded === total) spritesLoaded = true; };
            img.src = src;
        }
    }
    loadSprites();

    const SP = 32; // sprite pixel size in sprite sheet
    const ATLAS = {
        // tiles.png (544x832, 32px grid)
        wallTop:['tiles',0,64], wallSide1:['tiles',32,64], wallSide2:['tiles',64,64],
        deepWall:['tiles',0,96], catWallSide:['tiles',32,160],
        floorBlank:['tiles',0,192], floor1:['tiles',32,192],
        floor2:['tiles',64,192], floor3:['tiles',96,192],
        stairsDown:['tiles',224,512], chestClosed:['tiles',0,544], chestOpen:['tiles',32,544],
        blood1:['tiles',0,704], blood2:['tiles',32,704],
        corpse1:['tiles',0,672], corpse2:['tiles',32,672],
        // monsters.png (384x416, 32px grid)
        skeleton:['monsters',0,128], skelArcher:['monsters',32,128],
        lich:['monsters',64,128], deathKnight:['monsters',96,128],
        zombie:['monsters',128,128], ghoul:['monsters',160,128],
        banshee:['monsters',0,160], wraith:['monsters',64,160],
        imp:['monsters',32,352], minotaur:['monsters',224,224],
        // rogues.png (224x224, 32px grid)
        knight:['rogues',0,32], fighter:['rogues',32,32],
        ranger:['rogues',64,0], rogueChar:['rogues',96,0],
        wizardF:['rogues',0,128], wizardM:['rogues',32,128],
        // items.png (352x832, 32px grid)
        iSword:['items',96,0], iAxe:['items',32,96], iStaff:['items',0,320],
        iShield:['items',32,352], iHelmet:['items',128,480], iArmor:['items',96,384],
        iRing:['items',0,544], iAmulet:['items',0,512], iBoots:['items',32,448],
        iPotion:['items',32,608], iGold:['items',0,768],
        // animated-tiles.png torch lit frames (row 5, y=160)
        torch0:['animTiles',0,160], torch1:['animTiles',32,160],
        torch2:['animTiles',64,160], torch3:['animTiles',96,160],
        torch4:['animTiles',128,160], torch5:['animTiles',160,160],
        // === Promoted class sprites (rogues.png) ===
        paladin:['rogues',128,32],    // shield knight
        berserker:['rogues',0,96],    // male barbarian
        assassin:['rogues',128,0],    // bandit
        rangerCls:['rogues',64,0],    // ranger
        pyromancer:['rogues',0,128],  // female wizard
        cryomancer:['rogues',64,128], // druid (ice-themed)
        monk:['rogues',0,64],         // monk
        templar:['rogues',128,64],    // templar
        warlock:['rogues',160,128],   // warlock (6th col row5)
        fencer:['rogues',128,96],     // fencer
        priest:['rogues',32,64],      // priest
    };

    function drawSpr(key, dx, dy, dw, dh, flipX) {
        const a = ATLAS[key];
        if (!a || !SPRITES[a[0]]) return false;
        const prevSmooth = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        if (flipX) {
            ctx.save(); ctx.translate(dx + dw, dy); ctx.scale(-1, 1);
            ctx.drawImage(SPRITES[a[0]], a[1], a[2], SP, SP, 0, 0, dw, dh);
            ctx.restore();
        } else {
            ctx.drawImage(SPRITES[a[0]], a[1], a[2], SP, SP, dx, dy, dw, dh);
        }
        ctx.imageSmoothingEnabled = prevSmooth;
        return true;
    }

    const ITEM_ICON_SPRITE = {
        '\u2694': 'iSword', '\ud83e\udea3': 'iAxe', '\ud83d\udd2e': 'iStaff',
        '\ud83d\udee1': 'iShield', '\u26d1': 'iHelmet', '\ud83e\uddba': 'iArmor',
        '\ud83d\udc8d': 'iRing', '\ud83d\udcbf': 'iAmulet', '\ud83d\udc62': 'iBoots',
        '\ud83e\uddea': 'iPotion'
    };


    function initAudio() {
        if (!SETTINGS.sound) return;
        if (!audioCtx) {
            audioCtx = new AudioCtx();
            // Master output chain
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 1.0;
            masterGain.connect(audioCtx.destination);

            // Dry path
            dryGain = audioCtx.createGain();
            dryGain.gain.value = 0.75;
            dryGain.connect(masterGain);

            // Reverb (dungeon echo)
            reverbNode = audioCtx.createConvolver();
            const rate = audioCtx.sampleRate;
            const len = rate * 2.2; // 2.2s reverb tail - cathedral feel
            const impulse = audioCtx.createBuffer(2, len, rate);
            for (let ch = 0; ch < 2; ch++) {
                const d = impulse.getChannelData(ch);
                for (let i = 0; i < len; i++) {
                    // Exponential decay with some early reflections
                    const t = i / rate;
                    const decay = Math.pow(1 - i / len, 1.8);
                    const earlyRef = t < 0.05 ? 0.8 : (t < 0.12 ? 0.4 : 1);
                    d[i] = (Math.random() * 2 - 1) * decay * earlyRef;
                }
            }
            reverbNode.buffer = impulse;
            reverbSend = audioCtx.createGain();
            reverbSend.gain.value = 0.35; // Reverb wet amount
            reverbNode.connect(reverbSend);
            reverbSend.connect(masterGain);

            // Start background music
            startBGM();
        }
    }

    // Route audio node to both dry + reverb
    function routeToOutput(node) {
        if (dryGain) { node.connect(dryGain); node.connect(reverbNode); }
        else node.connect(audioCtx.destination);
    }

    // Background music - dark ambient drone
    function startBGM() {
        if (bgmNodes) return;
        const t = audioCtx.currentTime;
        const bgmGain = audioCtx.createGain();
        bgmGain.gain.value = 0.025;

        // Sub bass drone
        const sub = audioCtx.createOscillator();
        sub.type = 'sine';
        sub.frequency.value = 36.7; // Low D
        sub.connect(bgmGain);
        sub.start(t);

        // Dark pad
        const pad1 = audioCtx.createOscillator();
        pad1.type = 'triangle';
        pad1.frequency.value = 73.4; // D2
        const padFilter = audioCtx.createBiquadFilter();
        padFilter.type = 'lowpass';
        padFilter.frequency.value = 200;
        pad1.connect(padFilter);
        padFilter.connect(bgmGain);
        pad1.start(t);

        // Dissonant fifth for tension
        const pad2 = audioCtx.createOscillator();
        pad2.type = 'sine';
        pad2.frequency.value = 108; // ~Ab2 (tritone tension)
        const pad2G = audioCtx.createGain();
        pad2G.gain.value = 0.4;
        pad2.connect(pad2G);
        pad2G.connect(bgmGain);
        pad2.start(t);

        // Slow LFO for eerie pulsing
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.08; // Very slow
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 0.012;
        lfo.connect(lfoGain);
        lfoGain.connect(bgmGain.gain);
        lfo.start(t);

        routeToOutput(bgmGain);
        bgmNodes = { sub, pad1, pad2, lfo, bgmGain };
    }
    function stopBGM() {
        if (!bgmNodes) return;
        for (const node of Object.values(bgmNodes)) {
            try { node.stop?.(); } catch (e) { /* ignore */ }
            try { node.disconnect?.(); } catch (e) { /* ignore */ }
        }
        bgmNodes = null;
    }

    function setSoundEnabled(enabled) {
        SETTINGS.sound = enabled;
        saveSettings();
        if (enabled) {
            initAudio();
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            if (audioCtx && !bgmNodes) startBGM();
        } else {
            stopBGM();
            if (audioCtx && audioCtx.state !== 'closed') audioCtx.suspend();
        }
    }

    function playSound(freq, type, duration, volume = 0.15) {
        if (!audioCtx || !SETTINGS.sound) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        routeToOutput(gain);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    // Noise burst for impact/explosion sounds
    function playNoise(duration, volume = 0.1, filterFreq = 2000) {
        if (!audioCtx || !SETTINGS.sound) return;
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(filterFreq, audioCtx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + duration);
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        src.connect(filter);
        filter.connect(gain);
        routeToOutput(gain);
        src.start();
        src.stop(audioCtx.currentTime + duration);
    }

    // Sweep sound (for magic effects)
    function playSweep(startFreq, endFreq, duration, type = 'sine', volume = 0.1) {
        if (!audioCtx || !SETTINGS.sound) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + duration);
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        routeToOutput(gain);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    // Melee hit - heavy metal clang + bone crunch + body impact
    function sfxHit() {
        // Metal clang
        playNoise(0.06, 0.12, 4000);
        playSound(220, 'sawtooth', 0.06, 0.12);
        // Body thud
        playSound(80, 'square', 0.08, 0.09);
        // Secondary impact
        setTimeout(() => { playNoise(0.04, 0.06, 1200); playSound(55, 'sine', 0.1, 0.05); }, 25);
        // Bone crack
        setTimeout(() => playNoise(0.02, 0.04, 6000), 40);
    }

    // Item pickup - metallic clink with echo
    function sfxPickup() {
        playSound(1200, 'sine', 0.04, 0.06);
        setTimeout(() => playSound(1500, 'sine', 0.06, 0.05), 40);
        setTimeout(() => playSound(1800, 'sine', 0.08, 0.04), 80);
        setTimeout(() => playSound(1200, 'triangle', 0.12, 0.02), 120);
    }

    // Fireball - deep whoosh + magical crackle
    function sfxFireball() {
        playSweep(500, 120, 0.35, 'sawtooth', 0.09);
        playNoise(0.2, 0.07, 1800);
        playSound(150, 'triangle', 0.15, 0.04);
        setTimeout(() => { playNoise(0.12, 0.05, 3000); playSweep(300, 80, 0.2, 'triangle', 0.03); }, 50);
    }

    // Whirlwind - rushing gale
    function sfxWhirlwind() {
        playNoise(0.5, 0.09, 1500);
        playSweep(180, 450, 0.25, 'triangle', 0.07);
        playSweep(350, 120, 0.35, 'triangle', 0.05);
        playSound(100, 'sawtooth', 0.3, 0.03);
        setTimeout(() => playNoise(0.3, 0.04, 800), 100);
    }

    // Heal - ethereal chime with holy resonance
    function sfxHeal() {
        playSound(523, 'sine', 0.2, 0.07);
        playSound(523 * 1.5, 'sine', 0.2, 0.03);
        setTimeout(() => { playSound(659, 'sine', 0.2, 0.06); playSound(659 * 1.5, 'sine', 0.15, 0.02); }, 100);
        setTimeout(() => { playSound(784, 'sine', 0.25, 0.06); playSound(1047, 'sine', 0.3, 0.04); }, 200);
        setTimeout(() => playSound(1320, 'sine', 0.4, 0.03), 300);
    }

    // Level up - triumphant cathedral fanfare
    function sfxLevelUp() {
        playSound(294, 'square', 0.15, 0.08);
        playSound(294, 'sine', 0.3, 0.05);
        setTimeout(() => { playSound(370, 'square', 0.15, 0.08); playSound(370, 'sine', 0.2, 0.04); }, 120);
        setTimeout(() => { playSound(440, 'square', 0.15, 0.1); playSound(440, 'sine', 0.2, 0.05); }, 240);
        setTimeout(() => {
            playSound(587, 'sine', 0.5, 0.12); playSound(294, 'sine', 0.5, 0.06);
            playSound(440, 'sine', 0.5, 0.04); playNoise(0.15, 0.03, 5000);
        }, 360);
    }

    // Death - deep dread + collapse
    function sfxDeath() {
        playSweep(250, 35, 0.8, 'sawtooth', 0.14);
        playNoise(0.4, 0.1, 600);
        playSound(30, 'square', 0.6, 0.12);
        setTimeout(() => { playSound(25, 'sawtooth', 0.5, 0.08); playNoise(0.5, 0.06, 300); }, 100);
        setTimeout(() => playNoise(0.3, 0.04, 200), 300);
    }

    // Stairs - ominous descending echo
    function sfxStairs() {
        playSound(440, 'sine', 0.15, 0.07);
        setTimeout(() => playSound(392, 'sine', 0.15, 0.07), 120);
        setTimeout(() => playSound(330, 'sine', 0.15, 0.07), 240);
        setTimeout(() => { playSound(294, 'sine', 0.3, 0.06); playSound(147, 'sine', 0.4, 0.04); }, 360);
        setTimeout(() => playNoise(0.2, 0.03, 400), 450);
    }

    // Legendary drop - heavenly choir
    function sfxLegendary() {
        playSound(440, 'sine', 0.15, 0.1);
        playSound(554, 'sine', 0.15, 0.05);
        setTimeout(() => { playSound(554, 'sine', 0.15, 0.1); playSound(659, 'sine', 0.15, 0.05); }, 80);
        setTimeout(() => { playSound(659, 'sine', 0.2, 0.1); playSound(831, 'sine', 0.2, 0.05); }, 160);
        setTimeout(() => {
            playSound(880, 'sine', 0.6, 0.14); playSound(1100, 'sine', 0.5, 0.06);
            playSound(440, 'sine', 0.6, 0.06); playNoise(0.15, 0.04, 6000);
        }, 260);
        setTimeout(() => playSound(1320, 'sine', 0.4, 0.05), 400);
    }

    // Frost Nova - glass shattering + icy wind
    function sfxFrostNova() {
        playNoise(0.25, 0.1, 5000);
        playSweep(3000, 400, 0.15, 'sine', 0.07);
        playSound(2000, 'square', 0.03, 0.06); // Sharp crack
        setTimeout(() => { playNoise(0.2, 0.06, 7000); playSweep(2000, 200, 0.25, 'sine', 0.04); }, 40);
        setTimeout(() => playNoise(0.15, 0.03, 3000), 100);
    }

    // Shield activate - deep energy hum with resonance
    function sfxShield() {
        playSweep(150, 600, 0.25, 'sine', 0.09);
        playSound(300, 'triangle', 0.4, 0.06);
        playSound(600, 'sine', 0.3, 0.04);
        setTimeout(() => { playSound(450, 'sine', 0.25, 0.04); playSweep(600, 800, 0.15, 'triangle', 0.03); }, 100);
    }

    // Meteor - ominous descent
    function sfxMeteorCast() {
        playSweep(120, 50, 0.6, 'sawtooth', 0.07);
        playNoise(0.5, 0.05, 500);
        playSweep(80, 40, 0.7, 'square', 0.03);
        setTimeout(() => playSweep(200, 60, 0.4, 'triangle', 0.03), 200);
    }

    // Meteor impact - massive explosion
    function sfxMeteorImpact() {
        playNoise(0.5, 0.18, 2500);
        playSound(50, 'square', 0.4, 0.15);
        playSound(35, 'sawtooth', 0.6, 0.1);
        playNoise(0.15, 0.1, 5000); // High freq debris
        setTimeout(() => { playNoise(0.4, 0.1, 1000); playSound(70, 'triangle', 0.3, 0.06); }, 50);
        setTimeout(() => { playNoise(0.3, 0.06, 500); playSound(40, 'sine', 0.4, 0.04); }, 150);
        setTimeout(() => playNoise(0.2, 0.03, 300), 300);
    }

    // Monster death - guttural collapse + bone crunch
    function sfxMonsterDeath() {
        playSound(100, 'sawtooth', 0.15, 0.1);
        playNoise(0.12, 0.08, 1500);
        playSound(55, 'square', 0.1, 0.07);
        setTimeout(() => { playNoise(0.08, 0.05, 3000); playSound(40, 'sine', 0.15, 0.04); }, 50);
        setTimeout(() => playNoise(0.06, 0.03, 800), 100);
    }

    // Footstep - alternating stone taps with variation
    let lastFootstepTime = 0;
    let footstepAlt = false;
    function sfxFootstep() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        if (now - lastFootstepTime < 0.28) return;
        lastFootstepTime = now;
        footstepAlt = !footstepAlt;
        const pitch = footstepAlt ? 90 : 75;
        const vol = 0.015 + Math.random() * 0.01;
        playNoise(0.035, vol, 500 + Math.random() * 300);
        playSound(pitch + Math.random() * 30, 'triangle', 0.03, vol * 0.8);
    }

    // Chest open - heavy creak + gold jingle
    function sfxChestOpen() {
        playSweep(120, 250, 0.2, 'sawtooth', 0.06);
        playNoise(0.12, 0.06, 1000);
        setTimeout(() => { playNoise(0.08, 0.04, 600); playSweep(250, 150, 0.15, 'triangle', 0.04); }, 80);
        setTimeout(() => sfxPickup(), 150);
        setTimeout(() => sfxPickup(), 200);
    }

    // Monster growl - when monster aggros player
    function sfxMonsterGrowl() {
        if (!audioCtx) return;
        playSweep(120, 60, 0.3, 'sawtooth', 0.04);
        playNoise(0.15, 0.02, 600);
    }

    // Player hit - pain grunt
    function sfxPlayerHit() {
        playNoise(0.06, 0.06, 1500);
        playSound(150, 'sawtooth', 0.08, 0.05);
        setTimeout(() => playSound(100, 'square', 0.05, 0.03), 30);
    }

    // Ambient dungeon - layered environmental sounds
    let lastAmbientTime = 0;
    let ambientDripTimer = 0;
    function sfxAmbient() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        if (now - lastAmbientTime < 3 + Math.random() * 6) return;
        lastAmbientTime = now;
        const r = Math.random();
        if (r < 0.25) {
            // Water drip with multiple echoes
            const freq = 1500 + Math.random() * 1000;
            playSound(freq, 'sine', 0.06, 0.025);
            setTimeout(() => playSound(freq * 0.7, 'sine', 0.05, 0.015), 100 + Math.random() * 80);
            setTimeout(() => playSound(freq * 0.5, 'sine', 0.04, 0.008), 250 + Math.random() * 100);
        } else if (r < 0.4) {
            // Distant rumble / earthquake
            playNoise(0.5, 0.015, 250);
            playSound(30, 'sine', 0.4, 0.008);
        } else if (r < 0.55) {
            // Wind through corridors
            playNoise(0.8, 0.012, 800);
            playSweep(400, 200, 0.6, 'sine', 0.005);
        } else if (r < 0.7) {
            // Distant chain rattle
            for (let i = 0; i < 3; i++) {
                setTimeout(() => playNoise(0.02, 0.015, 4000 + Math.random() * 2000), i * 60);
            }
        } else if (r < 0.85) {
            // Stone creak
            playSweep(60, 40, 0.3, 'sawtooth', 0.008);
            setTimeout(() => playNoise(0.05, 0.005, 300), 200);
        } else {
            // Distant moan / ghost
            playSweep(200, 150, 0.6, 'sine', 0.01);
            setTimeout(() => playSweep(170, 130, 0.4, 'sine', 0.006), 300);
        }
    }

    // --- Constants ---
    const TILE = 40;
    const MAP_W = 60, MAP_H = 60;
    let W = window.innerWidth, H = window.innerHeight;

    // --- Canvas Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let DPR = Math.min(window.devicePixelRatio || 1, 2);
    function resizeCanvas() {
        W = window.innerWidth;
        H = window.innerHeight;
        DPR = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = Math.round(W * DPR);
        canvas.height = Math.round(H * DPR);
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        ctx.imageSmoothingEnabled = true;
    }
    resizeCanvas();

    const DOM = {
        titleScreen: document.getElementById('titleScreen'),
        titleStartText: document.getElementById('titleStartText'),
        classSelect: document.getElementById('classSelect'),
        statsPanel: document.getElementById('statsPanel'),
        statsContent: document.getElementById('statsContent'),
        inventoryPanel: document.getElementById('inventoryPanel'),
        inventoryContent: document.getElementById('inventoryContent'),
        tooltip: document.getElementById('tooltip'),
        logPanel: document.getElementById('logPanel'),
        levelUpNotice: document.getElementById('levelUpNotice'),
        deathScreen: document.getElementById('deathScreen'),
        helpOverlay: document.getElementById('helpOverlay'),
        skillTreePanel: document.getElementById('skillTreePanel'),
        skillTreeContent: document.getElementById('skillTreeContent'),
        promotionOverlay: document.getElementById('promotionOverlay'),
        promotionContent: document.getElementById('promotionContent'),
        skillSelectOverlay: document.getElementById('skillSelectOverlay'),
        skillSelectContent: document.getElementById('skillSelectContent'),
        settingsPanel: document.getElementById('settingsPanel'),
        settingsContent: document.getElementById('settingsContent'),
        pauseOverlay: document.getElementById('pauseOverlay')
    };

    // --- Game State ---
    const G = {
        started: false,
        titlePhase: 'start', // 'start' | 'classSelect'
        selectedClassIdx: 0,
        floor: 1,
        camX: 0, camY: 0,
        shakeT: 0, shakeAmt: 0, dmgFlashT: 0,
        time: 0,
        dead: false,
        paused: false,
        autoPickup: false,
        autoPickupRarity: 'normal'
    };

    const SETTINGS = {
        sound: true,
        screenShake: true,
        reducedParticles: false,
        filmGrain: true,
        showFPS: false
    };

    function loadSettings() {
        try {
            const raw = localStorage.getItem('diablo_settings');
            if (!raw) return;
            const data = JSON.parse(raw);
            for (const k of Object.keys(SETTINGS)) {
                if (typeof data[k] === 'boolean') SETTINGS[k] = data[k];
            }
        } catch (e) { /* ignore */ }
    }
    function saveSettings() {
        try { localStorage.setItem('diablo_settings', JSON.stringify(SETTINGS)); } catch (e) { /* ignore */ }
    }
    loadSettings();

    // --- Utility ---
    const rand = (a, b) => Math.floor(Math.random() * (b - a + 1)) + a;
    const randf = (a, b) => Math.random() * (b - a) + a;
    const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
    const lerp = (a, b, t) => a + (b - a) * t;
    const clamp = (v, mn, mx) => Math.max(mn, Math.min(mx, v));
    const FONT_UI = '"Spectral", "Garamond", "Georgia", serif';
    const FONT_TITLE = '"Cinzel", "IM Fell English", "Garamond", serif';

    // --- Log System ---
    const logMessages = [];
    let logDirty = false;
    let lastLogRender = 0;
    function addLog(msg, color = '#daa520') {
        logMessages.push({ msg, color, time: G.time });
        if (logMessages.length > 8) logMessages.shift();
        logDirty = true;
    }
    function drawLog() {
        if (!logDirty && G.time - lastLogRender < 0.25) return;
        const el = DOM.logPanel;
        el.innerHTML = logMessages.map((l) => {
            const age = G.time - l.time;
            const cls = age > 5 ? 'fade' : '';
            return `<div class="log-msg ${cls}" style="color:${l.color}">${l.msg}</div>`;
        }).join('');
        logDirty = false;
        lastLogRender = G.time;
    }

    // ========== PARTICLE SYSTEM (Round Soft-Glow) ==========
    class Particle {
        constructor(x, y, vx, vy, color, life, size = 3, grav = 150) {
            this.x = x; this.y = y;
            this.vx = vx; this.vy = vy;
            this.color = color;
            this.life = this.maxLife = life;
            this.size = size;
            this.grav = grav;
        }
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vy += this.grav * dt;
            this.life -= dt;
        }
        draw(cx, cy) {
            const a = clamp(this.life / this.maxLife, 0, 1);
            const sx = this.x - cx, sy = this.y - cy;
            const s = this.size * (0.5 + a * 0.5);
            // Core
            ctx.globalAlpha = a * 0.8;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(sx, sy, s, 0, Math.PI * 2);
            ctx.fill();
            // Hot center
            ctx.globalAlpha = a * 0.4;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(sx, sy, s * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        alive() { return this.life > 0; }
    }

    const particles = [];
    function emitParticles(x, y, color, count, speed = 80, life = 0.5, size = 3, grav = 150) {
        if (SETTINGS.reducedParticles) count = Math.max(1, Math.floor(count * 0.55));
        for (let i = 0; i < count; i++) {
            const a = randf(0, Math.PI * 2);
            const s = randf(20, speed);
            particles.push(new Particle(x + randf(-4,4), y + randf(-4,4), Math.cos(a)*s, Math.sin(a)*s, color, randf(life*0.5, life), randf(size*0.5, size*1.5), grav));
        }
    }

    // ========== AMBIENT PARTICLES (Dust motes, embers) ==========
    const ambientParticles = [];
    class AmbientParticle {
        constructor() { this.reset(); }
        reset() {
            this.x = player.x + randf(-400, 400);
            this.y = player.y + randf(-300, 300);
            this.vx = randf(-5, 5);
            this.vy = randf(-15, -3);
            this.size = randf(0.5, 2);
            this.life = this.maxLife = randf(3, 8);
            this.type = Math.random() < 0.3 ? 'ember' : 'dust';
            this.drift = randf(0, Math.PI * 2);
            if (this.type === 'ember') {
                const hue = 20 + Math.random() * 20;
                const light = 50 + Math.random() * 30;
                this.color = `hsl(${hue}, 100%, ${light}%)`;
                this.alpha = 0.6;
            } else {
                this.color = '#aa997766';
                this.alpha = 0.25;
            }
        }
        update(dt) {
            this.drift += dt * 0.5;
            this.x += (this.vx + Math.sin(this.drift) * 3) * dt;
            this.y += this.vy * dt;
            this.life -= dt;
        }
        draw(cx, cy) {
            const sx = this.x - cx, sy = this.y - cy;
            if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) return;
            const a = clamp(this.life / this.maxLife, 0, 1) * (this.life < 1 ? this.life : 1);
            ctx.globalAlpha = a * this.alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(sx, sy, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        alive() { return this.life > 0; }
    }
    function updateAmbientParticles(dt) {
        const target = SETTINGS.reducedParticles ? 8 : 15;
        while (ambientParticles.length < target) ambientParticles.push(new AmbientParticle());
        while (ambientParticles.length > target) ambientParticles.pop();
        for (let i = ambientParticles.length - 1; i >= 0; i--) {
            ambientParticles[i].update(dt);
            if (!ambientParticles[i].alive()) ambientParticles[i].reset();
        }
    }

    // ========== BLOOD POOLS (persist after monster death) ==========
    const bloodPools = [];
    function addBloodPool(x, y, size) {
        bloodPools.push({ x, y, size: size * 0.5, maxSize: size, alpha: 0.6, growT: 0.5 });
        if (bloodPools.length > 50) bloodPools.shift(); // Limit
    }
    function updateBloodPools(dt) {
        for (const bp of bloodPools) {
            if (bp.growT > 0) {
                bp.growT -= dt;
                bp.size = bp.maxSize * (1 - bp.growT / 0.5);
            }
        }
    }
    function drawBloodPools(cx, cy) {
        for (const bp of bloodPools) {
            const sx = bp.x - cx, sy = bp.y - cy;
            if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) continue;
            ctx.globalAlpha = bp.alpha * 0.7;
            ctx.fillStyle = '#300505';
            ctx.beginPath();
            ctx.ellipse(sx, sy + 2, bp.size, bp.size * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // ========== FLOATING DAMAGE ==========
    const floatingTexts = [];
    function addFloatingText(x, y, text, color, big = false) {
        floatingTexts.push({ x, y, text: String(text), color, life: 1.2, maxLife: 1.2, big, vy: -60 });
    }

    // ========== TILE TEXTURE SYSTEM (Offscreen Canvas) ==========
    // Pre-render tile textures for much better visual quality
    const TILE_TEXTURES = {};

    function generateTileTextures() {
        // Helper: create noise pattern on a canvas
        function addNoise(tctx, w, h, intensity, r, g, b) {
            const id = tctx.getImageData(0, 0, w, h);
            const d = id.data;
            for (let i = 0; i < d.length; i += 4) {
                const n = (Math.random() - 0.5) * intensity;
                d[i] = clamp(d[i] + n * r, 0, 255);
                d[i+1] = clamp(d[i+1] + n * g, 0, 255);
                d[i+2] = clamp(d[i+2] + n * b, 0, 255);
            }
            tctx.putImageData(id, 0, 0);
        }

        // --- FLOOR TILES (4 variants) ---
        for (let v = 0; v < 4; v++) {
            const c = document.createElement('canvas');
            c.width = TILE; c.height = TILE;
            const tc = c.getContext('2d');

            // Base stone color (dark, warm gray)
            const baseR = 28 + v * 3, baseG = 25 + v * 2, baseB = 22 + v * 2;
            tc.fillStyle = `rgb(${baseR},${baseG},${baseB})`;
            tc.fillRect(0, 0, TILE, TILE);

            // Large stone slab pattern (Diablo cathedral feel)
            tc.strokeStyle = `rgba(15,12,10,0.6)`;
            tc.lineWidth = 1;
            tc.strokeRect(1, 1, TILE - 2, TILE - 2);

            // Inner bevel highlight (top-left edges brighter)
            tc.fillStyle = `rgba(255,240,220,0.04)`;
            tc.fillRect(2, 2, TILE - 4, 1);
            tc.fillRect(2, 2, 1, TILE - 4);
            // Inner bevel shadow (bottom-right edges darker)
            tc.fillStyle = `rgba(0,0,0,0.08)`;
            tc.fillRect(2, TILE - 3, TILE - 4, 1);
            tc.fillRect(TILE - 3, 2, 1, TILE - 4);

            // Add stone grain noise
            addNoise(tc, TILE, TILE, 15, 1, 0.9, 0.8);

            // Random surface details per variant
            if (v === 0) {
                // Scratch marks
                tc.strokeStyle = 'rgba(10,8,6,0.3)';
                tc.lineWidth = 0.5;
                tc.beginPath();
                tc.moveTo(8, 5); tc.lineTo(28, 18); tc.stroke();
            } else if (v === 1) {
                // Small crack
                tc.strokeStyle = 'rgba(8,5,3,0.4)';
                tc.lineWidth = 0.5;
                tc.beginPath();
                tc.moveTo(15, 2); tc.lineTo(18, 15); tc.lineTo(14, 30); tc.lineTo(17, 38); tc.stroke();
            } else if (v === 2) {
                // Worn center
                tc.fillStyle = 'rgba(0,0,0,0.04)';
                tc.beginPath();
                tc.ellipse(TILE/2, TILE/2, 12, 10, 0.3, 0, Math.PI * 2);
                tc.fill();
            }

            TILE_TEXTURES['floor_' + v] = c;
        }

        // --- WALL TILE (exposed to floor) ---
        const wallC = document.createElement('canvas');
        wallC.width = TILE; wallC.height = TILE;
        const wc = wallC.getContext('2d');

        // Dark stone base
        wc.fillStyle = '#3d3228';
        wc.fillRect(0, 0, TILE, TILE);

        // Brick pattern (2 rows)
        const halfH = TILE / 2;
        // Row 1: full width brick
        wc.fillStyle = '#44382c';
        wc.fillRect(2, 2, TILE - 4, halfH - 3);
        // Row 2: two half bricks
        wc.fillStyle = '#403428';
        wc.fillRect(2, halfH + 1, TILE / 2 - 3, halfH - 3);
        wc.fillStyle = '#3e3226';
        wc.fillRect(TILE / 2 + 1, halfH + 1, TILE / 2 - 3, halfH - 3);

        // Mortar lines
        wc.strokeStyle = '#2a2018';
        wc.lineWidth = 1;
        wc.beginPath();
        wc.moveTo(0, halfH); wc.lineTo(TILE, halfH); wc.stroke();
        wc.beginPath();
        wc.moveTo(TILE / 2, halfH); wc.lineTo(TILE / 2, TILE); wc.stroke();

        // Top bevel
        wc.fillStyle = 'rgba(255,240,200,0.06)';
        wc.fillRect(0, 0, TILE, 2);

        // Stone grain
        addNoise(wc, TILE, TILE, 12, 1, 0.9, 0.7);

        TILE_TEXTURES['wall'] = wallC;

        // --- WALL TILE VARIANT 2 ---
        const wallC2 = document.createElement('canvas');
        wallC2.width = TILE; wallC2.height = TILE;
        const wc2 = wallC2.getContext('2d');
        wc2.fillStyle = '#3a3025';
        wc2.fillRect(0, 0, TILE, TILE);
        // Offset brick pattern
        wc2.fillStyle = '#403428';
        wc2.fillRect(2, 2, TILE / 2 - 3, halfH - 3);
        wc2.fillStyle = '#3e3226';
        wc2.fillRect(TILE / 2 + 1, 2, TILE / 2 - 3, halfH - 3);
        wc2.fillStyle = '#44382c';
        wc2.fillRect(2, halfH + 1, TILE - 4, halfH - 3);
        wc2.strokeStyle = '#2a2018';
        wc2.lineWidth = 1;
        wc2.beginPath();
        wc2.moveTo(0, halfH); wc2.lineTo(TILE, halfH); wc2.stroke();
        wc2.beginPath();
        wc2.moveTo(TILE / 2, 0); wc2.lineTo(TILE / 2, halfH); wc2.stroke();
        wc2.fillStyle = 'rgba(255,240,200,0.05)';
        wc2.fillRect(0, 0, TILE, 2);
        addNoise(wc2, TILE, TILE, 12, 1, 0.9, 0.7);
        TILE_TEXTURES['wall2'] = wallC2;

        // --- DEEP WALL (not adjacent to floor) ---
        const deepC = document.createElement('canvas');
        deepC.width = TILE; deepC.height = TILE;
        const dc = deepC.getContext('2d');
        dc.fillStyle = '#141210';
        dc.fillRect(0, 0, TILE, TILE);
        addNoise(dc, TILE, TILE, 8, 0.6, 0.5, 0.4);
        TILE_TEXTURES['deep_wall'] = deepC;

        // --- WALL FACE (3D bottom of wall when floor below) ---
        const faceC = document.createElement('canvas');
        faceC.width = TILE; faceC.height = 10;
        const fc = faceC.getContext('2d');
        const faceG = fc.createLinearGradient(0, 0, 0, 10);
        faceG.addColorStop(0, '#352a20');
        faceG.addColorStop(0.6, '#2a201a');
        faceG.addColorStop(1, '#1a1510');
        fc.fillStyle = faceG;
        fc.fillRect(0, 0, TILE, 10);
        // Bottom line
        fc.fillStyle = 'rgba(0,0,0,0.5)';
        fc.fillRect(0, 9, TILE, 1);
        addNoise(fc, TILE, 10, 8, 0.7, 0.6, 0.5);
        TILE_TEXTURES['wall_face'] = faceC;

        // --- BLOOD SPLATTER variants ---
        for (let v = 0; v < 3; v++) {
            const bc = document.createElement('canvas');
            bc.width = TILE; bc.height = TILE;
            const btc = bc.getContext('2d');
            btc.clearRect(0, 0, TILE, TILE);
            // Random blood drops
            const drops = 3 + v * 2;
            for (let d = 0; d < drops; d++) {
                const bx = 5 + Math.random() * (TILE - 10);
                const by = 5 + Math.random() * (TILE - 10);
                const br = 1 + Math.random() * (3 + v);
                btc.fillStyle = `rgba(${60 + v * 15},${8 + v * 3},${5 + v * 2},${0.15 + Math.random() * 0.15})`;
                btc.beginPath();
                btc.ellipse(bx, by, br, br * (0.6 + Math.random() * 0.8), Math.random() * Math.PI, 0, Math.PI * 2);
                btc.fill();
            }
            TILE_TEXTURES['blood_' + v] = bc;
        }

        // --- FLOOR SHADOW (cast from wall above) ---
        const shadowTopC = document.createElement('canvas');
        shadowTopC.width = TILE; shadowTopC.height = 14;
        const stc = shadowTopC.getContext('2d');
        const sg = stc.createLinearGradient(0, 0, 0, 14);
        sg.addColorStop(0, 'rgba(0,0,0,0.4)');
        sg.addColorStop(1, 'rgba(0,0,0,0)');
        stc.fillStyle = sg;
        stc.fillRect(0, 0, TILE, 14);
        TILE_TEXTURES['shadow_top'] = shadowTopC;

        // --- FLOOR SHADOW (cast from wall on left) ---
        const shadowLeftC = document.createElement('canvas');
        shadowLeftC.width = 10; shadowLeftC.height = TILE;
        const slc = shadowLeftC.getContext('2d');
        const slg = slc.createLinearGradient(0, 0, 10, 0);
        slg.addColorStop(0, 'rgba(0,0,0,0.25)');
        slg.addColorStop(1, 'rgba(0,0,0,0)');
        slc.fillStyle = slg;
        slc.fillRect(0, 0, 10, TILE);
        TILE_TEXTURES['shadow_left'] = shadowLeftC;

        // --- FILM GRAIN (Pre-rendered noise overlay) ---
        const grainC = document.createElement('canvas');
        grainC.width = 256; grainC.height = 256;
        const gctx = grainC.getContext('2d');
        const gid = gctx.createImageData(256, 256);
        const gdata = gid.data;
        for (let i = 0; i < gdata.length; i += 4) {
            const v = (Math.random() * 30) | 0;
            gdata[i] = gdata[i+1] = gdata[i+2] = v;
            gdata[i+3] = 25;
        }
        gctx.putImageData(gid, 0, 0);
        TILE_TEXTURES['grain'] = grainC;

        // Override tile textures with sprite sheet if loaded
        if (spritesLoaded && SPRITES.tiles) {
            const overrides = {
                wall:'wallTop', wall2:'wallSide1', deep_wall:'deepWall',
                floor_0:'floorBlank', floor_1:'floor1', floor_2:'floor2', floor_3:'floor3',
                blood_0:'blood1', blood_1:'blood2', blood_2:'corpse1'
            };
            for (const [texKey, atlasKey] of Object.entries(overrides)) {
                const a = ATLAS[atlasKey];
                if (!a || !SPRITES[a[0]] || !TILE_TEXTURES[texKey]) continue;
                const c = TILE_TEXTURES[texKey];
                const tc = c.getContext('2d');
                tc.imageSmoothingEnabled = false;
                tc.clearRect(0, 0, c.width, c.height);
                tc.drawImage(SPRITES[a[0]], a[1], a[2], SP, SP, 0, 0, c.width, c.height);
            }
            // Wall face: bottom portion of catacomb wall side
            const wf = TILE_TEXTURES['wall_face'];
            if (wf) {
                const a = ATLAS.catWallSide;
                if (a && SPRITES[a[0]]) {
                    const wfc = wf.getContext('2d');
                    wfc.imageSmoothingEnabled = false;
                    wfc.clearRect(0, 0, wf.width, wf.height);
                    wfc.drawImage(SPRITES[a[0]], a[1], a[2] + 22, SP, 10, 0, 0, wf.width, wf.height);
                }
            }
        }
    }

    // ========== DUNGEON GENERATION ==========
    class Dungeon {
        constructor(floor) {
            this.floor = floor;
            this.tiles = new Uint8Array(MAP_W * MAP_H); // 0=wall, 1=floor, 2=stairs, 3=chest
            this.rooms = [];
            this.explored = new Uint8Array(MAP_W * MAP_H);
            this.generate();
        }
        idx(x, y) { return y * MAP_W + x; }
        get(x, y) {
            if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return 0;
            return this.tiles[this.idx(x, y)];
        }
        set(x, y, v) {
            if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H) this.tiles[this.idx(x, y)] = v;
        }
        walkable(x, y) { const t = this.get(x, y); return t === 1 || t === 2 || t === 3; }

        generate() {
            this.tiles.fill(0);
            const roomCount = 8 + Math.min(this.floor, 8);

            // Generate rooms with varied sizes
            for (let i = 0; i < roomCount * 3 && this.rooms.length < roomCount; i++) {
                // Varied room shapes
                const shapeRoll = Math.random();
                let w, h;
                if (shapeRoll < 0.4) {
                    // Normal room
                    w = rand(4, 9); h = rand(4, 7);
                } else if (shapeRoll < 0.7) {
                    // Long corridor room
                    if (Math.random() < 0.5) { w = rand(8, 14); h = rand(3, 4); }
                    else { w = rand(3, 4); h = rand(8, 14); }
                } else if (shapeRoll < 0.9) {
                    // Large room
                    w = rand(8, 12); h = rand(7, 10);
                } else {
                    // Tiny room
                    w = rand(3, 5); h = rand(3, 5);
                }

                const rx = rand(2, MAP_W - w - 2);
                const ry = rand(2, MAP_H - h - 2);

                let valid = true;
                for (const r of this.rooms) {
                    if (rx < r.x + r.w + 2 && rx + w + 2 > r.x && ry < r.y + r.h + 2 && ry + h + 2 > r.y) {
                        valid = false; break;
                    }
                }
                if (!valid) continue;

                this.rooms.push({ x: rx, y: ry, w, h, cx: rx + (w>>1), cy: ry + (h>>1) });

                // Carve room with optional irregular edges
                for (let yy = ry; yy < ry + h; yy++) {
                    for (let xx = rx; xx < rx + w; xx++) {
                        // Cut corners for organic feel
                        const isCorner = (xx === rx && yy === ry) || (xx === rx + w - 1 && yy === ry) ||
                                        (xx === rx && yy === ry + h - 1) || (xx === rx + w - 1 && yy === ry + h - 1);
                        if (isCorner && Math.random() < 0.4) continue;
                        this.set(xx, yy, 1);
                    }
                }
            }

            // Sort rooms for better connectivity (nearest-neighbor)
            if (this.rooms.length > 2) {
                const sorted = [this.rooms[0]];
                const remaining = this.rooms.slice(1);
                while (remaining.length > 0) {
                    const last = sorted[sorted.length - 1];
                    let bestIdx = 0, bestDist = Infinity;
                    for (let i = 0; i < remaining.length; i++) {
                        const d = Math.hypot(remaining[i].cx - last.cx, remaining[i].cy - last.cy);
                        if (d < bestDist) { bestDist = d; bestIdx = i; }
                    }
                    sorted.push(remaining.splice(bestIdx, 1)[0]);
                }
                this.rooms = sorted;
            }

            // Connect rooms with winding corridors
            for (let i = 1; i < this.rooms.length; i++) {
                const a = this.rooms[i - 1], b = this.rooms[i];
                let cx = a.cx, cy = a.cy;

                // Randomly choose horizontal-first or vertical-first
                if (Math.random() < 0.5) {
                    // Horizontal then vertical
                    while (cx !== b.cx) {
                        this.set(cx, cy, 1);
                        // Widen corridor occasionally
                        if (Math.random() < 0.3) this.set(cx, cy + 1, 1);
                        cx += cx < b.cx ? 1 : -1;
                    }
                    while (cy !== b.cy) {
                        this.set(cx, cy, 1);
                        if (Math.random() < 0.3) this.set(cx + 1, cy, 1);
                        cy += cy < b.cy ? 1 : -1;
                    }
                } else {
                    // Vertical then horizontal
                    while (cy !== b.cy) {
                        this.set(cx, cy, 1);
                        if (Math.random() < 0.3) this.set(cx + 1, cy, 1);
                        cy += cy < b.cy ? 1 : -1;
                    }
                    while (cx !== b.cx) {
                        this.set(cx, cy, 1);
                        if (Math.random() < 0.3) this.set(cx, cy + 1, 1);
                        cx += cx < b.cx ? 1 : -1;
                    }
                }
                this.set(cx, cy, 1);
            }

            // Extra connections for loops (makes dungeon more interesting)
            const extraLoops = rand(2, Math.min(this.rooms.length - 1, 5));
            for (let i = 0; i < extraLoops; i++) {
                const a = this.rooms[rand(0, this.rooms.length - 1)];
                const b = this.rooms[rand(0, this.rooms.length - 1)];
                if (a === b) continue;
                let cx = a.cx, cy = a.cy;
                // Slightly drunk walk for organic corridors
                while (cx !== b.cx || cy !== b.cy) {
                    this.set(cx, cy, 1);
                    if (Math.random() < 0.15 && cx !== b.cx && cy !== b.cy) {
                        // Random wobble
                        if (Math.random() < 0.5) cx += cx < b.cx ? 1 : -1;
                        else cy += cy < b.cy ? 1 : -1;
                    } else {
                        // Move toward target
                        if (Math.abs(b.cx - cx) > Math.abs(b.cy - cy))
                            cx += cx < b.cx ? 1 : -1;
                        else
                            cy += cy < b.cy ? 1 : -1;
                    }
                }
                this.set(cx, cy, 1);
            }

            // Place stairs in the room farthest from start
            const startRoom = this.rooms[0];
            let farthestRoom = this.rooms[this.rooms.length - 1];
            let farthestDist = 0;
            for (const r of this.rooms) {
                const d = Math.hypot(r.cx - startRoom.cx, r.cy - startRoom.cy);
                if (d > farthestDist) { farthestDist = d; farthestRoom = r; }
            }
            this.stairsX = farthestRoom.cx;
            this.stairsY = farthestRoom.cy;
            this.set(this.stairsX, this.stairsY, 2);

            // Chests in some rooms (never in first or stairs room)
            for (let i = 1; i < this.rooms.length; i++) {
                const r = this.rooms[i];
                if (r === farthestRoom) continue;
                if (Math.random() < 0.3) {
                    const cx = r.x + rand(1, r.w - 2);
                    const cy = r.y + rand(1, r.h - 2);
                    if (this.get(cx, cy) === 1) this.set(cx, cy, 3);
                }
            }

            // Scatter some random floor decorations (pillars = unwalkable in floor)
            for (const r of this.rooms) {
                if (r.w >= 7 && r.h >= 6 && Math.random() < 0.4) {
                    // Add pillars to big rooms
                    const px1 = r.x + 2, py1 = r.y + 2;
                    const px2 = r.x + r.w - 3, py2 = r.y + r.h - 3;
                    this.set(px1, py1, 0); this.set(px2, py1, 0);
                    this.set(px1, py2, 0); this.set(px2, py2, 0);
                }
            }
        }

        reveal(px, py, radius) {
            const tr = Math.ceil(radius / TILE);
            const tx = Math.floor(px / TILE), ty = Math.floor(py / TILE);
            for (let dy = -tr; dy <= tr; dy++) {
                for (let dx = -tr; dx <= tr; dx++) {
                    const xx = tx + dx, yy = ty + dy;
                    if (xx >= 0 && xx < MAP_W && yy >= 0 && yy < MAP_H) {
                        if (dx*dx + dy*dy <= tr*tr) this.explored[this.idx(xx, yy)] = 1;
                    }
                }
            }
        }

        draw(camX, camY) {
            const startX = Math.max(0, Math.floor(camX / TILE) - 1);
            const startY = Math.max(0, Math.floor(camY / TILE) - 1);
            const endX = Math.min(MAP_W, startX + Math.ceil(W / TILE) + 3);
            const endY = Math.min(MAP_H, startY + Math.ceil(H / TILE) + 3);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const sx = x * TILE - camX, sy = y * TILE - camY;
                    const t = this.get(x, y);

                    if (t === 0) {
                        // === WALL ===
                        const hasFloorBelow = this.walkable(x, y + 1);
                        const hasFloorRight = this.walkable(x + 1, y);
                        const hasFloorLeft = this.walkable(x - 1, y);
                        const hasFloorAbove = this.walkable(x, y - 1);
                        const isExposed = hasFloorBelow || hasFloorRight || hasFloorLeft || hasFloorAbove;

                        if (isExposed) {
                            // Pre-rendered wall texture
                            const wallTex = (x + y) % 2 === 0 ? TILE_TEXTURES['wall'] : TILE_TEXTURES['wall2'];
                            ctx.drawImage(wallTex, sx, sy);

                            // 3D wall face below
                            if (hasFloorBelow) {
                                ctx.drawImage(TILE_TEXTURES['wall_face'], sx, sy + TILE - 10);
                            }

                            // Moss (deterministic)
                            if ((x * 13 + y * 7) % 23 === 0) {
                                ctx.fillStyle = 'rgba(35,60,25,0.2)';
                                ctx.fillRect(sx + 2, sy + TILE - 14, 8, 5);
                                ctx.fillStyle = 'rgba(40,70,28,0.15)';
                                ctx.fillRect(sx + 4, sy + TILE - 16, 4, 3);
                            }

                            // Wall crack
                            if ((x * 11 + y * 3) % 31 === 0) {
                                ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                                ctx.lineWidth = 0.5;
                                ctx.beginPath();
                                ctx.moveTo(sx + 10, sy + 4);
                                ctx.lineTo(sx + 16, sy + 14);
                                ctx.lineTo(sx + 13, sy + 28);
                                ctx.stroke();
                            }
                        } else {
                            ctx.drawImage(TILE_TEXTURES['deep_wall'], sx, sy);
                        }

                        // Torch on wall (animated sprite)
                        if (isExposed && (x * 7 + y * 13) % 29 === 0) {
                            const torchFrame = Math.floor((G.time * 6 + x * 3 + y * 5) % 6);
                            drawSpr('torch' + torchFrame, sx, sy, TILE, TILE);
                            // Warm glow around torch
                            const fl = Math.sin(G.time * 8 + x * 3 + y * 5) * 2;
                            const gr = 45 + fl * 3;
                            ctx.globalAlpha = 0.08;
                            ctx.fillStyle = '#ff8020';
                            ctx.beginPath();
                            ctx.arc(sx + TILE/2, sy + TILE/2 - 4, gr, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }

                    } else if (t === 1) {
                        // === FLOOR ===
                        const variant = ((x * 7 + y * 13) % 4);
                        ctx.drawImage(TILE_TEXTURES['floor_' + variant], sx, sy);

                        // Blood splatters (deterministic)
                        const bloodHash = (x * 17 + y * 31) % 53;
                        if (bloodHash < 3) {
                            ctx.drawImage(TILE_TEXTURES['blood_' + (bloodHash % 3)], sx, sy);
                        }

                        // Bone fragment
                        if ((x * 23 + y * 11) % 67 < 2) {
                            ctx.fillStyle = 'rgba(160,150,120,0.12)';
                            ctx.save();
                            ctx.translate(sx + 18, sy + 24);
                            ctx.rotate((x * 3 + y * 7) * 0.7);
                            ctx.fillRect(-5, -1, 10, 2);
                            ctx.fillRect(-2, -3, 2, 6); // cross bone
                            ctx.restore();
                        }

                        // Pebble
                        if ((x * 19 + y * 29) % 41 < 3) {
                            ctx.fillStyle = 'rgba(50,45,38,0.5)';
                            ctx.beginPath();
                            ctx.arc(sx + ((x * 7) % 30) + 5, sy + ((y * 11) % 30) + 5, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Wall shadows
                        if (this.get(x, y - 1) === 0) {
                            ctx.drawImage(TILE_TEXTURES['shadow_top'], sx, sy);
                        }
                        if (this.get(x - 1, y) === 0) {
                            ctx.drawImage(TILE_TEXTURES['shadow_left'], sx, sy);
                        }

                    } else if (t === 2) {
                        // === STAIRS (Sprite) ===
                        const variant = ((x * 7 + y * 13) % 4);
                        ctx.drawImage(TILE_TEXTURES['floor_' + variant], sx, sy);
                        drawSpr('stairsDown', sx, sy, TILE, TILE);

                        // Mystical glow
                        const sg = ctx.createRadialGradient(sx + TILE/2, sy + TILE/2, 0, sx + TILE/2, sy + TILE/2, TILE * 1.3);
                        sg.addColorStop(0, 'rgba(100,70,180,0.3)');
                        sg.addColorStop(0.4, 'rgba(100,70,180,0.1)');
                        sg.addColorStop(1, 'rgba(100,70,180,0)');
                        ctx.fillStyle = sg;
                        ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE * 2, TILE * 2);

                        // Sparkles
                        for (let i = 0; i < 3; i++) {
                            const sa = G.time * 2 + i * 2.1;
                            const spx = sx + TILE/2 + Math.cos(sa) * 12;
                            const spy = sy + TILE/2 + Math.sin(sa * 1.3) * 10 - 4;
                            ctx.fillStyle = `rgba(180,160,255,${0.2 + Math.sin(sa * 3) * 0.15})`;
                            ctx.beginPath();
                            ctx.arc(spx, spy, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }

                    } else if (t === 3) {
                        // === CHEST (Sprite) ===
                        const variant = ((x * 7 + y * 13) % 4);
                        ctx.drawImage(TILE_TEXTURES['floor_' + variant], sx, sy);
                        drawSpr('chestClosed', sx, sy, TILE, TILE);
                        // Gold glow
                        ctx.globalAlpha = 0.12;
                        ctx.fillStyle = '#c8a030';
                        ctx.beginPath();
                        ctx.arc(sx + TILE/2, sy + TILE/2, TILE * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }
    }

    // ========== ITEM SYSTEM ==========
    const ITEM_TYPES = {
        sword:   { name: 'å‰£', icon: 'âš”', slot: 'weapon', baseDmg: [5, 12] },
        axe:     { name: 'æˆ¦æ–§', icon: 'ğŸª“', slot: 'weapon', baseDmg: [8, 16] },
        staff:   { name: 'æ–', icon: 'ğŸ”®', slot: 'weapon', baseDmg: [3, 8] },
        shield:  { name: 'ç›¾', icon: 'ğŸ›¡', slot: 'offhand', baseDef: [3, 8] },
        helmet:  { name: 'å…œ', icon: 'â›‘', slot: 'head', baseDef: [2, 5] },
        armor:   { name: 'é§', icon: 'ğŸ¦º', slot: 'body', baseDef: [4, 10] },
        ring:    { name: 'æŒ‡è¼ª', icon: 'ğŸ’', slot: 'ring', baseDef: [0, 1] },
        amulet:  { name: 'è­·ç¬¦', icon: 'ğŸ“¿', slot: 'amulet', baseDef: [0, 1] },
        boots:   { name: 'é´', icon: 'ğŸ‘¢', slot: 'feet', baseDef: [1, 4] },
        potion:  { name: 'å›å¾©è–¬', icon: 'ğŸ§ª', slot: null, heal: 50 }
    };

    const RARITY = {
        common:    { name: 'ã‚³ãƒ¢ãƒ³', color: '#cccccc', affixes: 0, mult: 1 },
        magic:     { name: 'ãƒã‚¸ãƒƒã‚¯', color: '#6688ff', affixes: [1,2], mult: 1.3 },
        rare:      { name: 'ãƒ¬ã‚¢', color: '#ffdd44', affixes: [2,3], mult: 1.6 },
        legendary: { name: 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼', color: '#ff8800', affixes: [3,4], mult: 2.0 },
        unique:    { name: 'ãƒ¦ãƒ‹ãƒ¼ã‚¯', color: '#00dd66', affixes: [4,5], mult: 2.5 }
    };

    function pickRarity(r) {
        return r < 0.50 ? 'common' :
               r < 0.78 ? 'magic' :
               r < 0.93 ? 'rare' :
               r < 0.99 ? 'legendary' : 'unique';
    }
    function getAffixCount(rarity) {
        return Array.isArray(rarity.affixes)
            ? rand(rarity.affixes[0], rarity.affixes[1])
            : rarity.affixes;
    }

    const AFFIXES = [
        { stat: 'str', fmt: '+{v} ç­‹åŠ›', min: 1, max: 8 },
        { stat: 'dex', fmt: '+{v} æ•æ·', min: 1, max: 8 },
        { stat: 'vit', fmt: '+{v} ä½“åŠ›', min: 1, max: 8 },
        { stat: 'int', fmt: '+{v} çŸ¥åŠ›', min: 1, max: 8 },
        { stat: 'dmgPct', fmt: '+{v}% ãƒ€ãƒ¡ãƒ¼ã‚¸', min: 3, max: 25 },
        { stat: 'hp', fmt: '+{v} HP', min: 10, max: 80 },
        { stat: 'mp', fmt: '+{v} MP', min: 10, max: 60 },
        { stat: 'lifesteal', fmt: '{v}% ãƒ©ã‚¤ãƒ•ã‚¹ãƒ†ã‚£ãƒ¼ãƒ«', min: 2, max: 10 },
        { stat: 'atkSpd', fmt: '+{v}% æ”»æ’ƒé€Ÿåº¦', min: 5, max: 20 },
        { stat: 'def', fmt: '+{v} é˜²å¾¡', min: 2, max: 12 },
        { stat: 'critChance', fmt: '+{v}% ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«', min: 2, max: 10 },
        { stat: 'moveSpd', fmt: '+{v}% ç§»å‹•é€Ÿåº¦', min: 3, max: 15 }
    ];

    const UNIQUE_NAMES = {
        sword: ['é­”å‰£ãƒ€ãƒ¼ãƒ³ã‚¹ãƒ¬ã‚¤ãƒ´', 'ç‚ã®æ–­è£‚', 'è™šç©ºã®ç‰™'],
        axe: ['ç²‰ç •è€…', 'è¡€å¡—ã‚Œã®ä¸‰æ—¥æœˆ', 'åµã®åˆƒ'],
        staff: ['ä¸æ­»é³¥ã®æ–', 'æš—é»’ã®å¤§æ–', 'æ˜Ÿéœœã®å°ã'],
        shield: ['ä¸æ»…ã®å£', 'å®ˆè­·è€…ã®èª“ã„'],
        helmet: ['é¾ç‹ã®å† ', 'æ·±æ·µã®é¢'],
        armor: ['ä¸å±ˆã®é§', 'ç…‰ç„ã®èƒ¸å½“ã¦'],
        ring: ['é‹å‘½ã®ç’°', 'é—‡ã®ç³'],
        amulet: ['é­‚ã®é¦–é£¾ã‚Š', 'æ°¸é ã®å¿ƒè‡“'],
        boots: ['ç–¾é¢¨ã®é´', 'å½±æ¸¡ã‚Šã®é•·é´']
    };

    function generateItem(floor, forceRarity = null) {
        const typeKeys = Object.keys(ITEM_TYPES).filter(k => k !== 'potion');
        const typeKey = typeKeys[rand(0, typeKeys.length - 1)];
        const typeInfo = ITEM_TYPES[typeKey];

        let rarityKey = forceRarity;
        if (!rarityKey) {
            const r = Math.random();
            rarityKey = pickRarity(r);
        }
        const rarity = RARITY[rarityKey];

        const floorMult = 1 + (floor - 1) * 0.2;
        const item = {
            typeKey, typeInfo, rarityKey, rarity,
            icon: typeInfo.icon,
            affixes: [],
            baseDmg: typeInfo.baseDmg ? [Math.round(typeInfo.baseDmg[0] * rarity.mult * floorMult), Math.round(typeInfo.baseDmg[1] * rarity.mult * floorMult)] : null,
            baseDef: typeInfo.baseDef ? Math.round((typeInfo.baseDef[0] + rand(0, typeInfo.baseDef[1] - typeInfo.baseDef[0])) * rarity.mult * floorMult) : null,
        };

        // Name
        if (rarityKey === 'unique' && UNIQUE_NAMES[typeKey]) {
            const names = UNIQUE_NAMES[typeKey];
            item.name = names[rand(0, names.length - 1)];
        } else {
            const prefixes = ['å‘ªã‚ã‚Œã—', 'è–ãªã‚‹', 'å¤ä»£ã®', 'é›ãˆã‚‰ã‚Œã—', 'æœ½ã¡ãŸ', 'è¼ã', 'è¡€æŸ“ã‚ã®', 'å½±ã®', 'è’¼ã', 'ç¼ç†±ã®'];
            const prefix = rarityKey !== 'common' ? prefixes[rand(0, prefixes.length-1)] + ' ' : '';
            item.name = prefix + typeInfo.name;
        }

        // Generate affixes
        const affixCount = getAffixCount(rarity);
        const pool = [...AFFIXES];
        for (let i = 0; i < affixCount && pool.length > 0; i++) {
            const idx = rand(0, pool.length - 1);
            const a = pool.splice(idx, 1)[0];
            const v = Math.round(rand(a.min, a.max) * floorMult);
            item.affixes.push({ stat: a.stat, value: v, text: a.fmt.replace('{v}', v) });
        }

        return item;
    }

    function generatePotion() {
        return {
            typeKey: 'potion', typeInfo: ITEM_TYPES.potion, rarityKey: 'common',
            rarity: RARITY.common, icon: 'ğŸ§ª', name: 'å›å¾©è–¬',
            affixes: [], baseDmg: null, baseDef: null
        };
    }

    // ========== CLASS DEFINITIONS ==========
    const CLASS_DEFS = {
        warrior: {
            name: 'ãƒãƒ¼ãƒãƒªã‚¢ãƒ³', icon: 'âš”', engName: 'BARBARIAN', tier: 0,
            sprite: 'knight',
            baseStr: 20, baseDex: 10, baseVit: 20, baseInt: 5,
            branches: ['ã‚³ãƒ³ãƒãƒƒãƒˆã‚¹ã‚­ãƒ«', 'ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤', 'ãƒã‚¹ã‚¿ãƒªãƒ¼'],
            promotions: ['paladin', 'berserker'],
            skills: [
                { id: 'w_bash', name: 'ãƒãƒƒã‚·ãƒ¥', icon: 'ğŸ’¥', mp: 8, cd: 0.8, branch: 0,
                  desc: 'å¼·æ‰“ã§æ•µã‚’æ€¯ã¾ã›ãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: null,
                  effect: 'melee_burst', baseMult: [1.8, 2.4, 3.2], range: 60 },
                { id: 'w_doubleswing', name: 'ãƒ€ãƒ–ãƒ«ã‚¹ã‚¤ãƒ³ã‚°', icon: 'âš”', mp: 18, cd: 2.0, branch: 0,
                  desc: 'äºŒåˆ€ã§åŒæ™‚ã«æ–¬ã‚Šã¤ã‘ã‚‹', prereq: 'w_bash',
                  effect: 'whirlwind', baseMult: [1.4, 2.0, 2.8], range: 80 },
                { id: 'w_whirlwind', name: 'ãƒ¯ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰', icon: 'ğŸŒ€', mp: 30, cd: 3.0, branch: 0,
                  desc: 'å›è»¢ã—ãªãŒã‚‰å‘¨å›²ã®å…¨æ•µã‚’æ–¬ã‚Šè£‚ã', prereq: 'w_doubleswing',
                  effect: 'whirlwind', baseMult: [1.6, 2.2, 3.5], range: 120 },
                { id: 'w_howl', name: 'ãƒã‚¦ãƒ«', icon: 'ğŸ“¯', mp: 12, cd: 5.0, branch: 1,
                  desc: 'é›„å«ã³ã§å‘¨å›²ã®æ•µã‚’æ€¯ã¾ã›ã‚‹', prereq: null,
                  effect: 'stun_aoe', duration: [1.5, 2.0, 3.0], range: 130 },
                { id: 'w_shout', name: 'ã‚·ãƒ£ã‚¦ãƒˆ', icon: 'ğŸ›¡', mp: 20, cd: 8.0, branch: 1,
                  desc: 'å’†å“®ã§é˜²å¾¡åŠ›ã‚’ä¸Šæ˜‡', prereq: 'w_howl',
                  effect: 'buff_defense', duration: [6, 8, 12], reduction: [0.4, 0.5, 0.65] },
                { id: 'w_battleorders', name: 'ãƒãƒˆãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼', icon: 'âšœ', mp: 35, cd: 15.0, branch: 1,
                  desc: 'HP/MPã®æœ€å¤§å€¤ã‚’ä¸€æ™‚çš„ã«ä¸Šæ˜‡', prereq: 'w_shout',
                  effect: 'battle_orders', duration: [10, 15, 20], bonus: [0.2, 0.35, 0.5] },
                { id: 'w_leap', name: 'ãƒªãƒ¼ãƒ—ã‚¢ã‚¿ãƒƒã‚¯', icon: 'ğŸ¦˜', mp: 15, cd: 4.0, branch: 2,
                  desc: 'è·³èºã—ã¦ç€åœ°æ™‚ã«å‘¨å›²ã«ãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: null,
                  effect: 'charge', baseMult: [2.0, 2.8, 4.0], range: 220 },
                { id: 'w_ironskin', name: 'ã‚¢ã‚¤ã‚¢ãƒ³ã‚¹ã‚­ãƒ³', icon: 'ğŸ”°', mp: 25, cd: 12.0, branch: 2,
                  desc: 'é‰„ã®è‚Œã§é˜²å¾¡åŠ›ã‚’å¤§å¹…ä¸Šæ˜‡', prereq: 'w_leap',
                  effect: 'buff_defense', duration: [8, 10, 14], reduction: [0.5, 0.6, 0.75] },
                { id: 'w_berserk', name: 'ãƒãƒ¼ã‚µãƒ¼ã‚¯', icon: 'ğŸ‘¹', mp: 35, cd: 12.0, branch: 2,
                  desc: 'ç‹‚æ°—ã®åŠ›ã§æ”»æ’ƒåŠ›2å€ã€‚è¢«ãƒ€ãƒ¡å¢—åŠ ', prereq: 'w_ironskin',
                  effect: 'buff_berserk', duration: [8, 10, 14] }
            ]
        },
        rogue: {
            name: 'ã‚¢ãƒã‚¾ãƒ³', icon: 'ğŸ¹', engName: 'AMAZON', tier: 0,
            sprite: 'rogueChar',
            baseStr: 10, baseDex: 20, baseVit: 15, baseInt: 10,
            branches: ['å¼“ã‚¹ã‚­ãƒ«', 'ã‚¸ãƒ£ãƒ™ãƒªãƒ³', 'ãƒ‘ãƒƒã‚·ãƒ–'],
            promotions: ['assassin', 'ranger'],
            skills: [
                { id: 'r_firearrow', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ”¥', mp: 8, cd: 0.8, branch: 0,
                  desc: 'ç‚ã‚’çºã£ãŸçŸ¢ã‚’æ”¾ã¤', prereq: null,
                  effect: 'projectile_fire', baseMult: [1.6, 2.2, 3.0], speed: 400 },
                { id: 'r_multishot', name: 'ãƒãƒ«ãƒãƒ—ãƒ«ã‚·ãƒ§ãƒƒãƒˆ', icon: 'ğŸŒŸ', mp: 22, cd: 2.5, branch: 0,
                  desc: 'æ‰‡çŠ¶ã«è¤‡æ•°ã®çŸ¢ã‚’åŒæ™‚ç™ºå°„', prereq: 'r_firearrow',
                  effect: 'multi_shot', arrows: [3, 5, 7], baseMult: [1.0, 1.4, 1.8] },
                { id: 'r_strafe', name: 'ã‚¹ãƒˆãƒ¬ã‚¤ãƒ•', icon: 'ğŸ¯', mp: 35, cd: 5.0, branch: 0,
                  desc: 'å‘¨å›²ã®å…¨æ•µã«çŸ¢ã‚’é€£å°„', prereq: 'r_multishot',
                  effect: 'arrow_rain', baseMult: [2.0, 3.0, 4.5], range: 100 },
                { id: 'r_jab', name: 'ã‚¸ãƒ£ãƒ–', icon: 'ğŸ”±', mp: 10, cd: 1.0, branch: 1,
                  desc: 'æ§ã§ç´ æ—©ãçªã', prereq: null,
                  effect: 'melee_burst', baseMult: [1.8, 2.4, 3.2], range: 55 },
                { id: 'r_powerstrike', name: 'ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'âš¡', mp: 18, cd: 3.0, branch: 1,
                  desc: 'é›·ã‚’çºã£ãŸå¼·åŠ›ãªçªã', prereq: 'r_jab',
                  effect: 'melee_burst', baseMult: [2.5, 3.5, 5.0], range: 60 },
                { id: 'r_ltfury', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ãƒ•ãƒ¥ãƒ¼ãƒªãƒ¼', icon: 'ğŸŒ©', mp: 40, cd: 6.0, branch: 1,
                  desc: 'é›·ã®ã‚¸ãƒ£ãƒ™ãƒªãƒ³ãŒæ•µé–“ã§é€£é–', prereq: 'r_powerstrike',
                  effect: 'chain_lightning', bounces: [3, 4, 6], baseMult: [2.0, 3.0, 4.5] },
                { id: 'r_innersight', name: 'ã‚¤ãƒ³ãƒŠãƒ¼ã‚µã‚¤ãƒˆ', icon: 'ğŸ‘', mp: 15, cd: 8.0, branch: 2,
                  desc: 'æ•µã®é˜²å¾¡åŠ›ã‚’ä½ä¸‹ã•ã›ã‚‹', prereq: null,
                  effect: 'debuff_defense', duration: [4, 6, 8], reduction: [0.3, 0.45, 0.6], range: 150 },
                { id: 'r_critstrike', name: 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸ’', mp: 18, cd: 10.0, branch: 2,
                  desc: 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡ã‚’å¤§å¹…ä¸Šæ˜‡', prereq: 'r_innersight',
                  effect: 'buff_crit', duration: [6, 8, 12], bonus: [20, 35, 50] },
                { id: 'r_valkyrie', name: 'ãƒ´ã‚¡ãƒ«ã‚­ãƒªãƒ¼', icon: 'ğŸ›¡', mp: 45, cd: 20.0, branch: 2,
                  desc: 'æˆ¦ä¹™å¥³ã‚’å¬å–šã—å…±ã«æˆ¦ã†', prereq: 'r_critstrike',
                  effect: 'summon_minion', duration: [12, 18, 25], minionHP: [200, 350, 500], minionDmg: [15, 25, 40] }
            ]
        },
        sorcerer: {
            name: 'ã‚½ãƒ¼ã‚µãƒ¬ã‚¹', icon: 'ğŸ”®', engName: 'SORCERESS', tier: 0,
            sprite: 'wizardM',
            baseStr: 5, baseDex: 10, baseVit: 10, baseInt: 25,
            branches: ['ãƒ•ã‚¡ã‚¤ã‚¢ã‚¹ãƒšãƒ«', 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°', 'ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒšãƒ«'],
            promotions: ['pyromancer', 'cryomancer'],
            skills: [
                { id: 's_firebolt', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ«ãƒˆ', icon: 'ğŸ”¥', mp: 8, cd: 0.6, branch: 0,
                  desc: 'ç‚ã®å¼¾ã‚’ç™ºå°„ã™ã‚‹', prereq: null,
                  effect: 'projectile_fire', baseMult: [1.6, 2.2, 3.0], speed: 350 },
                { id: 's_fireball', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ«', icon: 'â˜€', mp: 18, cd: 1.5, branch: 0,
                  desc: 'çˆ†ç™ºã™ã‚‹å¤§ããªç«çƒ', prereq: 's_firebolt',
                  effect: 'projectile_fire', baseMult: [2.5, 3.5, 5.0], speed: 320 },
                { id: 's_meteor', name: 'ãƒ¡ãƒ†ã‚ª', icon: 'â˜„', mp: 50, cd: 8.0, branch: 0,
                  desc: 'å¤©ã‹ã‚‰å·¨å¤§éš•çŸ³ã‚’é™ã‚‰ã›å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: 's_fireball',
                  effect: 'meteor', baseMult: [3.5, 5.0, 7.0], range: 110 },
                { id: 's_chargedbolt', name: 'ãƒãƒ£ãƒ¼ã‚¸ãƒ‰ãƒœãƒ«ãƒˆ', icon: 'âš¡', mp: 10, cd: 1.0, branch: 1,
                  desc: 'è¤‡æ•°ã®ç¨²å¦»ã‚’æ”¾å°„çŠ¶ã«æ”¾ã¤', prereq: null,
                  effect: 'multi_shot', arrows: [3, 4, 6], baseMult: [1.2, 1.6, 2.2] },
                { id: 's_lightning', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°', icon: 'ğŸŒ©', mp: 22, cd: 2.0, branch: 1,
                  desc: 'å¼·åŠ›ãªç›´ç·šã®ç¨²å¦»', prereq: 's_chargedbolt',
                  effect: 'chain_lightning', bounces: [2, 3, 5], baseMult: [1.8, 2.5, 3.5] },
                { id: 's_teleport', name: 'ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ', icon: 'âœ¨', mp: 18, cd: 2.5, branch: 1,
                  desc: 'æŒ‡å®šåœ°ç‚¹ã«ç¬é–“ç§»å‹•', prereq: 's_chargedbolt',
                  effect: 'teleport', range: [200, 280, 380] },
                { id: 's_icebolt', name: 'ã‚¢ã‚¤ã‚¹ãƒœãƒ«ãƒˆ', icon: 'ğŸ”·', mp: 8, cd: 0.8, branch: 2,
                  desc: 'æ°·ã®å¼¾ã‚’æ’ƒã¡å‡ºã™', prereq: null,
                  effect: 'projectile_fire', baseMult: [1.4, 2.0, 2.8], speed: 380 },
                { id: 's_frostnova', name: 'ãƒ•ãƒ­ã‚¹ãƒˆãƒãƒ´ã‚¡', icon: 'â„', mp: 20, cd: 4.0, branch: 2,
                  desc: 'å†·æ°—ã®è¡æ’ƒæ³¢ã§å‘¨å›²ã®æ•µã‚’å‡çµ', prereq: 's_icebolt',
                  effect: 'frost_nova', baseMult: [0.8, 1.2, 1.8], freeze: [2, 3, 5] },
                { id: 's_blizzard', name: 'ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰', icon: 'ğŸŒ¨', mp: 45, cd: 7.0, branch: 2,
                  desc: 'ç¯„å›²ã«æ°·ã®åµã‚’é™ã‚‰ã›æŒç¶šãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: 's_frostnova',
                  effect: 'arrow_rain', baseMult: [2.5, 3.5, 5.0], range: 120 }
            ]
        },
        paladin: {
            name: 'ãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³', icon: 'â›¨', engName: 'PALADIN', tier: 1,
            sprite: 'paladin', baseClass: 'warrior',
            baseStr: 22, baseDex: 10, baseVit: 25, baseInt: 8,
            branches: ['ã‚³ãƒ³ãƒãƒƒãƒˆ', 'ã‚ªãƒ•ã‚§ãƒ³ã‚¹ã‚ªãƒ¼ãƒ©', 'ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ã‚ªãƒ¼ãƒ©'],
            promotions: [],
            skills: [
                { id: 'p_smite', name: 'ã‚¹ãƒã‚¤ãƒˆ', icon: 'âœ', mp: 12, cd: 1.0, branch: 0,
                  desc: 'ç›¾ã§æ‰“ã¡æ®ãˆæ•µã‚’æ€¯ã¾ã›ã‚‹', prereq: null,
                  effect: 'melee_burst', baseMult: [2.0, 2.8, 3.8], range: 60 },
                { id: 'p_zeal', name: 'ã‚¸ãƒ¼ãƒ«', icon: 'âš”', mp: 22, cd: 6.0, branch: 0,
                  desc: 'è–ãªã‚‹æƒ…ç†±ã§æ”»æ’ƒé€Ÿåº¦ã‚’å¤§å¹…ä¸Šæ˜‡', prereq: 'p_smite',
                  effect: 'buff_atkspd', duration: [5, 7, 10], bonus: [0.5, 0.8, 1.2] },
                { id: 'p_blessedhammer', name: 'ãƒ–ãƒ¬ã‚¹ãƒ‰ãƒãƒ³ãƒãƒ¼', icon: 'ğŸ”¨', mp: 35, cd: 4.0, branch: 0,
                  desc: 'è–ãªã‚‹ãƒãƒ³ãƒãƒ¼ãŒèºæ—‹çŠ¶ã«é£›ã³ç¯„å›²ãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: 'p_zeal',
                  effect: 'holy_burst', baseMult: [2.5, 3.5, 5.0], range: 140 },
                { id: 'p_might', name: 'ãƒã‚¤ãƒˆ', icon: 'ğŸ’ª', mp: 20, cd: 10.0, branch: 1,
                  desc: 'æ”»æ’ƒåŠ›ã‚’å¤§å¹…ä¸Šæ˜‡ã™ã‚‹ã‚ªãƒ¼ãƒ©', prereq: null,
                  effect: 'buff_berserk', duration: [8, 12, 16] },
                { id: 'p_holyfire', name: 'ãƒ›ãƒ¼ãƒªãƒ¼ãƒ•ã‚¡ã‚¤ã‚¢', icon: 'ğŸ”¥', mp: 28, cd: 6.0, branch: 1,
                  desc: 'è–ãªã‚‹ç‚ã§è¶³å…ƒã‚’ç„¼ãå°½ãã™', prereq: 'p_might',
                  effect: 'consecrate', baseMult: [0.6, 1.0, 1.5], range: 100, duration: [4, 6, 8] },
                { id: 'p_fanaticism', name: 'ãƒ•ã‚¡ãƒŠãƒ†ã‚£ã‚·ã‚ºãƒ ', icon: 'ğŸ”±', mp: 40, cd: 15.0, branch: 1,
                  desc: 'æ”»æ’ƒé€Ÿåº¦ãƒ»ç§»å‹•é€Ÿåº¦ãƒ»ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å…¨ã¦ä¸Šæ˜‡', prereq: 'p_holyfire',
                  effect: 'buff_frenzy', duration: [8, 12, 16], atkBonus: [0.5, 0.7, 1.0], spdBonus: [0.3, 0.5, 0.7] },
                { id: 'p_prayer', name: 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼', icon: 'ğŸ’š', mp: 25, cd: 10.0, branch: 2,
                  desc: 'ç¥ˆã‚Šã§HPã‚’å¤§å¹…å›å¾©', prereq: null,
                  effect: 'self_heal_pct', pct: [0.25, 0.35, 0.50] },
                { id: 'p_defiance', name: 'ãƒ‡ã‚£ãƒ•ã‚¡ã‚¤ã‚¢ãƒ³ã‚¹', icon: 'ğŸ›¡', mp: 22, cd: 8.0, branch: 2,
                  desc: 'é˜²å¾¡åŠ›ã‚’å¤§å¹…ä¸Šæ˜‡ã™ã‚‹ã‚ªãƒ¼ãƒ©', prereq: 'p_prayer',
                  effect: 'buff_defense', duration: [6, 8, 12], reduction: [0.5, 0.6, 0.75] },
                { id: 'p_salvation', name: 'ã‚µãƒ«ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³', icon: 'âœ¨', mp: 45, cd: 20.0, branch: 2,
                  desc: 'å…¨å±æ€§è€æ€§ã¨HPå›å¾©ã®ç©¶æ¥µã‚ªãƒ¼ãƒ©', prereq: 'p_defiance',
                  effect: 'buff_aura', duration: [10, 15, 20], regen: [5, 10, 15], reduction: [0.3, 0.4, 0.5] }
            ]
        },
        berserker: {
            name: 'ãƒãƒ¼ã‚µãƒ¼ã‚«ãƒ¼', icon: 'ğŸª“', engName: 'BERSERKER', tier: 1,
            sprite: 'berserker', baseClass: 'warrior',
            baseStr: 28, baseDex: 12, baseVit: 18, baseInt: 3,
            branches: ['ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼', 'ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤', 'ãƒã‚¹ã‚¿ãƒªãƒ¼'],
            promotions: [],
            skills: [
                { id: 'b_frenzy', name: 'ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼', icon: 'ğŸ˜¤', mp: 20, cd: 8.0, branch: 0,
                  desc: 'æ”»æ’ƒã¨ç§»å‹•é€Ÿåº¦ãŒçˆ†ç™ºçš„ã«ä¸Šæ˜‡', prereq: null,
                  effect: 'buff_frenzy', duration: [6, 8, 12], atkBonus: [0.5, 0.7, 1.0], spdBonus: [0.3, 0.5, 0.7] },
                { id: 'b_concentrate', name: 'ã‚³ãƒ³ã‚»ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆ', icon: 'ğŸ¯', mp: 14, cd: 1.5, branch: 0,
                  desc: 'é›†ä¸­ã—ãŸå¼·åŠ›ãªä¸€æ’ƒ', prereq: 'b_frenzy',
                  effect: 'melee_burst', baseMult: [2.5, 3.5, 5.0], range: 60 },
                { id: 'b_whirlwind', name: 'ãƒ¯ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰', icon: 'ğŸŒ€', mp: 35, cd: 3.0, branch: 0,
                  desc: 'å…¨ã¦ã‚’å·»ãè¾¼ã‚€è¶…æ—‹é¢¨', prereq: 'b_concentrate',
                  effect: 'whirlwind', baseMult: [2.0, 3.0, 4.5], range: 150 },
                { id: 'b_warcry', name: 'ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤', icon: 'ğŸ“¯', mp: 22, cd: 6.0, branch: 1,
                  desc: 'å’†å“®ã§å‘¨å›²ã®å…¨æ•µã‚’ã‚¹ã‚¿ãƒ³', prereq: null,
                  effect: 'stun_aoe', duration: [2.0, 3.0, 4.0], range: 140 },
                { id: 'b_battlecmd', name: 'ãƒãƒˆãƒ«ã‚³ãƒãƒ³ãƒ‰', icon: 'ğŸ–', mp: 25, cd: 10.0, branch: 1,
                  desc: 'æ”»æ’ƒé€Ÿåº¦ã‚’å¤§å¹…ä¸Šæ˜‡ã™ã‚‹å·ä»¤', prereq: 'b_warcry',
                  effect: 'buff_atkspd', duration: [6, 8, 12], bonus: [0.5, 0.7, 1.0] },
                { id: 'b_battleorders', name: 'ãƒãƒˆãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼', icon: 'âšœ', mp: 40, cd: 18.0, branch: 1,
                  desc: 'HP/MPæœ€å¤§å€¤ã‚’å¤§å¹…ä¸Šæ˜‡', prereq: 'b_battlecmd',
                  effect: 'battle_orders', duration: [12, 18, 25], bonus: [0.3, 0.45, 0.6] },
                { id: 'b_leap', name: 'ãƒªãƒ¼ãƒ—ã‚¢ã‚¿ãƒƒã‚¯', icon: 'ğŸ¦˜', mp: 16, cd: 3.5, branch: 2,
                  desc: 'è·³èºã—ã¦æ•µé™£ã«é£›ã³è¾¼ã‚€', prereq: null,
                  effect: 'charge', baseMult: [2.2, 3.0, 4.2], range: 230 },
                { id: 'b_natres', name: 'ãƒŠãƒãƒ¥ãƒ©ãƒ«ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ³ã‚¹', icon: 'ğŸ›¡', mp: 28, cd: 12.0, branch: 2,
                  desc: 'å¼·é­ãªè‚‰ä½“ã§å…¨ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›', prereq: 'b_leap',
                  effect: 'buff_defense', duration: [8, 12, 16], reduction: [0.5, 0.6, 0.75] },
                { id: 'b_berserk', name: 'ãƒãƒ¼ã‚µãƒ¼ã‚¯', icon: 'ğŸ’€', mp: 40, cd: 10.0, branch: 2,
                  desc: 'é˜²å¾¡ã‚’æ¨ã¦åœ§å€’çš„æ”»æ’ƒåŠ›ã€‚ä½HPæ•µã«ç‰¹åŠ¹', prereq: 'b_natres',
                  effect: 'execute', baseMult: [4.0, 6.0, 9.0], threshold: [0.5, 0.6, 0.7], range: 70 }
            ]
        },
        assassin: {
            name: 'ã‚¢ã‚µã‚·ãƒ³', icon: 'ğŸ—¡', engName: 'ASSASSIN', tier: 1,
            sprite: 'assassin', baseClass: 'rogue',
            baseStr: 14, baseDex: 26, baseVit: 12, baseInt: 12,
            branches: ['ãƒãƒ¼ã‚·ãƒ£ãƒ«ã‚¢ãƒ¼ãƒ„', 'ã‚·ãƒ£ãƒ‰ã‚¦', 'ãƒˆãƒ©ãƒƒãƒ—'],
            promotions: [],
            skills: [
                { id: 'a_tigerstrike', name: 'ã‚¿ã‚¤ã‚¬ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸ¯', mp: 10, cd: 1.0, branch: 0,
                  desc: 'æ°—ã‚’æºœã‚ãŸå¼·åŠ›ãªæ‰“æ’ƒ', prereq: null,
                  effect: 'melee_burst', baseMult: [2.2, 3.0, 4.2], range: 55 },
                { id: 'a_dragontalon', name: 'ãƒ‰ãƒ©ã‚´ãƒ³ã‚¿ãƒ­ãƒ³', icon: 'ğŸ‰', mp: 20, cd: 2.5, branch: 0,
                  desc: 'ç¬é–“ç§»å‹•ã—ã¦èƒŒå¾Œã‹ã‚‰æ€¥æ‰€æ”»æ’ƒ', prereq: 'a_tigerstrike',
                  effect: 'shadow_strike', baseMult: [3.0, 4.5, 6.5] },
                { id: 'a_phoenixstrike', name: 'ãƒ•ã‚§ãƒ‹ãƒƒã‚¯ã‚¹ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸ”¥', mp: 40, cd: 8.0, branch: 0,
                  desc: 'ç‚ãƒ»æ°·ãƒ»é›·ãŒåŒæ™‚ã«ç‚¸è£‚ã™ã‚‹ç©¶æ¥µæ‰“æ’ƒ', prereq: 'a_dragontalon',
                  effect: 'execute', baseMult: [5.0, 7.0, 10.0], threshold: [1.0, 1.0, 1.0], range: 80 },
                { id: 'a_burstspeed', name: 'ãƒãƒ¼ã‚¹ãƒˆã‚ªãƒ–ã‚¹ãƒ”ãƒ¼ãƒ‰', icon: 'ğŸ’¨', mp: 15, cd: 10.0, branch: 1,
                  desc: 'ç§»å‹•é€Ÿåº¦ã¨æ”»æ’ƒé€Ÿåº¦ã‚’ä¸Šæ˜‡', prereq: null,
                  effect: 'buff_speed', duration: [6, 8, 12], bonus: [0.5, 0.7, 1.0] },
                { id: 'a_cloak', name: 'ã‚¯ãƒ­ãƒ¼ã‚¯ã‚ªãƒ–ã‚·ãƒ£ãƒ‰ã‚¦', icon: 'ğŸŒ‘', mp: 22, cd: 12.0, branch: 1,
                  desc: 'å½±ã«åŒ…ã¾ã‚Œæ•µã®å‘½ä¸­ç‡ä½ä¸‹', prereq: 'a_burstspeed',
                  effect: 'smoke_screen', duration: [4, 6, 8], range: 120, evade: [40, 55, 70] },
                { id: 'a_venom', name: 'ãƒ´ã‚§ãƒãƒ ', icon: 'â˜ ', mp: 28, cd: 10.0, branch: 1,
                  desc: 'æ­¦å™¨ã«çŒ›æ¯’ã‚’å¡—ã‚ŠæŒç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ä»˜ä¸', prereq: 'a_cloak',
                  effect: 'buff_poison', duration: [8, 12, 16], dps: [10, 18, 28] },
                { id: 'a_fireblast', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒ–ãƒ©ã‚¹ãƒˆ', icon: 'ğŸ’£', mp: 12, cd: 3.5, branch: 2,
                  desc: 'çˆ†ç™ºã™ã‚‹ç½ ã‚’è¨­ç½®', prereq: null,
                  effect: 'place_trap', baseMult: [2.0, 3.0, 4.5] },
                { id: 'a_ltgsentry', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ã‚»ãƒ³ãƒˆãƒªãƒ¼', icon: 'âš¡', mp: 25, cd: 5.0, branch: 2,
                  desc: 'é›·æ’ƒã‚’æ”¾ã¤è‡ªå‹•ç ²å°ã‚’è¨­ç½®', prereq: 'a_fireblast',
                  effect: 'consecrate', baseMult: [0.8, 1.2, 1.8], range: 90, duration: [5, 7, 10] },
                { id: 'a_deathsentry', name: 'ãƒ‡ã‚¹ã‚»ãƒ³ãƒˆãƒªãƒ¼', icon: 'ğŸ’€', mp: 40, cd: 10.0, branch: 2,
                  desc: 'å‘¨å›²ã®æ­»ä½“ã‚’çˆ†ç™ºã•ã›ç¯„å›²å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: 'a_ltgsentry',
                  effect: 'arrow_rain', baseMult: [3.0, 4.5, 6.5], range: 120 }
            ]
        },
        ranger: {
            name: 'ãƒ¬ãƒ³ã‚¸ãƒ£ãƒ¼', icon: 'ğŸ¹', engName: 'RANGER', tier: 1,
            sprite: 'rangerCls', baseClass: 'rogue',
            baseStr: 12, baseDex: 24, baseVit: 16, baseInt: 12,
            branches: ['ã‚¢ãƒ¼ãƒã‚§ãƒªãƒ¼', 'ã‚¹ãƒ”ã‚¢ã‚¹ã‚­ãƒ«', 'ãƒ‘ãƒƒã‚·ãƒ–'],
            promotions: [],
            skills: [
                { id: 'rg_guided', name: 'ã‚¬ã‚¤ãƒ‡ãƒƒãƒ‰ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ¯', mp: 12, cd: 0.8, branch: 0,
                  desc: 'å¿…ä¸­ã®è¿½å°¾çŸ¢ã‚’æ”¾ã¤', prereq: null,
                  effect: 'projectile_fire', baseMult: [2.0, 2.8, 4.0], speed: 500 },
                { id: 'rg_strafe', name: 'ã‚¹ãƒˆãƒ¬ã‚¤ãƒ•', icon: 'ğŸ¹', mp: 25, cd: 2.5, branch: 0,
                  desc: 'é«˜é€Ÿã§é€£å°„ã—å‘¨å›²ã‚’å°„æŠœã', prereq: 'rg_guided',
                  effect: 'multi_shot', arrows: [4, 6, 9], baseMult: [1.2, 1.6, 2.2] },
                { id: 'rg_immolation', name: 'ã‚¤ãƒ¢ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ”¥', mp: 40, cd: 6.0, branch: 0,
                  desc: 'ç€å¼¾åœ°ã‚’ç‚ä¸Šã•ã›ã‚‹çŸ¢', prereq: 'rg_strafe',
                  effect: 'arrow_rain', baseMult: [2.5, 3.5, 5.5], range: 100 },
                { id: 'rg_chargedstrike', name: 'ãƒãƒ£ãƒ¼ã‚¸ãƒ‰ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'âš¡', mp: 14, cd: 2.0, branch: 1,
                  desc: 'é›·ã‚’çºã£ãŸæ§ã§çªã', prereq: null,
                  effect: 'melee_burst', baseMult: [2.2, 3.2, 4.5], range: 60 },
                { id: 'rg_fend', name: 'ãƒ•ã‚§ãƒ³ãƒ‰', icon: 'ğŸ”±', mp: 22, cd: 4.0, branch: 1,
                  desc: 'æ§ã‚’æŒ¯ã‚Šå›ã—å‘¨å›²ã‚’è–™ãæ‰•ã†', prereq: 'rg_chargedstrike',
                  effect: 'whirlwind', baseMult: [1.8, 2.5, 3.5], range: 90 },
                { id: 'rg_ltfury', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ãƒ•ãƒ¥ãƒ¼ãƒªãƒ¼', icon: 'ğŸŒ©', mp: 45, cd: 7.0, branch: 1,
                  desc: 'é›·ã®ã‚¸ãƒ£ãƒ™ãƒªãƒ³ãŒè¤‡æ•°ã®æ•µã‚’é€£é–æ”»æ’ƒ', prereq: 'rg_fend',
                  effect: 'chain_lightning', bounces: [3, 5, 7], baseMult: [2.5, 3.5, 5.0] },
                { id: 'rg_penetrate', name: 'ãƒšãƒãƒˆãƒ¬ã‚¤ãƒˆ', icon: 'ğŸ’', mp: 18, cd: 12.0, branch: 2,
                  desc: 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡ã‚’å¤§å¹…ä¸Šæ˜‡', prereq: null,
                  effect: 'buff_crit', duration: [6, 8, 12], bonus: [25, 35, 50] },
                { id: 'rg_slowmissiles', name: 'ã‚¹ãƒ­ãƒ¼ãƒŸã‚µã‚¤ãƒ«', icon: 'ğŸ•¸', mp: 20, cd: 6.0, branch: 2,
                  desc: 'ç¯„å›²å†…ã®æ•µã‚’æ¸›é€Ÿ', prereq: 'rg_penetrate',
                  effect: 'stun_aoe', duration: [2.0, 3.0, 4.0], range: 120 },
                { id: 'rg_decoy', name: 'ãƒ‡ã‚³ã‚¤', icon: 'ğŸ‘¤', mp: 30, cd: 15.0, branch: 2,
                  desc: 'åˆ†èº«ã‚’ç”Ÿæˆã—ã¦æ•µã‚’æ”ªä¹±', prereq: 'rg_slowmissiles',
                  effect: 'buff_dodge', duration: [5, 8, 12], chance: [50, 65, 80] }
            ]
        },
        pyromancer: {
            name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚½ãƒ¼ã‚µãƒ¬ã‚¹', icon: 'ğŸ”¥', engName: 'FIRE SORCERESS', tier: 1,
            sprite: 'pyromancer', baseClass: 'sorcerer',
            baseStr: 5, baseDex: 10, baseVit: 12, baseInt: 30,
            branches: ['ãƒ•ã‚¡ã‚¤ã‚¢ã‚¹ãƒšãƒ«', 'ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆ', 'ã‚¤ãƒ³ãƒ•ã‚§ãƒ«ãƒ'],
            promotions: [],
            skills: [
                { id: 'py_fireball', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ«', icon: 'â˜€', mp: 14, cd: 0.6, branch: 0,
                  desc: 'å¼·åŒ–ã•ã‚ŒãŸç«çƒã‚’ç™ºå°„', prereq: null,
                  effect: 'projectile_fire', baseMult: [2.5, 3.5, 5.0], speed: 380 },
                { id: 'py_firewall', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«', icon: 'ğŸ§±', mp: 28, cd: 5.0, branch: 0,
                  desc: 'ç‚ã®å£ã‚’å±•é–‹ã—é€šéã™ã‚‹æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: 'py_fireball',
                  effect: 'consecrate', baseMult: [0.8, 1.2, 1.8], range: 80, duration: [4, 6, 8] },
                { id: 'py_meteor', name: 'ãƒ¡ãƒ†ã‚ª', icon: 'â˜„', mp: 55, cd: 8.0, branch: 0,
                  desc: 'å¤©ã‹ã‚‰å·¨å¤§éš•çŸ³ã‚’è½ã¨ã—å£Šæ»…çš„ãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: 'py_firewall',
                  effect: 'meteor', baseMult: [4.5, 6.5, 9.0], range: 130 },
                { id: 'py_enchant', name: 'ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆ', icon: 'âœ¨', mp: 20, cd: 12.0, branch: 1,
                  desc: 'æ­¦å™¨ã«ç‚ã®åŠ›ã‚’ä»˜ä¸ã—æ”»æ’ƒåŠ›ä¸Šæ˜‡', prereq: null,
                  effect: 'buff_berserk', duration: [8, 12, 16] },
                { id: 'py_hydra', name: 'ãƒ’ãƒ‰ãƒ©', icon: 'ğŸ', mp: 35, cd: 8.0, branch: 1,
                  desc: 'ç«ç‚ã‚’åãå¤šé ­ç«œã‚’è¨­ç½®', prereq: 'py_enchant',
                  effect: 'consecrate', baseMult: [1.0, 1.5, 2.2], range: 100, duration: [5, 8, 12] },
                { id: 'py_firemastery', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'ğŸ”¥', mp: 30, cd: 15.0, branch: 1,
                  desc: 'å…¨ã¦ã®ç‚ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å¤§å¹…å¼·åŒ–', prereq: 'py_hydra',
                  effect: 'buff_atkspd', duration: [8, 12, 16], bonus: [0.5, 0.7, 1.0] },
                { id: 'py_inferno', name: 'ã‚¤ãƒ³ãƒ•ã‚§ãƒ«ãƒ', icon: 'ğŸŒ‹', mp: 18, cd: 2.0, branch: 2,
                  desc: 'è¶³å…ƒã‹ã‚‰ç‚ãŒå™´å‡º', prereq: null,
                  effect: 'ground_slam', baseMult: [1.8, 2.5, 3.5], range: 90, slow: [0.5, 0.4, 0.3] },
                { id: 'py_blaze', name: 'ãƒ–ãƒ¬ã‚¤ã‚º', icon: 'ğŸ’¥', mp: 25, cd: 4.0, branch: 2,
                  desc: 'ç‚ã®é€£é–ãŒæ•µã‚’ç„¼ãå°½ãã™', prereq: 'py_inferno',
                  effect: 'chain_lightning', bounces: [3, 5, 7], baseMult: [1.8, 2.5, 3.5] },
                { id: 'py_meteorstorm', name: 'ãƒ¡ãƒ†ã‚ªã‚¹ãƒˆãƒ¼ãƒ ', icon: 'ğŸŒ ', mp: 70, cd: 12.0, branch: 2,
                  desc: 'è¤‡æ•°ã®éš•çŸ³ãŒé™ã‚Šæ³¨ãè¶…å¤§é­”æ³•', prereq: 'py_blaze',
                  effect: 'meteor', baseMult: [5.5, 8.0, 12.0], range: 160 }
            ]
        },
        cryomancer: {
            name: 'ã‚¢ã‚¤ã‚¹ã‚½ãƒ¼ã‚µãƒ¬ã‚¹', icon: 'â„', engName: 'ICE SORCERESS', tier: 1,
            sprite: 'cryomancer', baseClass: 'sorcerer',
            baseStr: 5, baseDex: 12, baseVit: 14, baseInt: 28,
            branches: ['ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒšãƒ«', 'ãƒ•ãƒ­ã‚¹ãƒˆãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹', 'ã‚¢ã‚¤ã‚¹ãƒã‚¹ã‚¿ãƒªãƒ¼'],
            promotions: [],
            skills: [
                { id: 'cy_iceblast', name: 'ã‚¢ã‚¤ã‚¹ãƒ–ãƒ©ã‚¹ãƒˆ', icon: 'ğŸ”·', mp: 10, cd: 0.6, branch: 0,
                  desc: 'å¼·åŒ–ã•ã‚ŒãŸæ°·ã®å¼¾ã‚’æ”¾ã¤', prereq: null,
                  effect: 'projectile_fire', baseMult: [2.0, 2.8, 3.8], speed: 400 },
                { id: 'cy_glacialspike', name: 'ã‚°ãƒ¬ã‚¤ã‚·ãƒ£ãƒ«ã‚¹ãƒ‘ã‚¤ã‚¯', icon: 'â„', mp: 22, cd: 3.5, branch: 0,
                  desc: 'æ°·ã®æ£˜ãŒçˆ†ç™ºã—ç¯„å›²å‡çµ', prereq: 'cy_iceblast',
                  effect: 'frost_nova', baseMult: [1.5, 2.2, 3.0], freeze: [3, 4, 6] },
                { id: 'cy_blizzard', name: 'ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰', icon: 'ğŸŒ¨', mp: 45, cd: 7.0, branch: 0,
                  desc: 'åºƒç¯„å›²ã«å¹é›ªã‚’é™ã‚‰ã›å£Šæ»…ãƒ€ãƒ¡ãƒ¼ã‚¸', prereq: 'cy_glacialspike',
                  effect: 'arrow_rain', baseMult: [3.0, 4.5, 6.5], range: 130 },
                { id: 'cy_frozenarmor', name: 'ãƒ•ãƒ­ãƒ¼ã‚ºãƒ³ã‚¢ãƒ¼ãƒãƒ¼', icon: 'ğŸ›¡', mp: 18, cd: 10.0, branch: 1,
                  desc: 'æ°·ã®é§ã§è¢«ãƒ€ãƒ¡è»½æ¸›', prereq: null,
                  effect: 'buff_defense', duration: [6, 10, 14], reduction: [0.4, 0.55, 0.7] },
                { id: 'cy_shiverarmor', name: 'ã‚·ãƒ´ã‚¡ãƒ¼ã‚¢ãƒ¼ãƒãƒ¼', icon: 'ğŸª', mp: 25, cd: 8.0, branch: 1,
                  desc: 'æ”»æ’ƒã—ã¦ããŸæ•µã«å†·æ°—ã§åæ’ƒ', prereq: 'cy_frozenarmor',
                  effect: 'buff_counter', duration: [5, 7, 10], reflect: [0.4, 0.6, 0.9] },
                { id: 'cy_energyshield', name: 'ã‚¨ãƒŠã‚¸ãƒ¼ã‚·ãƒ¼ãƒ«ãƒ‰', icon: 'ğŸ”·', mp: 35, cd: 14.0, branch: 1,
                  desc: 'ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’MPã§å¸åã™ã‚‹ã‚·ãƒ¼ãƒ«ãƒ‰', prereq: 'cy_shiverarmor',
                  effect: 'mana_shield', duration: [6, 10, 15], absorb: [0.5, 0.65, 0.8] },
                { id: 'cy_frostnova', name: 'ãƒ•ãƒ­ã‚¹ãƒˆãƒãƒ´ã‚¡', icon: 'ğŸ’ ', mp: 20, cd: 4.0, branch: 2,
                  desc: 'å¼·åŒ–ã•ã‚ŒãŸå‡çµè¡æ’ƒæ³¢', prereq: null,
                  effect: 'frost_nova', baseMult: [1.2, 1.8, 2.8], freeze: [2, 3, 5] },
                { id: 'cy_coldmastery', name: 'ã‚³ãƒ¼ãƒ«ãƒ‰ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'ğŸ¥¶', mp: 22, cd: 8.0, branch: 2,
                  desc: 'å‘¨å›²ã®æ•µã®é˜²å¾¡ã‚’ä½ä¸‹', prereq: 'cy_frostnova',
                  effect: 'debuff_defense', duration: [5, 7, 10], reduction: [0.35, 0.5, 0.65], range: 140 },
                { id: 'cy_frozenorb', name: 'ãƒ•ãƒ­ãƒ¼ã‚ºãƒ³ã‚ªãƒ¼ãƒ–', icon: 'ğŸŒ', mp: 50, cd: 8.0, branch: 2,
                  desc: 'æ°·ã®çƒä½“ãŒæ°·ç‰‡ã‚’æ”¾å°„ã—ãªãŒã‚‰é£›ã¶', prereq: 'cy_coldmastery',
                  effect: 'frozen_orb', baseMult: [3.0, 4.5, 7.0], speed: 200, shardCount: [6, 8, 12] }
            ]
        }
    };

    // ========== CLASS CHANGE SYSTEM ==========
    const CLASS_PROMOTIONS = {
        warrior: [
            { key: 'paladin', name: 'è–é¨å£«', icon: 'â›¨', desc: 'è–ãªã‚‹åŠ›ã§å‘³æ–¹ã‚’å®ˆã‚Šæ•µã‚’æµ„åŒ–ã™ã‚‹é¨å£«ã€‚é˜²å¾¡ã¨å›å¾©ã«å„ªã‚Œã‚‹ã€‚' },
            { key: 'berserker', name: 'ç‹‚æˆ¦å£«', icon: 'ğŸª“', desc: 'æ€’ã‚Šã®åŠ›ã§åœ§å€’çš„ãªç«åŠ›ã‚’å©ãå‡ºã™æˆ¦å£«ã€‚æ”»æ’ƒã«å…¨æŒ¯ã‚Šã€‚' }
        ],
        rogue: [
            { key: 'assassin', name: 'æš—æ®ºè€…', icon: 'ğŸ—¡', desc: 'å½±ã«æ½œã¿æ€¥æ‰€ã‚’çªãæš—æ®ºã®ãƒ—ãƒ­ã€‚å˜ä½“ç«åŠ›ã¨å›é¿ã«ç‰¹åŒ–ã€‚' },
            { key: 'ranger', name: 'ç‹©äºº', icon: 'ğŸ¹', desc: 'é è·é›¢ã‹ã‚‰ã®ç²¾å¯†å°„æ’ƒã¨ç½ ã§æˆ¦å ´ã‚’æ”¯é…ã™ã‚‹ã€‚' }
        ],
        sorcerer: [
            { key: 'pyromancer', name: 'ç‚è¡“å¸«', icon: 'ğŸ”¥', desc: 'ç‚ã¨çˆ†ç™ºã®é­”æ³•ã§æ®²æ»…ã™ã‚‹ã€‚åœ§å€’çš„ãªç¯„å›²ç«åŠ›ã€‚' },
            { key: 'cryomancer', name: 'æ°·è¡“å¸«', icon: 'â„', desc: 'å‡çµã¨æ°·ã®é˜²å£ã§æˆ¦å ´ã‚’åˆ¶å¾¡ã™ã‚‹ã€‚CCç‰¹åŒ–å‹ã€‚' }
        ]
    };

    const PROMOTION_LEVEL = 10;
    let promotionPending = false;

    function checkPromotion() {
        if (player.level >= PROMOTION_LEVEL && !promotionPending) {
            const classDef = CLASS_DEFS[G.playerClass];
            if (classDef.tier === 0 && classDef.promotions && classDef.promotions.length > 0) {
                promotionPending = true;
                setPaused(true);
                showPromotionUI();
            }
        }
    }

    function showPromotionUI() {
        const promos = CLASS_PROMOTIONS[G.playerClass];
        if (!promos) return;
        const overlay = DOM.promotionOverlay;
        const content = DOM.promotionContent;
        let html = '<div style="text-align:center;margin-bottom:15px"><span style="color:#ffd700;font-size:22px;font-weight:bold;text-shadow:0 0 10px #ffd700">ã‚¯ãƒ©ã‚¹ãƒã‚§ãƒ³ã‚¸</span><br><span style="color:#aaa;font-size:12px">ãƒ¬ãƒ™ãƒ«10åˆ°é”ï¼ä¸Šä½ã‚¯ãƒ©ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„</span></div>';
        for (const p of promos) {
            const cd = CLASS_DEFS[p.key];
            html += `<div class="promo-card" onclick="doPromotion('${p.key}')">
                <div style="font-size:28px;margin-bottom:5px">${p.icon}</div>
                <div style="color:#ffd700;font-size:16px;font-weight:bold">${p.name}</div>
                <div style="color:#aaa;font-size:10px;margin-bottom:6px">${cd.engName}</div>
                <div style="color:#ccc;font-size:11px;margin-bottom:8px">${p.desc}</div>
                <div style="color:#888;font-size:10px">STR:${cd.baseStr} DEX:${cd.baseDex} VIT:${cd.baseVit} INT:${cd.baseInt}</div>
                <div style="color:#66aaff;font-size:10px;margin-top:4px">ã‚¹ã‚­ãƒ«ãƒ–ãƒ©ãƒ³ãƒ: ${cd.branches.join(' / ')}</div>
            </div>`;
        }
        content.innerHTML = html;
        overlay.style.display = 'flex';
        DOM.pauseOverlay.style.display = 'none';
    }

    window.doPromotion = function(newClass) {
        const newDef = CLASS_DEFS[newClass];
        if (!newDef) return;
        G.playerClass = newClass;
        player.classKey = newClass;
        player.className = newDef.name;
        // Apply stat bonuses (keep allocated stats, update base)
        const oldDef = CLASS_DEFS[newDef.baseClass];
        player.str += newDef.baseStr - oldDef.baseStr;
        player.dex += newDef.baseDex - oldDef.baseDex;
        player.vit += newDef.baseVit - oldDef.baseVit;
        player.int += newDef.baseInt - oldDef.baseInt;
        // Keep old skill levels, add new skills with level 0
        for (const sk of newDef.skills) {
            if (!(sk.id in player.skillLevels)) {
                player.skillLevels[sk.id] = 0;
            }
        }
        // Unlock first skill in each branch
        player.skillLevels[newDef.skills[0].id] = Math.max(1, player.skillLevels[newDef.skills[0].id] || 0);
        player.skillLevels[newDef.skills[3].id] = Math.max(1, player.skillLevels[newDef.skills[3].id] || 0);
        player.skillLevels[newDef.skills[6].id] = Math.max(1, player.skillLevels[newDef.skills[6].id] || 0);
        // Give bonus skill points
        player.skillPoints = (player.skillPoints || 0) + 3;
        // Rebuild skill bar from new class
        rebuildSkillBar();
        player.recalcStats();
        player.hp = player.maxHP;
        player.mp = player.maxMP;
        promotionPending = false;
        setPaused(false);
        DOM.promotionOverlay.style.display = 'none';
        addLog(`${newDef.name}ã«ã‚¯ãƒ©ã‚¹ãƒã‚§ãƒ³ã‚¸ï¼`, '#ffd700');
        sfxLevelUp();
        emitParticles(player.x, player.y, '#ffd700', 30, 100, 1.0, 5, -40);
    };

    // ========== SKILL BAR MANAGEMENT ==========
    function rebuildSkillBar() {
        const classDef = CLASS_DEFS[G.playerClass];
        const allSkills = getAllAvailableSkills();
        player.skills = {};
        // Fill 6 slots: prefer skills with levels > 0
        const learned = allSkills.filter(s => (player.skillLevels[s.id] || 0) > 0);
        const unlearned = allSkills.filter(s => (player.skillLevels[s.id] || 0) === 0);
        const ordered = [...learned, ...unlearned];
        for (let i = 0; i < 6; i++) {
            const sk = ordered[i] || ordered[0];
            player.skills[i + 1] = {
                id: sk.id, name: sk.name, icon: sk.icon,
                mp: sk.mp, cooldown: 0, maxCD: sk.cd, desc: sk.desc
            };
        }
    }

    function getAllAvailableSkills() {
        const classDef = CLASS_DEFS[G.playerClass];
        const result = [...classDef.skills];
        // Also include base class skills if promoted
        if (classDef.baseClass && CLASS_DEFS[classDef.baseClass]) {
            for (const sk of CLASS_DEFS[classDef.baseClass].skills) {
                if (!result.find(s => s.id === sk.id)) {
                    result.push(sk);
                }
            }
        }
        return result;
    }

    let skillSelectOpen = false;
    let skillSelectSlot = 0;

    function showSkillSelectUI() {
        skillSelectOpen = true;
        const overlay = DOM.skillSelectOverlay;
        const content = DOM.skillSelectContent;
        const allSkills = getAllAvailableSkills();
        let html = '<div style="text-align:center;margin-bottom:12px"><span style="color:#ffd700;font-size:18px;font-weight:bold">ã‚¹ã‚­ãƒ«ã‚»ãƒƒãƒˆç·¨é›†</span><br><span style="color:#aaa;font-size:11px">ã‚¹ãƒ­ãƒƒãƒˆã‚’ã‚¯ãƒªãƒƒã‚¯ â†’ ã‚¹ã‚­ãƒ«ã‚’é¸æŠ</span></div>';

        // Current slots
        html += '<div style="display:flex;gap:6px;justify-content:center;margin-bottom:15px">';
        for (let i = 1; i <= 6; i++) {
            const sk = player.skills[i];
            const sel = skillSelectSlot === i;
            html += `<div class="skill-slot-pick ${sel ? 'selected' : ''}" onclick="pickSlot(${i})">
                <div style="font-size:20px">${sk.icon}</div>
                <div style="font-size:8px;color:#aaa">${i}</div>
            </div>`;
        }
        html += '</div>';

        // Available skills grid
        if (skillSelectSlot > 0) {
            html += `<div style="color:#ffd700;font-size:12px;margin-bottom:8px;text-align:center">ã‚¹ãƒ­ãƒƒãƒˆ${skillSelectSlot}ã«è¨­å®šã™ã‚‹ã‚¹ã‚­ãƒ«:</div>`;
            html += '<div style="display:flex;flex-wrap:wrap;gap:6px;justify-content:center">';
            for (const sk of allSkills) {
                const lvl = player.skillLevels[sk.id] || 0;
                const locked = lvl < 1;
                html += `<div class="skill-pick-item ${locked ? 'locked' : ''}" onclick="${locked ? '' : `assignSkill('${sk.id}')`}">
                    <div style="font-size:18px">${sk.icon}</div>
                    <div style="font-size:9px;color:${locked ? '#666' : '#ffd700'}">${sk.name}</div>
                    <div style="font-size:8px;color:${locked ? '#444' : '#88f'}">Lv.${lvl} MP:${sk.mp}</div>
                </div>`;
            }
            html += '</div>';
        }

        html += '<div style="text-align:center;margin-top:12px"><button class="close-btn" onclick="closeSkillSelect()">é–‰ã˜ã‚‹ (R)</button></div>';
        content.innerHTML = html;
        overlay.style.display = 'flex';
    }

    window.pickSlot = function(slot) {
        skillSelectSlot = slot;
        showSkillSelectUI();
    };

    window.assignSkill = function(skillId) {
        const allSkills = getAllAvailableSkills();
        const sk = allSkills.find(s => s.id === skillId);
        if (!sk) return;
        if ((player.skillLevels[sk.id] || 0) < 1) return;
        player.skills[skillSelectSlot] = {
            id: sk.id, name: sk.name, icon: sk.icon,
            mp: sk.mp, cooldown: 0, maxCD: sk.cd, desc: sk.desc
        };
        showSkillSelectUI();
    };

    window.closeSkillSelect = function() {
        skillSelectOpen = false;
        DOM.skillSelectOverlay.style.display = 'none';
    };


    // ========== COLLISION HELPER ==========
    // Check if a circle at (px, py) with radius r can stand on walkable tiles
    function canWalk(px, py, r) {
        // Check the 4 cardinal edge points + center
        const points = [
            [px, py],
            [px - r, py], [px + r, py],
            [px, py - r], [px, py + r]
        ];
        for (const [x, y] of points) {
            const tx = Math.floor(x / TILE), ty = Math.floor(y / TILE);
            if (!dungeon.walkable(tx, ty)) return false;
        }
        return true;
    }

    // ========== GROUND ITEMS ==========
    const groundItems = [];
    class GroundItem {
        constructor(x, y, item) {
            this.x = x; this.y = y;
            this.item = item;
            this.bobT = randf(0, Math.PI * 2);
        }
    }
    function dropItem(x, y, item) {
        groundItems.push(new GroundItem(x + randf(-15, 15), y + randf(-15, 15), item));
    }

    // ========== PLAYER ==========
    const player = {
        x: 0, y: 0,
        targetX: 0, targetY: 0,
        radius: 14,
        speed: 160,
        moving: false,
        attacking: false,
        attackTarget: null,
        attackCooldown: 0,
        attackAnimT: 0,
        whirlwindT: 0,

        // Stats
        level: 1,
        xp: 0,
        xpToNext: 100,
        statPoints: 0,
        str: 10, dex: 10, vit: 10, int: 10,

        hp: 100, maxHP: 100,
        mp: 50, maxMP: 50,
        defense: 2,
        critChance: 5,

        // Equipment
        equipment: { weapon: null, offhand: null, head: null, body: null, ring: null, amulet: null, feet: null },
        inventory: [], // max 24
        maxInv: 24,

        // Skills
        selectedSkill: 1,
        freezeT: 0, // freeze nova effect timer
        shieldT: 0, // magic shield timer
        meteorT: 0, // meteor delay
        berserkT: 0,
        dodgeT: 0,
        dodgeChance: 0,
        manaShieldT: 0,
        manaShieldAbsorb: 0,
        shieldReduction: 0.5,
        counterT: 0, counterReflect: 0,
        speedBuffT: 0, speedBuffBonus: 0,
        poisonBuffT: 0, poisonDps: 0,
        atkSpdBuffT: 0, atkSpdBonus: 0,
        lifestealBuffT: 0, lifestealBuffPct: 0,
        undyingT: 0,
        stealthT: 0,
        critBuffT: 0, critBuffBonus: 0,
        auraT: 0, auraRegen: 0, auraReduction: 0,
        attackTimer: 0,
        battleOrdersT: 0, battleOrdersHP: 0, battleOrdersMP: 0,
        skillPoints: 0,
        skillLevels: {},
        classKey: 'warrior',
        className: 'æˆ¦å£«',
        skills: {
            1: { name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ«', icon: 'ğŸ”¥', mp: 15, cooldown: 0, maxCD: 1.2, desc: 'ç‚ã®å¼¾ã‚’æ’ƒã¤' },
            2: { name: 'æ—‹é¢¨æ–¬', icon: 'ğŸŒ€', mp: 20, cooldown: 0, maxCD: 2.5, desc: 'å‘¨å›²ã®æ•µã‚’æ–¬ã‚‹' },
            3: { name: 'ãƒ’ãƒ¼ãƒ«', icon: 'ğŸ’š', mp: 25, cooldown: 0, maxCD: 4.0, desc: 'HPã‚’å›å¾©ã™ã‚‹' },
            4: { name: 'ãƒ•ãƒ­ã‚¹ãƒˆãƒãƒ´ã‚¡', icon: 'â„ï¸', mp: 30, cooldown: 0, maxCD: 6.0, desc: 'å‘¨å›²ã®æ•µã‚’å‡çµ' },
            5: { name: 'é­”æ³•ã‚·ãƒ¼ãƒ«ãƒ‰', icon: 'ğŸ›¡ï¸', mp: 35, cooldown: 0, maxCD: 10.0, desc: '5ç§’é–“ãƒ€ãƒ¡ãƒ¼ã‚¸è»½æ¸›' },
            6: { name: 'ãƒ¡ãƒ†ã‚ª', icon: 'â˜„ï¸', mp: 50, cooldown: 0, maxCD: 8.0, desc: 'åºƒç¯„å›²ã«å¤§ãƒ€ãƒ¡ãƒ¼ã‚¸' }
        },

        getAttackDmg() {
            let base = this.str * 0.8 + 5;
            const w = this.equipment.weapon;
            if (w && w.baseDmg) base += rand(w.baseDmg[0], w.baseDmg[1]);
            // Affix bonuses
            let dmgPct = 0;
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === 'dmgPct') dmgPct += a.value;
                }
            }
            let finalDmg = Math.round(base * (1 + dmgPct / 100));
            if (this.berserkT > 0) finalDmg = Math.round(finalDmg * 2);
            return finalDmg;
        },

        getDefense() {
            let def = this.defense;
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                if (slot.baseDef) def += slot.baseDef;
                for (const a of slot.affixes) {
                    if (a.stat === 'def') def += a.value;
                }
            }
            return def;
        },

        getTotalStat(stat) {
            let val = this[stat];
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === stat) val += a.value;
                }
            }
            return val;
        },

        getCritChance() {
            let c = this.critChance + this.dex * 0.3;
            if (this.stealthT > 0) c = 100;
            if (this.critBuffT > 0) c += (this.critBuffBonus || 0);
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === 'critChance') c += a.value;
                }
            }
            return c;
        },

        getLifesteal() {
            let ls = 0;
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === 'lifesteal') ls += a.value;
                }
            }
            return ls;
        },

        recalcStats() {
            let bonusHP = 0, bonusMP = 0, bonusSpd = 0;
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === 'hp') bonusHP += a.value;
                    if (a.stat === 'mp') bonusMP += a.value;
                    if (a.stat === 'vit') bonusHP += a.value * 5;
                    if (a.stat === 'int') bonusMP += a.value * 3;
                    if (a.stat === 'moveSpd') bonusSpd += a.value;
                }
            }
            this.maxHP = 80 + this.vit * 5 + this.level * 10 + bonusHP;
            this.maxMP = 30 + this.int * 3 + this.level * 5 + bonusMP;
            this.speed = 160 * (1 + bonusSpd / 100) * (1 + (this.speedBuffBonus || 0));
            this.hp = Math.min(this.hp, this.maxHP);
            this.mp = Math.min(this.mp, this.maxMP);
        },

        addXP(amount) {
            this.xp += amount;
            while (this.xp >= this.xpToNext) {
                this.xp -= this.xpToNext;
                this.level++;
                this.statPoints += 5;
                this.skillPoints = (this.skillPoints || 0) + 1;
                this.xpToNext = Math.round(100 * Math.pow(1.3, this.level - 1));
                this.recalcStats();
                this.hp = this.maxHP;
                this.mp = this.maxMP;
                sfxLevelUp();
                showLevelUp();
                addLog(`ãƒ¬ãƒ™ãƒ« ${this.level} ã«ä¸ŠãŒã£ãŸï¼`, '#ffd700');
                checkPromotion();
            }
        },

        takeDamage(raw) {
            const def = this.getDefense();
            let dmg = Math.max(1, Math.round(raw * (100 / (100 + def))));
            // Dodge check
            if (this.dodgeT > 0 && Math.random() * 100 < (this.dodgeChance || 0)) {
                addFloatingText(this.x, this.y - 20, 'DODGE!', '#aaffaa');
                emitParticles(this.x, this.y, '#aaffaa', 5, 40, 0.2, 2, -30);
                return;
            }
            // Berserk increases damage taken
            if (this.berserkT > 0) dmg = Math.round(dmg * 1.3);
            // Magic Shield reduces damage by 50%
            if (this.shieldT > 0) {
                dmg = Math.max(1, Math.round(dmg * 0.5));
                emitParticles(this.x, this.y, '#8888ff', 4, 40, 0.2, 2, -30);
            }
            // Mana Shield - absorb damage with MP
            if (this.manaShieldT > 0 && this.mp > 0) {
                const absorbed = Math.round(dmg * (this.manaShieldAbsorb || 0.5));
                const mpCost = absorbed;
                if (this.mp >= mpCost) {
                    this.mp -= mpCost;
                    dmg -= absorbed;
                    emitParticles(this.x, this.y, '#4488ff', 4, 40, 0.2, 2, -30);
                }
            }
            this.hp -= dmg;
            addFloatingText(this.x, this.y - 20, dmg, '#ff4444');
            emitParticles(this.x, this.y, '#ff0000', 8, 80, 0.4, 3);
            emitParticles(this.x, this.y, '#880000', 4, 40, 0.3, 2, 100);
            G.shakeT = 0.2; G.shakeAmt = 5;
            G.dmgFlashT = 0.35; // Screen blood flash
            // Counter-attack
            if (this.counterT > 0 && this.counterReflect > 0) {
                const reflectDmg = Math.round(raw * this.counterReflect);
                // Find nearest monster
                let nearest = null, nearD = 100;
                for (const m of monsters) {
                    if (!m.alive) continue;
                    const d = dist(this.x, this.y, m.x, m.y);
                    if (d < nearD) { nearD = d; nearest = m; }
                }
                if (nearest) {
                    monsterTakeDmg(nearest, reflectDmg, false);
                    addFloatingText(nearest.x, nearest.y - 20, 'åæ’ƒ!' + reflectDmg, '#ffcc44');
                    emitParticles(nearest.x, nearest.y, '#ffcc44', 6, 40, 0.3, 2, 0);
                }
            }
            sfxPlayerHit();
            if (this.hp <= 0) {
                if (this.undyingT > 0) {
                    this.hp = 1;
                    this.undyingT = 0;
                    addFloatingText(this.x, this.y - 30, 'ä¸æ­»èº«ï¼', '#ffd700');
                    emitParticles(this.x, this.y, '#ffd700', 20, 80, 0.6, 4, -40);
                } else {
                    this.hp = 0;
                    G.dead = true;
                sfxDeath();
                    DOM.deathScreen.style.display = 'flex';
                }
            }
        },

        pickupNearby() {
            for (let i = groundItems.length - 1; i >= 0; i--) {
                const gi = groundItems[i];
                if (dist(this.x, this.y, gi.x, gi.y) < 50) {
                    if (gi.item.typeKey === 'potion') {
                        this.hp = Math.min(this.maxHP, this.hp + 50);
                        addFloatingText(this.x, this.y - 20, '+50 HP', '#00ff00');
                        emitParticles(this.x, this.y, '#00ff00', 8, 40, 0.5, 2, -50);
                        sfxHeal();
                        addLog('å›å¾©è–¬ã‚’ä½¿ã£ãŸ (+50 HP)', '#00ff00');
                    } else if (this.inventory.length < this.maxInv) {
                        this.inventory.push(gi.item);
                        sfxPickup();
                        if (gi.item.rarityKey === 'legendary' || gi.item.rarityKey === 'unique') sfxLegendary();
                        addLog(`${gi.item.name} ã‚’æ‹¾ã£ãŸ`, gi.item.rarity.color);
                    } else {
                        addLog('ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãŒä¸€æ¯ã§ã™ï¼', '#ff4444');
                        return;
                    }
                    groundItems.splice(i, 1);
                }
            }
        },

        equipItem(invIdx) {
            const item = this.inventory[invIdx];
            if (!item || !item.typeInfo.slot) return;
            const slot = item.typeInfo.slot;
            const prev = this.equipment[slot];
            this.equipment[slot] = item;
            this.inventory.splice(invIdx, 1);
            if (prev) this.inventory.push(prev);
            this.recalcStats();
            addLog(`${item.name} ã‚’è£…å‚™ã—ãŸ`, item.rarity.color);
        },

        unequipSlot(slot) {
            if (!this.equipment[slot]) return;
            if (this.inventory.length >= this.maxInv) { addLog('ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãŒä¸€æ¯ï¼', '#ff4444'); return; }
            const item = this.equipment[slot];
            this.inventory.push(item);
            this.equipment[slot] = null;
            this.recalcStats();
            addLog(`${item.name} ã‚’å¤–ã—ãŸ`, '#aaa');
        },

        useSkill(mx, my) {
            const sk = this.skills[this.selectedSkill];
            if (!sk || sk.cooldown > 0 || this.mp < sk.mp) return;
            const allAvail = getAllAvailableSkills();
            const skDef = allAvail.find(s => s.id === sk.id);
            if (!skDef) return;
            const lvl = this.skillLevels[sk.id] || 0;
            if (lvl < 1) { addLog('ã‚¹ã‚­ãƒ«æœªç¿’å¾—ï¼(Tã§ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ã‚’é–‹ã)', '#ff4444'); return; }
            const li = lvl - 1; // 0-indexed level

            this.mp -= sk.mp;
            sk.cooldown = sk.maxCD;

            const wx = mx + G.camX, wy = my + G.camY;
            const dmg = this.getAttackDmg();

            switch (skDef.effect) {
                case 'melee_burst': {
                    // Power Strike / strong single hit
                    const mult = skDef.baseMult[li];
                    sfxHit();
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            const isCrit = Math.random() * 100 < this.getCritChance();
                            const d = dmg * mult * (isCrit ? 2 : 1);
                            monsterTakeDmg(m, d, isCrit);
                            break; // Single target
                        }
                    }
                    this.attackAnimT = 0.3;
                    emitParticles(this.x, this.y, '#ffaa44', 10, 80, 0.4, 4, 0);
                    break;
                }
                case 'whirlwind': {
                    this.whirlwindT = 0.6;
                    sfxWhirlwind();
                    const mult = skDef.baseMult[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            const isCrit = Math.random() * 100 < this.getCritChance();
                            monsterTakeDmg(m, dmg * mult * (isCrit ? 2 : 1), isCrit);
                        }
                    }
                    emitParticles(this.x, this.y, '#88aaff', 20, 100, 0.5, 4, 0);
                    break;
                }
                case 'buff_berserk': {
                    this.berserkT = skDef.duration[li];
                    playSound(200, 'sawtooth', 0.3, 0.1);
                    emitParticles(this.x, this.y, '#ff4400', 20, 80, 0.6, 4, -30);
                    addLog(`ç‹‚æˆ¦å£«ãƒ¢ãƒ¼ãƒ‰ï¼(${skDef.duration[li]}ç§’)`, '#ff4400');
                    break;
                }
                case 'stun_aoe': {
                    const dur = skDef.duration[li];
                    playSound(150, 'square', 0.2, 0.1);
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            m.frozenT = dur;
                            m.spd = 0;
                        }
                    }
                    emitParticles(this.x, this.y, '#ffdd88', 15, 130, 0.4, 3, 0);
                    addLog('é›„å«ã³ï¼æ•µãŒæ€¯ã‚“ã ï¼', '#ffdd88');
                    break;
                }
                case 'buff_defense': {
                    this.shieldT = skDef.duration[li];
                    this.shieldReduction = skDef.reduction[li];
                    sfxShield();
                    emitParticles(this.x, this.y, '#aaaaff', 12, 50, 0.5, 3, -40);
                    addLog(`é‰„å£ç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#aaaaff');
                    break;
                }
                case 'charge': {
                    // Rush toward clicked position, damage first enemy hit
                    const angle = Math.atan2(wy - this.y, wx - this.x);
                    const chargeDist = Math.min(dist(this.x, this.y, wx, wy), skDef.range);
                    const nx = this.x + Math.cos(angle) * chargeDist;
                    const ny = this.y + Math.sin(angle) * chargeDist;
                    if (canWalk(nx, ny, 10)) { this.x = nx; this.y = ny; }
                    sfxHit();
                    const mult = skDef.baseMult[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < 60) {
                            monsterTakeDmg(m, dmg * mult, false);
                        }
                    }
                    emitParticles(this.x, this.y, '#ffcc44', 15, 100, 0.4, 3, 0);
                    G.shakeT = 0.1; G.shakeAmt = 4;
                    break;
                }
                case 'projectile_fire': {
                    sfxFireball();
                    const mult = skDef.baseMult[li];
                    const spd = skDef.speed || 350;
                    projectiles.push(new Projectile(this.x, this.y, wx, wy, dmg * mult, '#ff4400', spd, 8));
                    emitParticles(this.x, this.y, '#ff6600', 6, 50, 0.3, 3, 0);
                    break;
                }
                case 'multi_shot': {
                    sfxFireball();
                    const numArrows = skDef.arrows[li];
                    const mult = skDef.baseMult[li];
                    const baseAngle = Math.atan2(wy - this.y, wx - this.x);
                    const spread = 0.4;
                    for (let i = 0; i < numArrows; i++) {
                        const a = baseAngle - spread / 2 + spread * i / (numArrows - 1 || 1);
                        const tx = this.x + Math.cos(a) * 400;
                        const ty = this.y + Math.sin(a) * 400;
                        projectiles.push(new Projectile(this.x, this.y, tx, ty, dmg * mult, '#ffaa00', 380, 5));
                    }
                    break;
                }
                case 'arrow_rain': {
                    sfxMeteorCast();
                    this.meteorT = 0.6;
                    G.meteorX = wx; G.meteorY = wy;
                    G.meteorDmg = dmg * skDef.baseMult[li];
                    G.meteorColor = '#ffaa44';
                    for (let a = 0; a < Math.PI * 2; a += 0.4) {
                        emitParticles(wx + Math.cos(a) * skDef.range, wy + Math.sin(a) * skDef.range, '#ffaa44', 2, 20, 0.6, 2, 0);
                    }
                    addLog('çŸ¢ã®é›¨ï¼', '#ffaa44');
                    break;
                }
                case 'place_trap': {
                    playSound(400, 'triangle', 0.1, 0.06);
                    const trap = { x: this.x, y: this.y, dmg: dmg * skDef.baseMult[li], life: 10, r: 50, triggered: false };
                    if (!G.traps) G.traps = [];
                    G.traps.push(trap);
                    emitParticles(this.x, this.y, '#ff6600', 5, 30, 0.3, 2, 0);
                    addLog('ãƒˆãƒ©ãƒƒãƒ—ã‚’è¨­ç½®ï¼', '#ff8844');
                    break;
                }
                case 'buff_dodge': {
                    this.dodgeT = skDef.duration[li];
                    this.dodgeChance = skDef.chance[li];
                    playSound(600, 'sine', 0.15, 0.06);
                    emitParticles(this.x, this.y, '#aaffaa', 10, 50, 0.4, 2, -30);
                    addLog(`å›é¿ãƒ¢ãƒ¼ãƒ‰ï¼(${skDef.duration[li]}ç§’)`, '#aaffaa');
                    break;
                }
                case 'shadow_strike': {
                    // Teleport to nearest enemy and strike
                    let closest = null, closestD = 300;
                    for (const m of monsters) {
                        if (!m.alive) continue;
                        const d = dist(this.x, this.y, m.x, m.y);
                        if (d < closestD) { closestD = d; closest = m; }
                    }
                    if (closest) {
                        const angle = Math.atan2(this.y - closest.y, this.x - closest.x);
                        this.x = closest.x + Math.cos(angle) * 30;
                        this.y = closest.y + Math.sin(angle) * 30;
                        monsterTakeDmg(closest, dmg * skDef.baseMult[li], true);
                        sfxHit();
                        emitParticles(closest.x, closest.y, '#aa44ff', 15, 80, 0.4, 3, 0);
                    }
                    break;
                }
                case 'chain_lightning': {
                    playSweep(1000, 200, 0.2, 'sawtooth', 0.08);
                    playNoise(0.1, 0.05, 3000);
                    const mult = skDef.baseMult[li];
                    const maxBounces = skDef.bounces[li];
                    let lastX = this.x, lastY = this.y;
                    const hit = new Set();
                    for (let b = 0; b <= maxBounces; b++) {
                        let best = null, bestD = 200;
                        for (const m of monsters) {
                            if (!m.alive || hit.has(m)) continue;
                            const d = dist(lastX, lastY, m.x, m.y);
                            if (d < bestD) { bestD = d; best = m; }
                        }
                        if (!best) break;
                        hit.add(best);
                        // Draw lightning line as particles
                        const steps = 5;
                        for (let s = 0; s < steps; s++) {
                            const t = s / steps;
                            emitParticles(
                                lerp(lastX, best.x, t) + randf(-8, 8),
                                lerp(lastY, best.y, t) + randf(-8, 8),
                                '#88ccff', 1, 20, 0.3, 2, 0
                            );
                        }
                        monsterTakeDmg(best, dmg * mult * (b === 0 ? 1 : 0.7), false);
                        lastX = best.x; lastY = best.y;
                    }
                    break;
                }
                case 'meteor': {
                    sfxMeteorCast();
                    this.meteorT = 0.8;
                    G.meteorX = wx; G.meteorY = wy;
                    G.meteorDmg = dmg * skDef.baseMult[li];
                    G.meteorColor = '#ff4400';
                    for (let a = 0; a < Math.PI * 2; a += 0.3) {
                        emitParticles(wx + Math.cos(a) * skDef.range, wy + Math.sin(a) * skDef.range, '#ff6600', 2, 20, 0.8, 2, 0);
                    }
                    addLog('ãƒ¡ãƒ†ã‚ªè© å”±ä¸­...', '#ff8800');
                    break;
                }
                case 'frost_nova': {
                    sfxFrostNova();
                    this.freezeT = 0.5;
                    const mult = skDef.baseMult[li];
                    const freezeDur = skDef.freeze[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < 130) {
                            monsterTakeDmg(m, dmg * mult, false);
                            m.frozenT = freezeDur;
                            m.spd = MONSTER_DEFS[m.type].spd * 0.2;
                        }
                    }
                    emitParticles(this.x, this.y, '#88ddff', 30, 130, 0.6, 4, 0);
                    emitParticles(this.x, this.y, '#ffffff', 15, 80, 0.4, 2, -30);
                    addLog('ãƒ•ãƒ­ã‚¹ãƒˆãƒãƒ´ã‚¡ï¼', '#88ddff');
                    break;
                }
                case 'teleport': {
                    const maxRange = skDef.range[li];
                    const d = dist(this.x, this.y, wx, wy);
                    const tdist = Math.min(d, maxRange);
                    const angle = Math.atan2(wy - this.y, wx - this.x);
                    const nx = this.x + Math.cos(angle) * tdist;
                    const ny = this.y + Math.sin(angle) * tdist;
                    emitParticles(this.x, this.y, '#aa88ff', 15, 60, 0.3, 3, 0);
                    if (canWalk(nx, ny, 10)) { this.x = nx; this.y = ny; }
                    playSweep(800, 1600, 0.1, 'sine', 0.06);
                    emitParticles(this.x, this.y, '#aa88ff', 15, 60, 0.3, 3, 0);
                    break;
                }
                case 'mana_shield': {
                    this.manaShieldT = skDef.duration[li];
                    this.manaShieldAbsorb = skDef.absorb[li];
                    sfxShield();
                    emitParticles(this.x, this.y, '#4488ff', 15, 50, 0.5, 3, -40);
                    addLog(`ãƒãƒŠã‚·ãƒ¼ãƒ«ãƒ‰ç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#4488ff');
                    break;
                }

                case 'self_heal_pct': {
                    const healAmt = Math.round(player.maxHP * skDef.pct[li]);
                    player.hp = Math.min(player.maxHP, player.hp + healAmt);
                    addFloatingText(player.x, player.y - 20, '+' + healAmt + ' HP', '#00ff00');
                    emitParticles(player.x, player.y, '#00ff00', 12, 50, 0.5, 3, -40);
                    sfxHeal();
                    addLog(`HPå›å¾© (+${healAmt})`, '#00ff00');
                    break;
                }
                case 'ground_slam': {
                    sfxHit();
                    G.shakeT = 0.2; G.shakeAmt = 6;
                    const mult = skDef.baseMult[li];
                    const slowFactor = skDef.slow ? skDef.slow[li] : 0.5;
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            monsterTakeDmg(m, dmg * mult, false);
                            m.spd = MONSTER_DEFS[m.type].spd * slowFactor;
                            m.frozenT = 2;
                        }
                    }
                    emitParticles(this.x, this.y, '#aa8844', 20, skDef.range, 0.5, 4, 0);
                    break;
                }
                case 'buff_counter': {
                    this.counterT = skDef.duration[li];
                    this.counterReflect = skDef.reflect[li];
                    playSound(400, 'triangle', 0.15, 0.08);
                    emitParticles(this.x, this.y, '#ffcc44', 10, 40, 0.4, 3, -30);
                    addLog(`è¦‹åˆ‡ã‚Šç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#ffcc44');
                    break;
                }
                case 'buff_speed': {
                    this.speedBuffT = skDef.duration[li];
                    this.speedBuffBonus = skDef.bonus[li];
                    playSound(600, 'sine', 0.12, 0.05);
                    emitParticles(this.x, this.y, '#88ffaa', 10, 50, 0.4, 2, -30);
                    addLog(`ç§»å‹•é€Ÿåº¦UPï¼(${skDef.duration[li]}ç§’)`, '#88ffaa');
                    break;
                }
                case 'buff_poison': {
                    this.poisonBuffT = skDef.duration[li];
                    this.poisonDps = skDef.dps[li];
                    playSound(300, 'sawtooth', 0.1, 0.06);
                    emitParticles(this.x, this.y, '#88ff44', 10, 40, 0.4, 2, -30);
                    addLog(`æ¯’å¡—ã‚Šï¼æ”»æ’ƒã«æ¯’ä»˜ä¸(${skDef.duration[li]}ç§’)`, '#88ff44');
                    break;
                }
                case 'smoke_screen': {
                    const dur = skDef.duration[li];
                    this.dodgeT = dur;
                    this.dodgeChance = skDef.evade[li];
                    playSound(200, 'sine', 0.08, 0.06);
                    emitParticles(this.x, this.y, '#999999', 25, skDef.range, 0.6, 5, -20);
                    addLog(`ç…™å¹•ï¼å›é¿ç‡UP(${dur}ç§’)`, '#999');
                    break;
                }
                case 'holy_burst': {
                    sfxHit();
                    const mult = skDef.baseMult[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            monsterTakeDmg(m, dmg * mult, false);
                        }
                    }
                    emitParticles(this.x, this.y, '#ffdd88', 25, skDef.range, 0.5, 4, 0);
                    break;
                }
                case 'consecrate': {
                    if (!G.consecrations) G.consecrations = [];
                    G.consecrations.push({
                        x: this.x, y: this.y,
                        dmg: dmg * skDef.baseMult[li],
                        range: skDef.range,
                        life: skDef.duration[li],
                        maxLife: skDef.duration[li],
                        tickCD: 0
                    });
                    playSound(350, 'sine', 0.1, 0.08);
                    emitParticles(this.x, this.y, '#ffcc44', 15, skDef.range * 0.5, 0.5, 3, 0);
                    addLog('è–åŸŸã‚’å±•é–‹ï¼', '#ffcc44');
                    break;
                }
                case 'buff_atkspd': {
                    this.atkSpdBuffT = skDef.duration[li];
                    this.atkSpdBonus = skDef.bonus[li];
                    playSound(500, 'triangle', 0.1, 0.05);
                    emitParticles(this.x, this.y, '#ffaa88', 10, 40, 0.3, 2, -30);
                    addLog(`æ”»æ’ƒé€Ÿåº¦UPï¼(${skDef.duration[li]}ç§’)`, '#ffaa88');
                    break;
                }
                case 'buff_frenzy': {
                    this.berserkT = skDef.duration[li];
                    this.speedBuffT = skDef.duration[li];
                    this.speedBuffBonus = skDef.spdBonus[li];
                    this.atkSpdBuffT = skDef.duration[li];
                    this.atkSpdBonus = skDef.atkBonus[li];
                    playSound(250, 'sawtooth', 0.2, 0.1);
                    emitParticles(this.x, this.y, '#ff6644', 20, 80, 0.6, 4, -30);
                    addLog(`ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼ï¼(${skDef.duration[li]}ç§’)`, '#ff6644');
                    break;
                }
                case 'execute': {
                    sfxHit();
                    const mult = skDef.baseMult[li];
                    const thresh = skDef.threshold[li];
                    let hit = false;
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < (skDef.range || 70)) {
                            const hpRatio = m.hp / m.maxHP;
                            const finalMult = hpRatio <= thresh ? mult * 1.5 : mult;
                            monsterTakeDmg(m, dmg * finalMult, hpRatio <= thresh);
                            hit = true;
                            break;
                        }
                    }
                    if (hit) {
                        this.attackAnimT = 0.3;
                        emitParticles(this.x, this.y, '#ff4444', 15, 80, 0.4, 4, 0);
                        G.shakeT = 0.15; G.shakeAmt = 5;
                    }
                    break;
                }
                case 'buff_lifesteal': {
                    this.lifestealBuffT = skDef.duration[li];
                    this.lifestealBuffPct = skDef.pct[li];
                    playSound(350, 'sine', 0.12, 0.06);
                    emitParticles(this.x, this.y, '#ff4466', 10, 40, 0.4, 3, -30);
                    addLog(`è¡€ã®åˆƒï¼(${skDef.duration[li]}ç§’)`, '#ff4466');
                    break;
                }
                case 'buff_undying': {
                    this.undyingT = skDef.duration[li];
                    playSound(200, 'square', 0.15, 0.1);
                    emitParticles(this.x, this.y, '#ffd700', 20, 60, 0.8, 4, -40);
                    addLog(`ä¸æ­»èº«ç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#ffd700');
                    break;
                }
                case 'buff_stealth': {
                    this.stealthT = skDef.duration[li];
                    playSound(800, 'sine', 0.06, 0.04);
                    emitParticles(this.x, this.y, '#aa88ff', 15, 50, 0.5, 3, -30);
                    addLog(`æ¶ˆå¤±ï¼æ¬¡ã®æ”»æ’ƒã¯ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç¢ºå®š`, '#aa88ff');
                    break;
                }
                case 'buff_crit': {
                    this.critBuffT = skDef.duration[li];
                    this.critBuffBonus = skDef.bonus[li];
                    playSound(700, 'triangle', 0.1, 0.05);
                    emitParticles(this.x, this.y, '#ffdd44', 10, 40, 0.4, 2, -30);
                    addLog(`é·¹ã®ç›®ï¼ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡+${skDef.bonus[li]}%(${skDef.duration[li]}ç§’)`, '#ffdd44');
                    break;
                }
                case 'buff_aura': {
                    this.auraT = skDef.duration[li];
                    this.auraRegen = skDef.regen[li];
                    this.auraReduction = skDef.reduction[li];
                    this.shieldT = skDef.duration[li];
                    this.shieldReduction = skDef.reduction[li];
                    sfxShield();
                    emitParticles(this.x, this.y, '#ffdd88', 15, 60, 0.6, 4, -30);
                    addLog(`å®ˆè­·ã®ã‚ªãƒ¼ãƒ©ç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#ffdd88');
                    break;
                }
                case 'mana_drain': {
                    sfxHit();
                    const mult = skDef.baseMult[li];
                    const mpSteal = skDef.mpSteal[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < 80) {
                            monsterTakeDmg(m, dmg * mult, false);
                            this.mp = Math.min(this.maxMP, this.mp + mpSteal);
                            addFloatingText(this.x, this.y - 30, '+' + mpSteal + ' MP', '#8844ff');
                            emitParticles(m.x, m.y, '#8844ff', 6, 40, 0.3, 2, -20);
                            break;
                        }
                    }
                    break;
                }
                case 'debuff_defense': {
                    const dur = skDef.duration[li];
                    const red = skDef.reduction[li];
                    playSound(250, 'sawtooth', 0.1, 0.06);
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            m.cursedT = dur;
                            m.curseDmgMult = 1 + red;
                        }
                    }
                    emitParticles(this.x, this.y, '#8844aa', 15, skDef.range * 0.5, 0.4, 3, 0);
                    addLog(`å‘ªç¸›ï¼æ•µã®è¢«ãƒ€ãƒ¡å¢—åŠ (${dur}ç§’)`, '#8844aa');
                    break;
                }
                case 'dark_orb': {
                    playSound(300, 'sine', 0.15, 0.08);
                    const mult = skDef.baseMult[li];
                    const spd = skDef.speed || 250;
                    const p = new Projectile(this.x, this.y, wx, wy, dmg * mult, '#8800ff', spd, 10);
                    p.pierce = true;
                    projectiles.push(p);
                    emitParticles(this.x, this.y, '#8800ff', 8, 40, 0.3, 3, 0);
                    break;
                }

                case 'battle_orders': {
                    const boBonus = skDef.bonus[li];
                    const boDur = skDef.duration[li];
                    const hpBoost = Math.round(player.maxHP * boBonus);
                    const mpBoost = Math.round(player.maxMP * boBonus);
                    player.maxHP += hpBoost;
                    player.maxMP += mpBoost;
                    player.hp = Math.min(player.maxHP, player.hp + hpBoost);
                    player.mp = Math.min(player.maxMP, player.mp + mpBoost);
                    player.battleOrdersT = boDur;
                    player.battleOrdersHP = hpBoost;
                    player.battleOrdersMP = mpBoost;
                    playSound(250, 'triangle', 0.2, 0.1);
                    emitParticles(this.x, this.y, '#ffd700', 20, 80, 0.6, 4, -30);
                    addLog(`ãƒãƒˆãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼ï¼HP+${hpBoost} MP+${mpBoost} (${boDur}ç§’)`, '#ffd700');
                    break;
                }
                case 'summon_minion': {
                    const sDur = skDef.duration[li];
                    const sHP = skDef.minionHP[li];
                    const sDmg = skDef.minionDmg[li];
                    if (!G.minions) G.minions = [];
                    G.minions = G.minions.filter(m => m.life > 0);
                    if (G.minions.length < 2) {
                        G.minions.push({
                            x: this.x + randf(-30, 30), y: this.y + randf(-30, 30),
                            hp: sHP, maxHP: sHP, dmg: sDmg, life: sDur,
                            attackCD: 0, r: 12
                        });
                    }
                    playSound(500, 'sine', 0.15, 0.08);
                    emitParticles(this.x, this.y, '#88ddff', 15, 60, 0.5, 3, -30);
                    addLog(`å¬å–šï¼(HP:${sHP} ATK:${sDmg} ${sDur}ç§’)`, '#88ddff');
                    break;
                }
                case 'frozen_orb': {
                    playSound(600, 'sine', 0.12, 0.06);
                    const orbMult = skDef.baseMult[li];
                    const orbSpd = skDef.speed || 200;
                    const shards = skDef.shardCount ? skDef.shardCount[li] : 8;
                    const orbP = new Projectile(this.x, this.y, wx, wy, dmg * orbMult * 0.5, '#88ccff', orbSpd, 12);
                    orbP.pierce = true;
                    orbP.frozen_orb = true;
                    orbP.shardDmg = dmg * orbMult * 0.3;
                    orbP.shardCount = shards;
                    orbP.shardTimer = 0;
                    projectiles.push(orbP);
                    emitParticles(this.x, this.y, '#88ddff', 10, 50, 0.3, 3, 0);
                    break;
                }
            }
        },

        update(dt) {
            // Regen
            this.mp = Math.min(this.maxMP, this.mp + (1 + this.int * 0.05) * dt);
            // Battle Orders timer
            if (this.battleOrdersT > 0) {
                this.battleOrdersT -= dt;
                if (this.battleOrdersT <= 0) {
                    this.maxHP -= this.battleOrdersHP;
                    this.maxMP -= this.battleOrdersMP;
                    this.hp = Math.min(this.maxHP, this.hp);
                    this.mp = Math.min(this.maxMP, this.mp);
                    this.battleOrdersHP = 0;
                    this.battleOrdersMP = 0;
                    addLog('ãƒãƒˆãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼ã®åŠ¹æœãŒåˆ‡ã‚ŒãŸ', '#888');
                }
            }
            this.hp = Math.min(this.maxHP, this.hp + (0.5 + this.vit * 0.02) * dt);

            // Skill cooldowns
            for (const sk of Object.values(this.skills)) {
                if (sk.cooldown > 0) sk.cooldown = Math.max(0, sk.cooldown - dt);
            }

            // Whirlwind anim
            if (this.whirlwindT > 0) this.whirlwindT -= dt;

            // Frost Nova timer
            if (this.freezeT > 0) this.freezeT -= dt;

            // Magic Shield timer
            if (this.shieldT > 0) this.shieldT -= dt;

            // Berserk timer
            if (this.berserkT > 0) this.berserkT -= dt;
            // Dodge timer
            if (this.dodgeT > 0) this.dodgeT -= dt;
            // Mana Shield timer
            if (this.manaShieldT > 0) this.manaShieldT -= dt;

            // Counter timer
            if (this.counterT > 0) this.counterT -= dt;
            // Speed buff timer
            if (this.speedBuffT > 0) {
                this.speedBuffT -= dt;
                if (this.speedBuffT <= 0) this.speedBuffBonus = 0;
            }
            // Poison buff timer
            if (this.poisonBuffT > 0) this.poisonBuffT -= dt;
            // Attack speed buff timer
            if (this.atkSpdBuffT > 0) this.atkSpdBuffT -= dt;
            // Lifesteal buff timer
            if (this.lifestealBuffT > 0) this.lifestealBuffT -= dt;
            // Undying timer
            if (this.undyingT > 0) this.undyingT -= dt;
            // Stealth timer
            if (this.stealthT > 0) this.stealthT -= dt;
            // Crit buff timer
            if (this.critBuffT > 0) this.critBuffT -= dt;
            // Aura timer
            if (this.auraT > 0) {
                this.auraT -= dt;
                this.hp = Math.min(this.maxHP, this.hp + (this.auraRegen || 0) * dt);
            }
            // Consecrations
            if (G.consecrations) {
                for (let ci = G.consecrations.length - 1; ci >= 0; ci--) {
                    const con = G.consecrations[ci];
                    con.life -= dt;
                    con.tickCD -= dt;
                    if (con.tickCD <= 0) {
                        con.tickCD = 0.5;
                        for (const m of monsters) {
                            if (m.alive && dist(con.x, con.y, m.x, m.y) < con.range) {
                                monsterTakeDmg(m, con.dmg * 0.2, false);
                            }
                        }
                    }
                    if (con.life <= 0) G.consecrations.splice(ci, 1);
                }
            }
            // Meteor timer - explode when ready
            if (this.meteorT > 0) {
                this.meteorT -= dt;
                // Warning particles
                if (G.meteorX) {
                    emitParticles(G.meteorX + randf(-50,50), G.meteorY + randf(-50,50), '#ff4400', 1, 10, 0.3, 2, -20);
                }
                if (this.meteorT <= 0 && G.meteorX) {
                    // BOOM
                    const mx = G.meteorX, my = G.meteorY;
                    sfxMeteorImpact();
                    G.shakeT = 0.4; G.shakeAmt = 8;
                    emitParticles(mx, my, '#ff4400', 40, 150, 0.8, 5, 50);
                    emitParticles(mx, my, '#ffaa00', 25, 100, 0.6, 4, 30);
                    emitParticles(mx, my, '#ffffff', 10, 60, 0.3, 2, 0);
                    for (const m of monsters) {
                        if (m.alive && dist(mx, my, m.x, m.y) < 100) {
                            const isCrit = Math.random() * 100 < this.getCritChance();
                            const d = isCrit ? G.meteorDmg * 2 : G.meteorDmg;
                            monsterTakeDmg(m, d, isCrit);
                        }
                    }
                    addLog('ãƒ¡ãƒ†ã‚ªç€å¼¾ï¼', '#ff4400');
                    G.meteorX = null; G.meteorY = null;
                }
            }

            // Attack cooldown
            if (this.attackCooldown > 0) this.attackCooldown -= dt;
            if (this.attackAnimT > 0) this.attackAnimT -= dt;

            // Attack target
            if (this.attacking && this.attackTarget && this.attackTarget.alive) {
                const d = dist(this.x, this.y, this.attackTarget.x, this.attackTarget.y);
                if (d < 50) {
                    if (this.attackCooldown <= 0) {
                        const dmg = this.getAttackDmg();
                        const isCrit = Math.random() * 100 < this.getCritChance();
                        const finalDmg = isCrit ? dmg * 2 : dmg;
                        monsterTakeDmg(this.attackTarget, finalDmg, isCrit);
                        this.attackCooldown = 0.5;
                        this.attackAnimT = 0.2;
                        sfxHit();

                        // Lifesteal
                        const ls = this.getLifesteal();
                        if (ls > 0) {
                            const heal = Math.round(finalDmg * ls / 100);
                            this.hp = Math.min(this.maxHP, this.hp + heal);
                        }
                    }
                    this.moving = false;
                } else {
                    this.targetX = this.attackTarget.x;
                    this.targetY = this.attackTarget.y;
                    this.moving = true;
                }
            }

            // Arrow key movement
            let kbMoveX = 0, kbMoveY = 0;
            if (keysDown['arrowup']) kbMoveY = -1;
            if (keysDown['arrowdown']) kbMoveY = 1;
            if (keysDown['arrowleft']) kbMoveX = -1;
            if (keysDown['arrowright']) kbMoveX = 1;
            if (kbMoveX !== 0 || kbMoveY !== 0) {
                // Normalize diagonal
                const kbLen = Math.hypot(kbMoveX, kbMoveY) || 1;
                kbMoveX /= kbLen; kbMoveY /= kbLen;
                const step = this.speed * dt;
                const nx = this.x + kbMoveX * step;
                const ny = this.y + kbMoveY * step;
                const cr = 10;
                const canBoth = canWalk(nx, ny, cr);
                const canX = canWalk(this.x + kbMoveX * step, this.y, cr);
                const canY = canWalk(this.x, this.y + kbMoveY * step, cr);
                if (canBoth) { this.x = nx; this.y = ny; }
                else if (canX) { this.x += kbMoveX * step; }
                else if (canY) { this.y += kbMoveY * step; }
                this.moving = false; // Cancel click-move
                this.attacking = false;
                sfxFootstep();
            }

            // Movement with proper circle collision
            if (this.moving) {
                sfxFootstep();
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const d = Math.hypot(dx, dy);
                if (d > 3) {
                    const mx = dx / d, my = dy / d;
                    const step = this.speed * dt;
                    const nx = this.x + mx * step;
                    const ny = this.y + my * step;

                    // Check circle collision: test 4 edge points of the circle
                    const cr = 10; // collision radius
                    const canMoveX = canWalk(this.x + mx * step, this.y, cr);
                    const canMoveY = canWalk(this.x, this.y + my * step, cr);
                    const canMoveBoth = canWalk(nx, ny, cr);

                    if (canMoveBoth) {
                        this.x = nx; this.y = ny;
                    } else if (canMoveX) {
                        this.x += mx * step;
                    } else if (canMoveY) {
                        this.y += my * step;
                    }
                    // else: stuck, don't move
                } else {
                    this.moving = false;
                }
            }
        },

        draw(cx, cy) {
            const sx = this.x - cx, sy = this.y - cy;

            // Magic Shield aura
            if (this.shieldT > 0) {
                const pulse = 0.6 + Math.sin(G.time * 6) * 0.15;
                ctx.strokeStyle = `rgba(120,120,255,${pulse})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, 22, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = `rgba(80,80,255,${pulse * 0.15})`;
                ctx.beginPath();
                ctx.arc(sx, sy, 21, 0, Math.PI * 2);
                ctx.fill();
            }

            // Frost Nova ring effect
            if (this.freezeT > 0) {
                const r = 130 * (1 - this.freezeT / 0.5);
                ctx.strokeStyle = `rgba(100,220,255,${this.freezeT})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Whirlwind effect
            if (this.whirlwindT > 0) {
                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(G.time * 15);
                for (let i = 0; i < 4; i++) {
                    const a = this.whirlwindT / 0.6;
                    ctx.strokeStyle = `rgba(100,150,255,${a * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 35 + i * 12, i * 1.5, i * 1.5 + 2.5);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(sx, sy + 16, 14, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Walking animation phase
            const walkPhase = this.moving ? Math.sin(G.time * 10) * 2 : 0;

            // Render character based on class
            if (this.classKey === 'warrior' || this.classKey === 'paladin' || this.classKey === 'berserker') this._drawGenericSprite(sx, sy, walkPhase, CLASS_DEFS[this.classKey].sprite);
            else if (this.classKey === 'rogue' || this.classKey === 'assassin' || this.classKey === 'ranger') this._drawGenericSprite(sx, sy, walkPhase, CLASS_DEFS[this.classKey].sprite);
            else if (this.classKey === 'sorcerer' || this.classKey === 'pyromancer' || this.classKey === 'cryomancer') this._drawGenericSprite(sx, sy, walkPhase, CLASS_DEFS[this.classKey].sprite);

            // HP/MP bars over head
            const hpFrac = this.hp / this.maxHP;
            const mpFrac = this.mp / this.maxMP;
            const barW = 30;
            ctx.fillStyle = '#1a0000';
            ctx.fillRect(sx - barW/2, sy + 20, barW, 3);
            ctx.fillStyle = hpFrac > 0.3 ? '#cc2222' : '#ff4444';
            ctx.fillRect(sx - barW/2, sy + 20, barW * hpFrac, 3);
            ctx.fillStyle = '#00001a';
            ctx.fillRect(sx - barW/2, sy + 24, barW, 2);
            ctx.fillStyle = '#4444cc';
            ctx.fillRect(sx - barW/2, sy + 24, barW * mpFrac, 2);
            // Level badge
            ctx.font = '9px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#daa520';
            ctx.fillText('Lv' + this.level, sx, sy - TILE/2 - 4);

            // Berserk aura (only sorcerer shows mana shield glow)
            if (this.manaShieldT > 0) {
                const manaGlow = 0.5 + Math.sin(G.time * 8) * 0.2;
                ctx.fillStyle = `rgba(100, 100, 255, ${manaGlow * 0.2})`;
                ctx.beginPath();
                ctx.arc(sx, sy, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        },
        _drawGenericSprite(sx, sy, walkPhase, spriteKey) {
            const bounce = this.moving ? Math.sin(walkPhase * 10) * 2 : 0;
            const flipX = this.targetX < this.x - 2;
            const atkTilt = this.attacking ? Math.sin(this.attackTimer * Math.PI * 6) * 0.15 : 0;
            ctx.save();
            ctx.translate(sx, sy + bounce);
            if (atkTilt) ctx.rotate(atkTilt);
            if (!drawSpr(spriteKey, -TILE/2, -TILE/2, TILE, TILE, flipX)) {
                // Fallback: try class-specific legacy method
                ctx.fillStyle = '#888'; ctx.fillRect(-TILE/4, -TILE/4, TILE/2, TILE/2);
            }
            ctx.restore();
            // Aura effects for promoted classes
            const classDef = CLASS_DEFS[this.classKey];
            if (classDef && classDef.tier > 0) {
                const colors = {paladin:'#ffd700',berserker:'#ff4400',assassin:'#8800ff',ranger:'#44ff44',pyromancer:'#ff6600',cryomancer:'#44ccff'};
                const c = colors[this.classKey] || '#ffffff';
                ctx.globalAlpha = 0.08 + Math.sin(G.time * 3) * 0.04;
                ctx.fillStyle = c;
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.5, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
            if (this.attacking) {
                ctx.globalAlpha = 0.25 * Math.abs(Math.sin(this.attackTimer * Math.PI * 4));
                ctx.fillStyle = '#ffaa44';
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        },
        _drawWarrior(sx, sy, walkPhase) {
            const bounce = this.moving ? Math.sin(walkPhase * 10) * 2 : 0;
            const flipX = this.targetX < this.x - 2;
            const atkTilt = this.attacking ? Math.sin(this.attackTimer * Math.PI * 6) * 0.15 : 0;
            ctx.save();
            ctx.translate(sx, sy + bounce);
            if (atkTilt) ctx.rotate(atkTilt);
            if (!drawSpr('knight', -TILE/2, -TILE/2, TILE, TILE, flipX)) {
                ctx.fillStyle = '#888'; ctx.fillRect(-TILE/4, -TILE/4, TILE/2, TILE/2);
            }
            ctx.restore();
            if (this.attacking) {
                ctx.globalAlpha = 0.25 * Math.abs(Math.sin(this.attackTimer * Math.PI * 4));
                ctx.fillStyle = '#ffaa44';
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        },
        _drawRogue(sx, sy, walkPhase) {
            const bounce = this.moving ? Math.sin(walkPhase * 10) * 2 : 0;
            const flipX = this.targetX < this.x - 2;
            const atkTilt = this.attacking ? Math.sin(this.attackTimer * Math.PI * 6) * 0.1 : 0;
            ctx.save();
            ctx.translate(sx, sy + bounce);
            if (atkTilt) ctx.rotate(atkTilt);
            if (!drawSpr('rogueChar', -TILE/2, -TILE/2, TILE, TILE, flipX)) {
                ctx.fillStyle = '#6a6'; ctx.fillRect(-TILE/4, -TILE/4, TILE/2, TILE/2);
            }
            ctx.restore();
            if (this.attacking) {
                ctx.globalAlpha = 0.2 * Math.abs(Math.sin(this.attackTimer * Math.PI * 4));
                ctx.fillStyle = '#88ff88';
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.5, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        },
        _drawSorcerer(sx, sy, walkPhase) {
            const bounce = this.moving ? Math.sin(walkPhase * 10) * 1.5 : 0;
            const flipX = this.targetX < this.x - 2;
            const magicGlow = 0.08 + Math.sin(G.time * 3) * 0.04;
            ctx.save();
            ctx.translate(sx, sy + bounce);
            if (!drawSpr('wizardM', -TILE/2, -TILE/2, TILE, TILE, flipX)) {
                ctx.fillStyle = '#66a'; ctx.fillRect(-TILE/4, -TILE/4, TILE/2, TILE/2);
            }
            ctx.restore();
            ctx.globalAlpha = magicGlow;
            ctx.fillStyle = '#6644ff';
            ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.5, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1;
            if (this.attacking) {
                ctx.globalAlpha = 0.3 * Math.abs(Math.sin(this.attackTimer * Math.PI * 4));
                ctx.fillStyle = '#4488ff';
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

    };

    // ========== MONSTERS ==========
    const MONSTER_DEFS = {
        skeleton: { name: 'ã‚¹ã‚±ãƒ«ãƒˆãƒ³', r: 12, hp: 40, dmg: 8, spd: 60, xp: 25, color: '#9a8a6a', loot: 0.4, icon: 'ğŸ’€' },
        zombie:   { name: 'ã‚¾ãƒ³ãƒ“', r: 14, hp: 70, dmg: 12, spd: 40, xp: 35, color: '#3a4a25', loot: 0.45, icon: 'ğŸ§Ÿ' },
        imp:      { name: 'ã‚¤ãƒ³ãƒ—', r: 10, hp: 30, dmg: 15, spd: 100, xp: 45, color: '#8a2a2a', loot: 0.5, icon: 'ğŸ‘¹' },
        ghost:    { name: 'ã‚´ãƒ¼ã‚¹ãƒˆ', r: 11, hp: 25, dmg: 10, spd: 110, xp: 55, color: '#555588', loot: 0.55, icon: 'ğŸ‘»' },
        demonlord:{ name: 'ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ­ãƒ¼ãƒ‰', r: 22, hp: 300, dmg: 30, spd: 70, xp: 300, color: '#8a1515', loot: 1.0, icon: 'ğŸ‘¿' }
    };

    const monsters = [];
    class Monster {
        constructor(x, y, type, floor) {
            this.x = x; this.y = y;
            this.type = type;
            const d = MONSTER_DEFS[type];
            this.def = d;
            const s = 1 + (floor - 1) * 0.3;
            this.maxHP = Math.round(d.hp * s);
            this.hp = this.maxHP;
            this.dmg = Math.round(d.dmg * s);
            this.spd = d.spd;
            this.r = d.r;
            this.alive = true;
            this.deathT = 0;
            this.atkCD = 0;
            this.phase = type === 'ghost';
            this.phaseAlpha = 1;
            this.hitFlash = 0;
            this.aggroRange = type === 'demonlord' ? 400 : 250;
            this.frozenT = 0;
            this.origSpd = d.spd;
            this.aggroed = false;
        }

        update(dt) {
            if (!this.alive) { this.deathT -= dt; return; }
            this.atkCD = Math.max(0, this.atkCD - dt);
            this.hitFlash = Math.max(0, this.hitFlash - dt);

            // Frozen state
            if (this.frozenT > 0) {
                this.frozenT -= dt;
                if (this.frozenT <= 0) {
                    this.spd = this.origSpd; // restore speed
                }
            }

            if (this.phase) {
                this.phaseAlpha = 0.3 + Math.sin(G.time * 3) * 0.3;
            }

            const d = dist(this.x, this.y, player.x, player.y);
            if (d < this.aggroRange && this.frozenT <= 0) {
                // Growl on first aggro
                if (!this.aggroed) { this.aggroed = true; sfxMonsterGrowl(); }
                const dx = player.x - this.x, dy = player.y - this.y;
                const len = Math.hypot(dx, dy) || 1;
                const step = this.spd * dt;
                const mx = dx / len, my = dy / len;
                const nx = this.x + mx * step;
                const ny = this.y + my * step;
                const cr = Math.max(this.r - 4, 4);

                if (this.phase) {
                    this.x = nx; this.y = ny;
                } else {
                    const canBoth = canWalk(nx, ny, cr);
                    const canX = canWalk(this.x + mx * step, this.y, cr);
                    const canY = canWalk(this.x, this.y + my * step, cr);
                    if (canBoth) { this.x = nx; this.y = ny; }
                    else if (canX) { this.x += mx * step; }
                    else if (canY) { this.y += my * step; }
                }

                if (d < this.r + player.radius + 10 && this.atkCD <= 0) {
                    player.takeDamage(this.dmg);
                    this.atkCD = 1.0;
                }
            }
        }

        _darken(hex, factor) {
            const r = parseInt(hex.slice(1,3),16);
            const g = parseInt(hex.slice(3,5),16);
            const b = parseInt(hex.slice(5,7),16);
            return `rgb(${Math.round(r*factor)},${Math.round(g*factor)},${Math.round(b*factor)})`;
        }

        draw(cx, cy) {
            const sx = this.x - cx, sy = this.y - cy;
            if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) return;

            if (!this.alive) {
                ctx.globalAlpha = clamp(this.deathT / 0.5, 0, 1);
            }
            if (this.phase) ctx.globalAlpha = this.phaseAlpha;

            ctx.save();

            // Shadow ellipse under all monsters
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(sx, sy + this.r + 3, this.r * 0.7, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Apply hit flash to drawing
            let alphaFlash = 1;
            if (this.hitFlash > 0) {
                alphaFlash = 0.5 + 0.5 * (this.hitFlash / 0.1);
            }

            // Type-specific detailed rendering
            if (this.type === 'skeleton') this._drawSkeleton(sx, sy, alphaFlash);
            else if (this.type === 'zombie') this._drawZombie(sx, sy, alphaFlash);
            else if (this.type === 'imp') this._drawImp(sx, sy, alphaFlash);
            else if (this.type === 'ghost') this._drawGhost(sx, sy, alphaFlash);
            else if (this.type === 'demonlord') this._drawDemonLord(sx, sy, alphaFlash);

            ctx.restore();
            ctx.globalAlpha = 1;

            // Frozen indicator overlay
            if (this.frozenT > 0) {
                ctx.strokeStyle = '#88ddff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, this.r + 4, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = 'rgba(100,200,255,0.15)';
                ctx.beginPath();
                ctx.arc(sx, sy, this.r + 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // HP bar
            if (this.alive && this.hp < this.maxHP) {
                const bw = this.r * 2.5;
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(sx - bw/2, sy - this.r - 10, bw, 4);
                ctx.fillStyle = this.hp / this.maxHP > 0.3 ? '#00aa00' : '#dd3300';
                ctx.fillRect(sx - bw/2, sy - this.r - 10, bw * (this.hp / this.maxHP), 4);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(sx - bw/2, sy - this.r - 10, bw, 4);
            }

            // Name plate
            if (this.alive) {
                ctx.fillStyle = '#aaaaaa';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.def.name, sx, sy + this.r + 12);
            }

            // Boss aura
            if (this.type === 'demonlord' && this.alive) {
                ctx.strokeStyle = `rgba(200,50,50,${0.25 + Math.sin(G.time * 3.5) * 0.1})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(sx, sy, this.r + 10, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Boss name override
            if (this.type === 'demonlord' && this.alive) {
                ctx.fillStyle = '#cc5555';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.def.name, sx, sy - this.r - 14);
            }
        }

    _drawSkeleton(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        drawSpr('skeleton', sx - TILE/2, sy - TILE/2, TILE, TILE, flipX);
        if (alphaFlash > 0) {
            ctx.globalAlpha = alphaFlash * 0.4; ctx.fillStyle = '#fff';
            ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE, TILE); ctx.globalAlpha = 1;
        }
    }

    _drawZombie(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        drawSpr('zombie', sx - TILE/2, sy - TILE/2, TILE, TILE, flipX);
        if (alphaFlash > 0) {
            ctx.globalAlpha = alphaFlash * 0.4; ctx.fillStyle = '#fff';
            ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE, TILE); ctx.globalAlpha = 1;
        }
    }

    _drawImp(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        drawSpr('imp', sx - TILE/2, sy - TILE/2, TILE, TILE, flipX);
        if (alphaFlash > 0) {
            ctx.globalAlpha = alphaFlash * 0.4; ctx.fillStyle = '#f44';
            ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE, TILE); ctx.globalAlpha = 1;
        }
    }

    _drawGhost(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        ctx.globalAlpha = 0.55 + Math.sin(G.time * 3) * 0.15;
        drawSpr('banshee', sx - TILE/2, sy - TILE/2, TILE, TILE, flipX);
        ctx.globalAlpha = 1;
        if (alphaFlash > 0) {
            ctx.globalAlpha = alphaFlash * 0.3; ctx.fillStyle = '#88f';
            ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE, TILE); ctx.globalAlpha = 1;
        }
    }

    _drawDemonLord(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        const bossScale = 1.35;
        const bw = TILE * bossScale, bh = TILE * bossScale;
        drawSpr('deathKnight', sx - bw/2, sy - bh/2, bw, bh, flipX);
        ctx.globalAlpha = 0.12 + Math.sin(G.time * 4) * 0.05;
        ctx.fillStyle = '#ff4400';
        ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.75, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
        if (alphaFlash > 0) {
            ctx.globalAlpha = alphaFlash * 0.4; ctx.fillStyle = '#ff0';
            ctx.fillRect(sx - bw/2, sy - bh/2, bw, bh); ctx.globalAlpha = 1;
        }
    }
    }

    function monsterTakeDmg(m, dmg, isCrit) {
        m.hp -= dmg;
        m.hitFlash = 0.1;
        addFloatingText(m.x, m.y - m.r - 10, Math.round(dmg), isCrit ? '#ffff00' : '#ff6666', isCrit);
        emitParticles(m.x, m.y, '#cc0000', isCrit ? 10 : 5, 70, 0.4, 3);
        if (m.hp <= 0) {
            m.alive = false;
            m.deathT = 0.5;
            sfxMonsterDeath();
            addBloodPool(m.x, m.y, m.r * 2 + 5);
            emitParticles(m.x, m.y, '#660000', 8, 50, 0.6, 2, 80);
            player.addXP(m.def.xp * (1 + (G.floor - 1) * 0.1));
            // Drop loot
            if (Math.random() < m.def.loot) {
                const count = m.type === 'demonlord' ? rand(3, 5) : 1;
                for (let i = 0; i < count; i++) dropItem(m.x, m.y, generateItem(G.floor));
            }
            if (Math.random() < 0.3) dropItem(m.x, m.y, generatePotion());
            addLog(`${m.def.name} ã‚’å€’ã—ãŸ! (+${m.def.xp} XP)`, '#ffaa00');
        }
    }

    // ========== PROJECTILES ==========
    const projectiles = [];
    class Projectile {
        constructor(x, y, tx, ty, dmg, color, spd, r) {
            this.x = x; this.y = y;
            this.dmg = dmg; this.color = color; this.r = r;
            const d = Math.hypot(tx - x, ty - y) || 1;
            this.vx = (tx - x) / d * spd;
            this.vy = (ty - y) / d * spd;
            this.life = 3;
            this.trail = [];
        }
        update(dt) {
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > 8) this.trail.shift();
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.life -= dt;
            emitParticles(this.x, this.y, this.color, 1, 20, 0.2, 2, 0);
        }
        draw(cx, cy) {
            // Trail
            for (let i = 0; i < this.trail.length; i++) {
                const a = (i / this.trail.length) * 0.5;
                ctx.globalAlpha = a;
                ctx.fillStyle = this.color;
                const s = this.r * (i / this.trail.length);
                ctx.beginPath();
                ctx.arc(this.trail[i].x - cx, this.trail[i].y - cy, s, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Glow
            const grd = ctx.createRadialGradient(this.x - cx, this.y - cy, 0, this.x - cx, this.y - cy, this.r * 3);
            grd.addColorStop(0, this.color + 'aa');
            grd.addColorStop(1, this.color + '00');
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(this.x - cx, this.y - cy, this.r * 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x - cx, this.y - cy, this.r * 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x - cx, this.y - cy, this.r, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // ========== DUNGEON INIT ==========
    let dungeon;
    let tileTexturesReady = false;
    function initFloor() {
        if (!tileTexturesReady) { generateTileTextures(); tileTexturesReady = true; }
        dungeon = new Dungeon(G.floor);
        const r0 = dungeon.rooms[0];
        player.x = r0.cx * TILE + TILE/2;
        player.y = r0.cy * TILE + TILE/2;
        player.targetX = player.x;
        player.targetY = player.y;
        player.moving = false;
        player.attacking = false;
        monsters.length = 0;
        groundItems.length = 0;
        projectiles.length = 0;
        particles.length = 0;
        bloodPools.length = 0;
        ambientParticles.length = 0;

        // Spawn monsters
        const count = 5 + G.floor * 3;
        const types = G.floor <= 2 ? ['skeleton', 'zombie'] :
                      G.floor <= 4 ? ['skeleton', 'zombie', 'imp'] :
                      G.floor <= 6 ? ['zombie', 'imp', 'ghost'] :
                      ['imp', 'ghost'];

        for (let i = 0; i < count; i++) {
            const room = dungeon.rooms[rand(1, dungeon.rooms.length - 1)];
            const mx = room.x * TILE + rand(TILE, (room.w - 1) * TILE);
            const my = room.y * TILE + rand(TILE, (room.h - 1) * TILE);
            monsters.push(new Monster(mx, my, types[rand(0, types.length - 1)], G.floor));
        }

        // Boss on every 5th floor
        if (G.floor % 5 === 0) {
            const bossRoom = dungeon.rooms[dungeon.rooms.length - 2] || dungeon.rooms[dungeon.rooms.length - 1];
            monsters.push(new Monster(bossRoom.cx * TILE + TILE/2, bossRoom.cy * TILE + TILE/2, 'demonlord', G.floor));
            addLog(`âš  ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒç¾ã‚ŒãŸï¼`, '#ff0000');
        }

        addLog(`åœ°ä¸‹${G.floor}éšã«é™ã‚ŠãŸ`, '#aaaaff');
    }

    // ========== LEVEL UP NOTICE ==========
    let levelUpTimer = 0;
    function showLevelUp() {
        levelUpTimer = 2;
        DOM.levelUpNotice.style.display = 'block';
    }

    // ========== UI UPDATES ==========
    function updateStatsPanel() {
        const el = DOM.statsContent;
        if (!isPanelVisible(DOM.statsPanel)) return;
        const btn = (stat) => player.statPoints > 0 ? `<button class="stat-btn" onclick="allocStat('${stat}')">+</button>` : '';
        const hpPct = Math.round(player.hp / player.maxHP * 100);
        const mpPct = Math.round(player.mp / player.maxMP * 100);
        const xpPct = Math.round(player.xp / player.xpToNext * 100);
        const shieldOn = player.shieldT > 0 ? '<span style="color:#88f"> [ã‚·ãƒ¼ãƒ«ãƒ‰ä¸­]</span>' : '';
        const killCount = G.totalKills || 0;

        el.innerHTML = `
            <div style="text-align:center;margin-bottom:8px">
                <span style="color:#ffd700;font-size:18px;font-weight:bold">Lv.${player.level}</span>
                <span style="color:#888;font-size:11px;margin-left:8px">å‹‡è€…</span>
            </div>
            <div style="background:#1a1020;border:1px solid #333;padding:6px;margin-bottom:8px;border-radius:3px">
                <div style="display:flex;justify-content:space-between;margin-bottom:4px">
                    <span style="color:#ff6666">HP ${Math.round(player.hp)}/${player.maxHP}</span>
                    <span style="color:#ff6666;font-size:10px">${hpPct}%</span>
                </div>
                <div style="background:#300;height:8px;border-radius:4px;overflow:hidden;margin-bottom:6px">
                    <div style="background:linear-gradient(90deg,#cc0000,#ff4444);height:100%;width:${hpPct}%;border-radius:4px;transition:width 0.3s"></div>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px">
                    <span style="color:#6688ff">MP ${Math.round(player.mp)}/${player.maxMP}</span>
                    <span style="color:#6688ff;font-size:10px">${mpPct}%</span>
                </div>
                <div style="background:#003;height:8px;border-radius:4px;overflow:hidden;margin-bottom:6px">
                    <div style="background:linear-gradient(90deg,#0044cc,#4488ff);height:100%;width:${mpPct}%;border-radius:4px;transition:width 0.3s"></div>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px">
                    <span style="color:#aa66ff">XP ${player.xp}/${player.xpToNext}</span>
                    <span style="color:#aa66ff;font-size:10px">${xpPct}%</span>
                </div>
                <div style="background:#201030;height:6px;border-radius:3px;overflow:hidden">
                    <div style="background:linear-gradient(90deg,#6622cc,#aa66ff);height:100%;width:${xpPct}%;border-radius:3px;transition:width 0.3s"></div>
                </div>
            </div>
            <div style="color:#ffcc44;font-size:11px;margin-bottom:4px">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚¤ãƒ³ãƒˆ: <span style="color:#ff8;font-weight:bold">${player.statPoints}</span></div>
            <hr style="border-color:#333;margin:6px 0">
            <div class="stat-row"><span class="stat-label">âš” ç­‹åŠ› (STR)</span><span class="stat-value">${player.getTotalStat('str')} ${btn('str')}</span></div>
            <div style="font-size:9px;color:#666;margin:-2px 0 4px 18px">ç‰©ç†ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ </div>
            <div class="stat-row"><span class="stat-label">ğŸ¹ æ•æ· (DEX)</span><span class="stat-value">${player.getTotalStat('dex')} ${btn('dex')}</span></div>
            <div style="font-size:9px;color:#666;margin:-2px 0 4px 18px">ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡å¢—åŠ </div>
            <div class="stat-row"><span class="stat-label">â¤ ä½“åŠ› (VIT)</span><span class="stat-value">${player.getTotalStat('vit')} ${btn('vit')}</span></div>
            <div style="font-size:9px;color:#666;margin:-2px 0 4px 18px">æœ€å¤§HP +5/pt</div>
            <div class="stat-row"><span class="stat-label">âœ¨ çŸ¥åŠ› (INT)</span><span class="stat-value">${player.getTotalStat('int')} ${btn('int')}</span></div>
            <div style="font-size:9px;color:#666;margin:-2px 0 4px 18px">æœ€å¤§MP +3/ptã€å›å¾©é‡å¢—åŠ </div>
            <hr style="border-color:#333;margin:6px 0">
            <div style="color:#ccc;font-size:11px;margin-bottom:4px">âš” æˆ¦é—˜ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
            <div class="stat-row"><span class="stat-label">æ”»æ’ƒåŠ›</span><span class="stat-value" style="color:#ff8866">${player.getAttackDmg()}</span></div>
            <div class="stat-row"><span class="stat-label">é˜²å¾¡åŠ›</span><span class="stat-value" style="color:#88aaff">${player.getDefense()}${shieldOn}</span></div>
            <div class="stat-row"><span class="stat-label">ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡</span><span class="stat-value" style="color:#ffcc44">${player.getCritChance().toFixed(1)}%</span></div>
            <div class="stat-row"><span class="stat-label">ãƒ©ã‚¤ãƒ•ã‚¹ãƒ†ã‚£ãƒ¼ãƒ«</span><span class="stat-value" style="color:#44ff88">${player.getLifesteal()}%</span></div>
            <div class="stat-row"><span class="stat-label">ç§»å‹•é€Ÿåº¦</span><span class="stat-value">${Math.round(player.speed)}</span></div>
            <hr style="border-color:#333;margin:6px 0">
            <div style="color:#ccc;font-size:11px;margin-bottom:4px">ğŸ—º æ¢ç´¢æƒ…å ±</div>
            <div class="stat-row"><span class="stat-label">ç¾åœ¨éšå±¤</span><span class="stat-value" style="color:#aa88ff">B${G.floor}F</span></div>
            <div class="stat-row"><span class="stat-label">æ®‹ã‚Šæ•µæ•°</span><span class="stat-value" style="color:#ff6666">${monsters.filter(m=>m.alive).length}</span></div>
            <div class="stat-row"><span class="stat-label">æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ </span><span class="stat-value">${player.inventory.length}/${player.maxInv}</span></div>
        `;
    }

    window.allocStat = function(stat) {
        if (player.statPoints <= 0) return;
        player[stat]++;
        player.statPoints--;
        player.recalcStats();
        updateStatsPanel();
    };

    function updateInventoryPanel() {
        const el = DOM.inventoryContent;
        if (!isPanelVisible(DOM.inventoryPanel)) return;

        let html = '<div style="color:#aaa;font-size:11px;margin-bottom:6px">è£…å‚™ã‚¹ãƒ­ãƒƒãƒˆ (ã‚¯ãƒªãƒƒã‚¯ã§å¤–ã™)</div>';
        html += '<div class="equip-slots">';
        const slotNames = { weapon: 'æ­¦å™¨', offhand: 'ç›¾', head: 'é ­', body: 'èƒ´', ring: 'æŒ‡', amulet: 'é¦–', feet: 'è¶³' };
        for (const [slot, label] of Object.entries(slotNames)) {
            const item = player.equipment[slot];
            const filled = item ? 'filled' : '';
            const style = item ? `border-color:${item.rarity.color}` : '';
            html += `<div class="equip-slot ${filled}" style="${style}" onclick="unequipSlot('${slot}')"
                onmouseenter="showEquipTooltip(event,'${slot}')" onmouseleave="hideTooltip()">
                ${item ? item.icon : ''}
                <div class="slot-label">${label}</div>
            </div>`;
        }
        html += '</div>';

        html += `<div style="color:#aaa;font-size:11px;margin:8px 0 4px">æ‰€æŒå“ ${player.inventory.length}/${player.maxInv} (ã‚¯ãƒªãƒƒã‚¯ã§è£…å‚™/ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æ¨ã¦ã‚‹)</div>`;
        html += '<div class="inv-grid">';
        for (let i = 0; i < player.maxInv; i++) {
            const item = player.inventory[i];
            if (item) {
                html += `<div class="inv-cell" style="border-color:${item.rarity.color}40"
                    onclick="equipInvItem(${i})" ondblclick="dropInvItem(${i})"
                    onmouseenter="showInvTooltip(event,${i})" onmouseleave="hideTooltip()">
                    ${item.icon}
                </div>`;
            } else {
                html += '<div class="inv-cell"></div>';
            }
        }
        html += '</div>';
        el.innerHTML = html;
    }

    window.unequipSlot = function(slot) { player.unequipSlot(slot); updateInventoryPanel(); };
    window.equipInvItem = function(i) { player.equipItem(i); updateInventoryPanel(); };
    window.dropInvItem = function(i) {
        const item = player.inventory[i];
        if (item) {
            dropItem(player.x, player.y, item);
            player.inventory.splice(i, 1);
            addLog(`${item.name} ã‚’æ¨ã¦ãŸ`, '#888');
            updateInventoryPanel();
        }
    };

    function buildTooltipHTML(item) {
        if (!item) return '';
        let html = `<div class="tt-name" style="color:${item.rarity.color}">${item.name}</div>`;
        html += `<div class="tt-type">${item.typeInfo.name} â€” ${item.rarity.name}</div>`;
        if (item.baseDmg) html += `<div style="color:#fff;margin:4px 0">ãƒ€ãƒ¡ãƒ¼ã‚¸: ${item.baseDmg[0]}-${item.baseDmg[1]}</div>`;
        if (item.baseDef) html += `<div style="color:#fff;margin:4px 0">é˜²å¾¡: +${item.baseDef}</div>`;
        for (const a of item.affixes) html += `<div class="tt-affix">${a.text}</div>`;
        if (item.typeInfo.slot) html += `<div class="tt-equip">ã‚¯ãƒªãƒƒã‚¯ã§è£…å‚™</div>`;
        return html;
    }

    window.showInvTooltip = function(e, i) {
        const item = player.inventory[i];
        if (!item) return;
        const tt = DOM.tooltip;
        tt.innerHTML = buildTooltipHTML(item);
        tt.style.display = 'block';
        tt.style.left = (e.clientX + 15) + 'px';
        tt.style.top = (e.clientY - 10) + 'px';
    };
    window.showEquipTooltip = function(e, slot) {
        const item = player.equipment[slot];
        if (!item) return;
        const tt = DOM.tooltip;
        tt.innerHTML = buildTooltipHTML(item);
        tt.style.display = 'block';
        tt.style.left = (e.clientX + 15) + 'px';
        tt.style.top = (e.clientY - 10) + 'px';
    };
    window.hideTooltip = function() { DOM.tooltip.style.display = 'none'; };

    function updateSkillTreeUI() {
        const el = DOM.skillTreeContent;
        if (!G.playerClass) return;
        const classDef = CLASS_DEFS[G.playerClass];
        const baseClassDef = classDef.baseClass ? CLASS_DEFS[classDef.baseClass] : null;
        let html = `<div style="text-align:center;margin-bottom:10px">
            <span style="font-size:20px">${classDef.icon}</span>
            <span style="color:#ffd700;font-size:16px;font-weight:bold;margin-left:8px">${classDef.name}</span>
            <span style="color:#888;font-size:12px;margin-left:8px">(${classDef.engName})</span>
            ${classDef.tier > 0 ? '<span style="color:#ff8800;font-size:10px;margin-left:6px">â˜…ä¸Šä½ã‚¯ãƒ©ã‚¹</span>' : ''}
            <div style="color:#ffcc44;font-size:12px;margin-top:6px">ã‚¹ã‚­ãƒ«ãƒã‚¤ãƒ³ãƒˆ: <span style="color:#ff8;font-weight:bold">${player.skillPoints}</span></div>
        </div>`;

        function renderBranches(cDef, label) {
            let h = '';
            if (label) h += `<div style="color:#aa88ff;font-size:12px;text-align:center;margin:8px 0 4px;border-top:1px solid #333;padding-top:6px">${label}</div>`;
            for (let b = 0; b < cDef.branches.length; b++) {
                const branchSkills = cDef.skills.filter(s => s.branch === b);
                h += '<div class="skill-branch"><div class="skill-branch-title">' + cDef.branches[b] + '</div><div>';
                for (const sk of branchSkills) {
                    const lvl = player.skillLevels[sk.id] || 0;
                    const maxLvl = 3;
                    const allAvail = getAllAvailableSkills();
                    const canLearn = lvl < maxLvl && player.skillPoints > 0 &&
                        (!sk.prereq || (player.skillLevels[sk.prereq] || 0) >= 1);
                    const stateClass = lvl >= maxLvl ? 'maxed' : lvl > 0 ? 'unlocked' : canLearn ? '' : 'locked';
                    const lvlStars = 'â˜…'.repeat(lvl) + 'â˜†'.repeat(maxLvl - lvl);
                    const btnHtml = canLearn ? '<button class="sn-btn" onclick="learnSkill(\'' + sk.id + '\')">ç¿’å¾— (+1)</button>' : '';
                    const prereqName = sk.prereq ? allAvail.find(s=>s.id===sk.prereq)?.name || '' : '';
                    h += '<div class="skill-node ' + stateClass + '">' +
                        '<div class="sn-icon">' + sk.icon + '</div>' +
                        '<div class="sn-name">' + sk.name + '</div>' +
                        '<div class="sn-level">' + lvlStars + ' (Lv.' + lvl + '/' + maxLvl + ')</div>' +
                        '<div class="sn-desc">' + sk.desc + '</div>' +
                        '<div style="color:#4488ff;font-size:9px;margin-top:2px">MP:' + sk.mp + ' CD:' + sk.cd + 's</div>' +
                        (sk.prereq ? '<div style="color:#885;font-size:9px">å¿…è¦: ' + prereqName + '</div>' : '') +
                        btnHtml +
                        '</div>';
                }
                h += '</div></div>';
            }
            return h;
        }

        html += renderBranches(classDef, null);
        if (baseClassDef) {
            html += renderBranches(baseClassDef, '--- ' + baseClassDef.name + 'ã‚¹ã‚­ãƒ« ---');
        }
        el.innerHTML = html;
    }

    window.learnSkill = function(skillId) {
        if (player.skillPoints <= 0) return;
        const allAvail = getAllAvailableSkills();
        const sk = allAvail.find(s => s.id === skillId);
        if (!sk) return;
        const lvl = player.skillLevels[skillId] || 0;
        if (lvl >= 3) return;
        if (sk.prereq && (player.skillLevels[sk.prereq] || 0) < 1) return;
        player.skillLevels[skillId] = lvl + 1;
        player.skillPoints--;
        // Update skill slot cooldown data
        for (let si = 1; si <= 6; si++) {
            if (player.skills[si] && player.skills[si].id === skillId) {
                player.skills[si].maxCD = sk.cd * (1 - (player.skillLevels[skillId] - 1) * 0.1);
            }
        }
        updateSkillTreeUI();
        addLog(`${sk.name} ã‚’Lv.${player.skillLevels[skillId]}ã«å¼·åŒ–ï¼`, '#ffd700');
    };

    function renderSettingsUI() {
        const rows = [
            { key: 'sound', label: 'ã‚µã‚¦ãƒ³ãƒ‰', value: SETTINGS.sound },
            { key: 'screenShake', label: 'ç”»é¢æºã‚Œ', value: SETTINGS.screenShake },
            { key: 'reducedParticles', label: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‰Šæ¸›', value: SETTINGS.reducedParticles },
            { key: 'filmGrain', label: 'ãƒ•ã‚£ãƒ«ãƒ ã‚°ãƒ¬ã‚¤ãƒ³', value: SETTINGS.filmGrain },
            { key: 'showFPS', label: 'FPS è¡¨ç¤º', value: SETTINGS.showFPS }
        ];
        let html = '<div style="color:#ccb38a;font-size:11px;margin-bottom:8px">ã‚²ãƒ¼ãƒ ã®æ¼”å‡ºã‚„è² è·ã‚’èª¿æ•´ã§ãã¾ã™ã€‚</div>';
        for (const r of rows) {
            const on = r.value ? 'ON' : 'OFF';
            const cls = r.value ? '' : 'off';
            html += `<div class="setting-row">
                <div class="setting-label">${r.label}</div>
                <button class="toggle-btn ${cls}" onclick="toggleSetting('${r.key}')">${on}</button>
            </div>`;
        }
        html += `<div class="setting-row">
            <div class="setting-label">è‡ªå‹•æ‹¾ã„</div>
            <button class="toggle-btn ${G.autoPickup ? '' : 'off'}" onclick="toggleAutoPickup()">${G.autoPickup ? 'ON' : 'OFF'}</button>
        </div>`;
        html += `<div class="setting-row">
            <div class="setting-label">æ‹¾ã„ãƒ•ã‚£ãƒ«ã‚¿</div>
            <button class="toggle-btn" onclick="cyclePickupFilter()">${getPickupFilterLabel()}</button>
        </div>`;
        DOM.settingsContent.innerHTML = html;
    }

    window.toggleSetting = function(key) {
        if (!(key in SETTINGS)) return;
        if (key === 'sound') {
            setSoundEnabled(!SETTINGS.sound);
        } else {
            SETTINGS[key] = !SETTINGS[key];
            saveSettings();
        }
        renderSettingsUI();
    };
    window.toggleAutoPickup = function() {
        G.autoPickup = !G.autoPickup;
        addLog(G.autoPickup ? 'è‡ªå‹•æ‹¾ã„: ON' : 'è‡ªå‹•æ‹¾ã„: OFF', '#ffdd44');
        renderSettingsUI();
    };
    function getPickupFilterLabel() {
        const names = ['ãƒãƒ¼ãƒãƒ«ä»¥ä¸Š','ãƒã‚¸ãƒƒã‚¯ä»¥ä¸Š','ãƒ¬ã‚¢ä»¥ä¸Š','ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼ä»¥ä¸Š'];
        const rarities = ['normal','magic','rare','legendary'];
        const idx = rarities.indexOf(G.autoPickupRarity);
        return names[idx] || names[0];
    }
    window.cyclePickupFilter = function() {
        const rarities = ['normal','magic','rare','legendary'];
        const idx = rarities.indexOf(G.autoPickupRarity);
        const next = (idx + 1) % rarities.length;
        G.autoPickupRarity = rarities[next];
        addLog('è‡ªå‹•æ‹¾ã„ãƒ•ã‚£ãƒ«ã‚¿: ' + getPickupFilterLabel(), '#ffdd44');
        renderSettingsUI();
    };

    function isPanelVisible(panel) {
        return getComputedStyle(panel).display !== 'none';
    }
    function setPanelVisible(panel, visible) {
        panel.style.display = visible ? 'block' : 'none';
    }
    function togglePanel(panel) {
        const visible = isPanelVisible(panel);
        panel.style.display = visible ? 'none' : 'block';
        return !visible;
    }

    function setPaused(paused) {
        G.paused = paused;
        DOM.pauseOverlay.style.display = paused ? 'flex' : 'none';
        if (paused) DOM.tooltip.style.display = 'none';
        if (paused) {
            for (const k of Object.keys(keysDown)) keysDown[k] = false;
        }
    }

    // ========== INPUT ==========
    let mouse = { x: 0, y: 0 };
    let keysDown = {};

    canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; }, { passive: true });

    canvas.addEventListener('contextmenu', e => { e.preventDefault(); });

    canvas.addEventListener('mousedown', e => {
        if (G.dead || !G.started || G.paused || isPanelVisible(DOM.settingsPanel) || skillSelectOpen) return;
        e.preventDefault();

        if (e.button === 2) {
            // Right click - use skill
            player.useSkill(mouse.x, mouse.y);
            return;
        }

        if (e.button === 0) {
            const wx = mouse.x + G.camX, wy = mouse.y + G.camY;

            // Check if clicking a monster
            let clickedMonster = null;
            for (const m of monsters) {
                if (m.alive && dist(wx, wy, m.x, m.y) < m.r + 10) {
                    clickedMonster = m;
                    break;
                }
            }

            if (clickedMonster) {
                player.attacking = true;
                player.attackTarget = clickedMonster;
                player.moving = true;
                player.targetX = clickedMonster.x;
                player.targetY = clickedMonster.y;
            } else {
                // Check ground items first
                let clickedItem = false;
                for (let i = groundItems.length - 1; i >= 0; i--) {
                    const gi = groundItems[i];
                    if (dist(wx, wy, gi.x, gi.y) < 25) {
                        // Move to item then pick up
                        player.targetX = gi.x;
                        player.targetY = gi.y;
                        player.moving = true;
                        player.attacking = false;
                        player.attackTarget = null;
                        clickedItem = true;
                        break;
                    }
                }
                if (!clickedItem) {
                    player.targetX = wx;
                    player.targetY = wy;
                    player.moving = true;
                    player.attacking = false;
                    player.attackTarget = null;
                }
            }
        }
    });

    document.addEventListener('keydown', e => {
        keysDown[e.key.toLowerCase()] = true;
        if (e.code) keysDown[e.code] = true;
        if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key.toLowerCase())) e.preventDefault();

        // --- Title screen keyboard navigation ---
        if (!G.started) {
            if (G.titlePhase === 'start') {
                if (e.key === 'Enter' || e.code === 'Space') {
                    e.preventDefault();
                    if (hasSaveData() && confirm('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸã€‚ç¶šãã‹ã‚‰ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™ã‹ï¼Ÿ\nï¼ˆã‚­ãƒ£ãƒ³ã‚»ãƒ«ã§æ–°è¦ã‚²ãƒ¼ãƒ ï¼‰')) {
                        initAudio();
                        loadGame();
                    } else {
                        showClassSelect();
                    }
                    return;
                }
            } else if (G.titlePhase === 'classSelect') {
                if (e.key === 'ArrowLeft') {
                    G.selectedClassIdx = (G.selectedClassIdx + 2) % 3;
                    updateClassHighlight();
                    return;
                }
                if (e.key === 'ArrowRight') {
                    G.selectedClassIdx = (G.selectedClassIdx + 1) % 3;
                    updateClassHighlight();
                    return;
                }
                if (e.key === 'Enter' || e.code === 'Space') {
                    e.preventDefault();
                    confirmClassSelect();
                    return;
                }
            }
            return; // Don't process game keys when on title
        }

        // --- Death screen keyboard ---
        if (G.dead) {
            if (e.key === 'Enter' || e.code === 'Space') {
                e.preventDefault();
                initAudio();
                G.dead = false;
                setPaused(false);
                G.floor = Math.max(1, G.floor - 1);
                player.hp = player.maxHP;
                player.mp = player.maxMP;
                DOM.deathScreen.style.display = 'none';
                initFloor();
                addLog('å¾©æ´»ã—ãŸ...', '#ffaaaa');
            }
            return;
        }

        if (promotionPending) return;

        // Save/Load
        if (e.code === 'F5') { e.preventDefault(); saveGame(); return; }
        if (e.code === 'F8') { e.preventDefault(); loadGame(); return; }

        // Pause / Settings
        if (e.code === 'Escape') {
            e.preventDefault();
            if (isPanelVisible(DOM.settingsPanel)) {
                setPanelVisible(DOM.settingsPanel, false);
                setPaused(false);
            } else {
                setPaused(!G.paused);
            }
            return;
        }
        if (e.code === 'KeyO') {
            e.preventDefault();
            const opened = togglePanel(DOM.settingsPanel);
            if (opened) {
                renderSettingsUI();
                setPaused(true);
                DOM.pauseOverlay.style.display = 'none';
            } else {
                setPaused(false);
            }
            return;
        }

        if (G.paused) return;

        // --- A key: Attack nearest enemy (use e.code for IME compatibility) ---
        if (e.code === 'KeyA') {
            e.preventDefault();
            let nearest = null, nearestD = 300;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                player.attacking = true;
                player.attackTarget = nearest;
                player.moving = true;
                player.targetX = nearest.x;
                player.targetY = nearest.y;
            }
            return;
        }

        // --- S key: Use selected skill (use e.code for IME compatibility) ---
        if (e.code === 'KeyS') {
            e.preventDefault();
            // Use skill toward nearest enemy, or toward mouse if no enemy nearby
            let tx = mouse.x, ty = mouse.y;
            let nearest = null, nearestD = 400;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                tx = nearest.x - G.camX;
                ty = nearest.y - G.camY;
            }
            player.useSkill(tx, ty);
            return;
        }

        if (e.code === 'KeyC') {
            e.preventDefault();
            const p = DOM.statsPanel;
            togglePanel(p);
            updateStatsPanel();
        }
        if (e.code === 'KeyI') {
            e.preventDefault();
            const p = DOM.inventoryPanel;
            togglePanel(p);
            updateInventoryPanel();
        }
        if (e.code === 'KeyH') {
            e.preventDefault();
            const p = DOM.helpOverlay;
            togglePanel(p);
        }
        if (e.code === 'KeyG') {
            toggleAutoPickup();
        }
        if (e.code === 'KeyP') {
            cyclePickupFilter();
        }
        if (e.code === 'KeyR') {
            e.preventDefault();
            if (skillSelectOpen) { closeSkillSelect(); }
            else { skillSelectSlot = 1; showSkillSelectUI(); }
        }
        if (e.code === 'KeyT') {
            e.preventDefault();
            const p = DOM.skillTreePanel;
            const opened = togglePanel(p);
            if (opened) updateSkillTreeUI();
        }
        if (e.code === 'Digit1' || e.key === '1') player.selectedSkill = 1;
        if (e.code === 'Digit2' || e.key === '2') player.selectedSkill = 2;
        if (e.code === 'Digit3' || e.key === '3') player.selectedSkill = 3;
        if (e.code === 'Digit4' || e.key === '4') player.selectedSkill = 4;
        if (e.code === 'Digit5' || e.key === '5') player.selectedSkill = 5;
        if (e.code === 'Digit6' || e.key === '6') player.selectedSkill = 6;
        if (e.code === 'Space') { e.preventDefault(); player.pickupNearby(); }
    });
    document.addEventListener('keyup', e => {
        keysDown[e.key.toLowerCase()] = false;
        if (e.code) keysDown[e.code] = false;
    });

    // ========== TITLE SCREEN ==========
    const CLASS_KEYS = ['warrior', 'rogue', 'sorcerer'];

    function showClassSelect() {
        initAudio();
        G.titlePhase = 'classSelect';
        G.selectedClassIdx = 0;
        DOM.titleStartText.style.display = 'none';
        DOM.classSelect.style.display = 'block';
        updateClassHighlight();
    }

    function updateClassHighlight() {
        const cards = document.querySelectorAll('.class-card');
        cards.forEach((c, i) => {
            if (i === G.selectedClassIdx) {
                c.style.borderColor = '#ffd700';
                c.style.boxShadow = '0 0 20px rgba(218,165,32,0.4)';
                c.style.transform = 'translateY(-5px)';
            } else {
                c.style.borderColor = '#5a4a3a';
                c.style.boxShadow = 'none';
                c.style.transform = 'none';
            }
        });
    }

    function confirmClassSelect() {
        selectClass(CLASS_KEYS[G.selectedClassIdx]);
    }

    // Click handlers still work
    DOM.titleStartText.addEventListener('click', (e) => {
        e.stopPropagation();
        showClassSelect();
    });

    window.selectClass = function(cls) {
        G.playerClass = cls;
        const classDef = CLASS_DEFS[cls];
        player.className = classDef.name;
        player.classKey = cls;
        player.str = classDef.baseStr;
        player.dex = classDef.baseDex;
        player.vit = classDef.baseVit;
        player.int = classDef.baseInt;
        player.skillPoints = 0;
        player.skillLevels = {};
        // Initialize skill levels to 0
        for (const sk of classDef.skills) {
            player.skillLevels[sk.id] = 0;
        }
        // Unlock starting skills (first skill in each branch, level 1)
        player.skillLevels[classDef.skills[0].id] = 1;
        player.skillLevels[classDef.skills[3].id] = 1;
        // Set active skill slots from class skills (pick first 6)
        rebuildSkillBar();
        DOM.titleScreen.style.display = 'none';
        setPaused(false);
        setPanelVisible(DOM.settingsPanel, false);
        G.started = true;
        G.hintTimer = 8;
        player.recalcStats();
        player.hp = player.maxHP;
        player.mp = player.maxMP;
        initFloor();
    };

    DOM.deathScreen.addEventListener('click', () => {
        initAudio();
        G.dead = false;
        setPaused(false);
        G.floor = Math.max(1, G.floor - 1);
        player.hp = player.maxHP;
        player.mp = player.maxMP;
        DOM.deathScreen.style.display = 'none';
        initFloor();
        addLog('å¾©æ´»ã—ãŸ...', '#ffaaaa');
    });

    // ========== DRAWING HELPERS ==========
    function drawLighting() {
        dungeon.reveal(player.x, player.y, 300);
        const px = player.x - G.camX, py = player.y - G.camY;
        // Dynamic torch flicker
        const flicker = Math.sin(G.time * 4.7) * 10 + Math.sin(G.time * 7.3) * 5 + Math.sin(G.time * 13.1) * 3;
        const lightR = 350 + flicker;

        // Main darkness overlay - deeper darkness
        const lg = ctx.createRadialGradient(px, py, lightR * 0.2, px, py, lightR);
        lg.addColorStop(0, 'rgba(0,0,5,0)');
        lg.addColorStop(0.35, 'rgba(0,0,5,0.1)');
        lg.addColorStop(0.6, 'rgba(0,0,5,0.35)');
        lg.addColorStop(0.8, 'rgba(0,0,5,0.65)');
        lg.addColorStop(1, 'rgba(0,0,5,0.88)');
        ctx.fillStyle = lg;
        ctx.fillRect(0, 0, W, H);

        // Warm torch tint - amber/orange Diablo glow
        const warmG = ctx.createRadialGradient(px, py, 0, px, py, lightR * 0.55);
        warmG.addColorStop(0, 'rgba(255,160,60,0.14)');
        warmG.addColorStop(0.3, 'rgba(255,130,40,0.08)');
        warmG.addColorStop(0.7, 'rgba(255,100,20,0.03)');
        warmG.addColorStop(1, 'rgba(255,80,10,0)');
        ctx.fillStyle = warmG;
        ctx.beginPath();
        ctx.arc(px, py, lightR * 0.55, 0, Math.PI * 2);
        ctx.fill();

        // Color grading - warm amber tint (Diablo signature look)
        ctx.globalAlpha = 0.06;
        ctx.fillStyle = '#442200';
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        // Screen vignette - heavy, cinematic
        const vigSize = Math.max(W, H) * 0.7;
        const vig = ctx.createRadialGradient(W / 2, H / 2, vigSize * 0.3, W / 2, H / 2, vigSize);
        vig.addColorStop(0, 'rgba(0,0,0,0)');
        vig.addColorStop(0.6, 'rgba(0,0,0,0.2)');
        vig.addColorStop(0.85, 'rgba(0,0,0,0.45)');
        vig.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = vig;
        ctx.fillRect(0, 0, W, H);

        // Damage flash - red vignette when hit
        if (G.dmgFlashT > 0) {
            const flashA = clamp(G.dmgFlashT / 0.35, 0, 1) * 0.4;
            const dmgVig = ctx.createRadialGradient(W/2, H/2, W*0.1, W/2, H/2, W*0.6);
            dmgVig.addColorStop(0, `rgba(120,0,0,0)`);
            dmgVig.addColorStop(0.5, `rgba(150,0,0,${flashA * 0.3})`);
            dmgVig.addColorStop(1, `rgba(180,0,0,${flashA})`);
            ctx.fillStyle = dmgVig;
            ctx.fillRect(0, 0, W, H);
        }
    }

    function drawGroundItems() {
        const TYPE_SPR = {sword:'iSword',axe:'iAxe',staff:'iStaff',shield:'iShield',helmet:'iHelmet',armor:'iArmor',ring:'iRing',amulet:'iAmulet',boots:'iBoots',potion:'iPotion'};
        for (const gi of groundItems) {
            gi.bobT += 0.02;
            const sx = gi.x - G.camX, sy = gi.y - G.camY + Math.sin(gi.bobT) * 3;
            if (sx < -30 || sx > W + 30 || sy < -30 || sy > H + 30) continue;

            // Rarity glow
            const c = gi.item.rarity.color;
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = c;
            ctx.beginPath(); ctx.arc(sx, sy, 13, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1;

            // Sprite icon: find matching type by icon
            let sprKey = null;
            for (const [tKey, tInfo] of Object.entries(ITEM_TYPES)) {
                if (tInfo.icon === gi.item.icon) { sprKey = TYPE_SPR[tKey]; break; }
            }
            if (!sprKey || !drawSpr(sprKey, sx - 14, sy - 14, 28, 28)) {
                ctx.font = `14px ${FONT_UI}`;
                ctx.textAlign = 'center';
                ctx.fillText(gi.item.icon, sx, sy + 5);
            }

            // Label
            ctx.font = `10px ${FONT_UI}`;
            ctx.textAlign = 'center';
            ctx.fillStyle = c;
            ctx.fillText(gi.item.name, sx, sy - 16);
        }
    }

    function drawHUD() {
        // ===== BOTTOM BAR BACKGROUND =====
        const barH = 80;
        const barY = H - barH;
        ctx.fillStyle = 'rgba(8,5,3,0.9)';
        ctx.fillRect(0, barY, W, barH);
        ctx.strokeStyle = '#5a4a3a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, barY);
        ctx.lineTo(W, barY);
        ctx.stroke();
        // Decorative line
        ctx.strokeStyle = '#3a2a1a';
        ctx.beginPath();
        ctx.moveTo(0, barY + 1);
        ctx.lineTo(W, barY + 1);
        ctx.stroke();

        // Health & Mana Globes
        const globeR = 30;
        const globeY = H - 40;

        // HP Globe (left)
        const hpX = 45;
        ctx.save();
        ctx.beginPath();
        ctx.arc(hpX, globeY, globeR, 0, Math.PI * 2);
        ctx.clip();
        // BG
        ctx.fillStyle = '#330000';
        ctx.fillRect(hpX - globeR, globeY - globeR, globeR * 2, globeR * 2);
        // Fill
        const hpPct = clamp(player.hp / player.maxHP, 0, 1);
        const hpFillH = globeR * 2 * hpPct;
        ctx.fillStyle = '#cc0000';
        ctx.fillRect(hpX - globeR, globeY + globeR - hpFillH, globeR * 2, hpFillH);
        // Sheen
        const hpSheen = ctx.createRadialGradient(hpX - 8, globeY - 8, 0, hpX, globeY, globeR);
        hpSheen.addColorStop(0, 'rgba(255,100,100,0.3)');
        hpSheen.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = hpSheen;
        ctx.fillRect(hpX - globeR, globeY - globeR, globeR * 2, globeR * 2);
        ctx.restore();
        // Border
        ctx.strokeStyle = '#8b6914';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(hpX, globeY, globeR, 0, Math.PI * 2);
        ctx.stroke();
        // Text
        ctx.fillStyle = '#fff';
        ctx.font = `bold 13px ${FONT_UI}`;
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(player.hp)}`, hpX, globeY + 4);
        ctx.font = `9px ${FONT_UI}`;
        ctx.fillStyle = '#faa';
        ctx.fillText('HP', hpX, globeY + 16);

        // MP Globe (right)
        const mpX = W - 50;
        ctx.save();
        ctx.beginPath();
        ctx.arc(mpX, globeY, globeR, 0, Math.PI * 2);
        ctx.clip();
        ctx.fillStyle = '#000033';
        ctx.fillRect(mpX - globeR, globeY - globeR, globeR * 2, globeR * 2);
        const mpPct = clamp(player.mp / player.maxMP, 0, 1);
        const mpFillH = globeR * 2 * mpPct;
        ctx.fillStyle = '#0044cc';
        ctx.fillRect(mpX - globeR, globeY + globeR - mpFillH, globeR * 2, mpFillH);
        const mpSheen = ctx.createRadialGradient(mpX - 8, globeY - 8, 0, mpX, globeY, globeR);
        mpSheen.addColorStop(0, 'rgba(100,100,255,0.3)');
        mpSheen.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = mpSheen;
        ctx.fillRect(mpX - globeR, globeY - globeR, globeR * 2, globeR * 2);
        ctx.restore();
        ctx.strokeStyle = '#4a4a8b';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(mpX, globeY, globeR, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = `bold 13px ${FONT_UI}`;
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(player.mp)}`, mpX, globeY + 4);
        ctx.font = `9px ${FONT_UI}`;
        ctx.fillStyle = '#aaf';
        ctx.fillText('MP', mpX, globeY + 16);

        // Skill bar - 6 slots
        const skillW = 48, skillH = 48, skillGap = 5;
        const numSkills = 6;
        const skillTotalW = numSkills * skillW + (numSkills - 1) * skillGap;
        const skillStartX = W / 2 - skillTotalW / 2;
        const skillY = H - 62;

        // Skill bar background
        ctx.fillStyle = 'rgba(10,8,5,0.85)';
        ctx.fillRect(skillStartX - 8, skillY - 5, skillTotalW + 16, skillH + 18);
        ctx.strokeStyle = '#8b7355';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(skillStartX - 8, skillY - 5, skillTotalW + 16, skillH + 18);

        for (let i = 1; i <= numSkills; i++) {
            const sk = player.skills[i];
            const x = skillStartX + (i - 1) * (skillW + skillGap);
            const sel = player.selectedSkill === i;

            // Background
            ctx.fillStyle = sel ? 'rgba(100,80,30,0.9)' : 'rgba(30,25,20,0.8)';
            ctx.fillRect(x, skillY, skillW, skillH);

            // Border
            ctx.strokeStyle = sel ? '#ffd700' : '#5a4a3a';
            ctx.lineWidth = sel ? 2 : 1;
            ctx.strokeRect(x, skillY, skillW, skillH);

            // Glow for selected
            if (sel) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 6;
                ctx.strokeRect(x, skillY, skillW, skillH);
                ctx.shadowBlur = 0;
            }

            // Icon
            ctx.font = `18px ${FONT_UI}`;
            ctx.textAlign = 'center';
            ctx.fillText(sk.icon, x + skillW / 2, skillY + 24);

            // Key number
            ctx.font = `bold 9px ${FONT_UI}`;
            ctx.fillStyle = sel ? '#ffd700' : '#777';
            ctx.fillText(i, x + skillW / 2, skillY + 40);

            // MP cost
            ctx.font = `7px ${FONT_UI}`;
            ctx.fillStyle = '#4488ff';
            ctx.fillText(sk.mp + 'MP', x + skillW / 2, skillY + skillH - 2);

            // Cooldown overlay
            if (sk.cooldown > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.65)';
                const cdPct = sk.cooldown / sk.maxCD;
                ctx.fillRect(x, skillY, skillW, skillH * cdPct);
                ctx.fillStyle = '#fff';
                ctx.font = `bold 13px ${FONT_UI}`;
                ctx.fillText(sk.cooldown.toFixed(1), x + skillW / 2, skillY + 28);
            }
        }

        // XP bar
        const xpW = skillTotalW + 60;
        const xpH = 6;
        const xpX = W / 2 - xpW / 2;
        const xpY = skillY - 12;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(xpX, xpY, xpW, xpH);
        ctx.fillStyle = '#8844ff';
        ctx.fillRect(xpX, xpY, xpW * (player.xp / player.xpToNext), xpH);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(xpX, xpY, xpW, xpH);
        ctx.fillStyle = '#aaa';
        ctx.font = `9px ${FONT_UI}`;
        ctx.textAlign = 'center';
        ctx.fillText(`Lv.${player.level}  ${player.xp}/${player.xpToNext} XP`, W / 2, xpY - 2);

        // Minimap
        const mmSize = 130;
        const mmX = W - mmSize - 10, mmY = 10;
        const mmScale = mmSize / (MAP_W * TILE);

        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(mmX, mmY, mmSize, mmSize);
        ctx.strokeStyle = '#8b7355';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(mmX, mmY, mmSize, mmSize);

        // Rooms - only explored ones
        for (const room of dungeon.rooms) {
            // Check if any tile in this room has been explored
            const explored = dungeon.explored[dungeon.idx(room.cx, room.cy)];
            if (explored) {
                ctx.fillStyle = '#2a2040';
                ctx.fillRect(
                    mmX + room.x * TILE * mmScale,
                    mmY + room.y * TILE * mmScale,
                    room.w * TILE * mmScale,
                    room.h * TILE * mmScale
                );
            }
        }


        // Explored corridor tiles (not just rooms)
        ctx.fillStyle = '#1a1530';
        for (let ty = 0; ty < MAP_H; ty++) {
            for (let tx = 0; tx < MAP_W; tx++) {
                if (dungeon.explored[dungeon.idx(tx, ty)] && dungeon.get(tx, ty) >= 1) {
                    let inRoom = false;
                    for (const room of dungeon.rooms) {
                        if (dungeon.explored[dungeon.idx(room.cx, room.cy)] &&
                            tx >= room.x && tx < room.x + room.w &&
                            ty >= room.y && ty < room.y + room.h) {
                            inRoom = true; break;
                        }
                    }
                    if (!inRoom) {
                        ctx.fillRect(
                            mmX + tx * TILE * mmScale, mmY + ty * TILE * mmScale,
                            Math.max(TILE * mmScale, 1.5), Math.max(TILE * mmScale, 1.5)
                        );
                    }
                }
            }
        }

        // Player on minimap
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(mmX + player.x * mmScale, mmY + player.y * mmScale, 3, 0, Math.PI * 2);
        ctx.fill();

        // Monsters on minimap - ONLY show if near player (within aggro/visibility range)
        const visionRange = 300;
        ctx.fillStyle = '#ff3333';
        for (const m of monsters) {
            if (m.alive && dist(player.x, player.y, m.x, m.y) < visionRange) {
                ctx.fillRect(mmX + m.x * mmScale - 1.5, mmY + m.y * mmScale - 1.5, 3, 3);
            }
        }

        // Stairs on minimap - only if explored
        const stairsExplored = dungeon.explored[dungeon.idx(dungeon.stairsX, dungeon.stairsY)];
        if (stairsExplored) {
            ctx.fillStyle = '#aa88ff';
            ctx.fillRect(mmX + dungeon.stairsX * TILE * mmScale - 2, mmY + dungeon.stairsY * TILE * mmScale - 2, 5, 5);
        }

        // Floor label
        ctx.fillStyle = '#daa520';
        ctx.font = `bold 14px ${FONT_UI}`;
        ctx.textAlign = 'right';
        ctx.fillText(`B${G.floor}F`, mmX - 5, mmY + 16);

        ctx.font = `11px ${FONT_UI}`;
        ctx.fillStyle = '#cc6666';
        ctx.fillText(`æ•µ: ${monsters.filter(m=>m.alive).length}`, mmX - 5, mmY + 32);

        // Auto-pickup indicator
        if (G.autoPickup) {
            ctx.font = `9px ${FONT_UI}`;
            ctx.fillStyle = '#88ff44';
            ctx.textAlign = 'right';
            ctx.fillText('AUTOæ‹¾ã„:ON', mmX - 5, mmY + 46);
        }

        // Stairs hint
        if (monsters.filter(m => m.alive).length === 0) {
            ctx.fillStyle = '#aaaaff';
            ctx.font = `12px ${FONT_UI}`;
            ctx.textAlign = 'center';
            ctx.fillText('éšæ®µã¸é€²ã‚ï¼', W / 2, 30);
        }

        if (SETTINGS.showFPS) {
            ctx.fillStyle = '#c8b18a';
            ctx.font = `10px ${FONT_UI}`;
            ctx.textAlign = 'right';
            ctx.fillText(`FPS ${fps.toFixed(0)}`, mmX - 6, 14);
        }

        // Persistent shortcut display (top-left)
        ctx.globalAlpha = 0.6;
        ctx.font = `10px ${FONT_UI}`;
        ctx.textAlign = 'left';
        const shortcuts = [
            ['çŸ¢å°', 'ç§»å‹•'],
            ['A', 'æ”»æ’ƒ'],
            ['S', 'ã‚¹ã‚­ãƒ«'],
            ['LClick', 'æ”»æ’ƒ'],
            ['RClick', 'ã‚¹ã‚­ãƒ«'],
            ['1-6', 'ã‚¹ã‚­ãƒ«é¸æŠ'],
            ['Space', 'æ‹¾ã†'],
            ['I', 'è£…å‚™'],
            ['C', 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹'],
            ['T', 'ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼'],
            ['H', 'ãƒ˜ãƒ«ãƒ—'],
            ['O', 'è¨­å®š'],
            ['Esc', 'ä¸€æ™‚åœæ­¢'],
            ['G', 'è‡ªå‹•æ‹¾ã„'],
            ['P', 'æ‹¾ã„ãƒ•ã‚£ãƒ«ã‚¿'],
            ['F5', 'ã‚»ãƒ¼ãƒ–'],
            ['F8', 'ãƒ­ãƒ¼ãƒ‰']
        ];
        let scX = 8;
        const scY = 14;
        for (const [key, desc] of shortcuts) {
            ctx.fillStyle = '#000';
            const kw = ctx.measureText(key).width;
            const dw = ctx.measureText(desc).width;
            const totalW = kw + dw + 8;
            ctx.fillStyle = 'rgba(0,0,0,0.45)';
            ctx.fillRect(scX - 2, scY - 10, totalW + 4, 14);
            ctx.fillStyle = '#c8a84e';
            ctx.fillText(key, scX, scY);
            ctx.fillStyle = '#998866';
            ctx.fillText(desc, scX + kw + 4, scY);
            scX += totalW + 8;
        }
        ctx.globalAlpha = 1;
    }

    function drawFloatingTexts() {
        for (const ft of floatingTexts) {
            const sx = ft.x - G.camX, sy = ft.y - G.camY + ft.vy * (ft.maxLife - ft.life);
            const a = clamp(ft.life / ft.maxLife, 0, 1);
            ctx.globalAlpha = a;
            ctx.font = ft.big ? `bold 24px ${FONT_UI}` : `bold 16px ${FONT_UI}`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#000';
            ctx.fillText(ft.text, sx + 1, sy + 1);
            ctx.fillStyle = ft.color;
            ctx.fillText(ft.text, sx, sy);
            ctx.globalAlpha = 1;
        }
    }

    // ========== SAVE / LOAD SYSTEM ==========
    function saveGame() {
        try {
            const saveData = {
                version: 2,
                timestamp: Date.now(),
                floor: G.floor,
                time: G.time,
                playerClass: G.playerClass,
                autoPickup: G.autoPickup,
                autoPickupRarity: G.autoPickupRarity,
                player: {
                    x: player.x, y: player.y,
                    level: player.level, xp: player.xp, xpToNext: player.xpToNext,
                    hp: player.hp, maxHP: player.maxHP,
                    mp: player.mp, maxMP: player.maxMP,
                    str: player.str, dex: player.dex, vit: player.vit, int: player.int,
                    statPoints: player.statPoints,
                    skillPoints: player.skillPoints,
                    classKey: player.classKey,
                    className: player.className,
                    skillLevels: { ...player.skillLevels },
                    defense: player.defense,
                    critChance: player.critChance,
                    equipment: {},
                    inventory: []
                }
            };
            for (const [slot, item] of Object.entries(player.equipment)) {
                saveData.player.equipment[slot] = item ? {
                    name: item.name, typeKey: item.typeKey,
                    rarityKey: item.rarityKey, rarity: item.rarity,
                    typeInfo: item.typeInfo,
                    baseStat: item.baseStat, statType: item.statType,
                    affixes: item.affixes || [], desc: item.desc || '',
                    icon: item.icon
                } : null;
            }
            for (const item of player.inventory) {
                saveData.player.inventory.push({
                    name: item.name, typeKey: item.typeKey,
                    rarityKey: item.rarityKey, rarity: item.rarity,
                    typeInfo: item.typeInfo,
                    baseStat: item.baseStat, statType: item.statType,
                    affixes: item.affixes || [], desc: item.desc || '',
                    icon: item.icon
                });
            }
            saveData.player.skills = {};
            for (let i = 1; i <= 6; i++) {
                const sk = player.skills[i];
                saveData.player.skills[i] = {
                    id: sk.id, name: sk.name, icon: sk.icon,
                    mp: sk.mp, maxCD: sk.maxCD, desc: sk.desc
                };
            }
            localStorage.setItem('diablo_save', JSON.stringify(saveData));
            addLog('ã‚²ãƒ¼ãƒ ã‚’ã‚»ãƒ¼ãƒ–ã—ã¾ã—ãŸï¼', '#00ff88');
            addFloatingText(player.x, player.y - 30, 'SAVED!', '#00ff88');
            emitParticles(player.x, player.y, '#00ff88', 15, 50, 0.5, 3, -40);
            playSound(600, 'sine', 0.1, 0.05);
            return true;
        } catch (e) {
            addLog('ã‚»ãƒ¼ãƒ–ã«å¤±æ•—: ' + e.message, '#ff4444');
            return false;
        }
    }

    function loadGame() {
        try {
            const raw = localStorage.getItem('diablo_save');
            if (!raw) { addLog('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', '#ff4444'); return false; }
            const save = JSON.parse(raw);
            if (!save.version || save.version < 2) {
                addLog('å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã§ã™ã€‚æ–°ã—ãã‚²ãƒ¼ãƒ ã‚’å§‹ã‚ã¦ãã ã•ã„', '#ff4444');
                return false;
            }
            G.floor = save.floor;
            G.time = save.time || 0;
            G.playerClass = save.playerClass;
            G.autoPickup = save.autoPickup || false;
            G.autoPickupRarity = save.autoPickupRarity || 'normal';
            G.dead = false;
            setPaused(false);
            setPanelVisible(DOM.settingsPanel, false);
            G.started = true;
            const p = save.player;
            player.level = p.level;
            player.xp = p.xp;
            player.xpToNext = p.xpToNext;
            player.str = p.str; player.dex = p.dex;
            player.vit = p.vit; player.int = p.int;
            player.statPoints = p.statPoints || 0;
            player.skillPoints = p.skillPoints || 0;
            player.classKey = p.classKey;
            player.className = p.className;
            player.skillLevels = p.skillLevels || {};
            for (const [slot, item] of Object.entries(p.equipment)) {
                player.equipment[slot] = item;
            }
            player.inventory = p.inventory || [];
            if (p.skills) {
                for (let i = 1; i <= 6; i++) {
                    if (p.skills[i]) {
                        player.skills[i] = { ...p.skills[i], cooldown: 0, maxCD: p.skills[i].maxCD || 0 };
                    }
                }
            }
            player.recalcStats();
            player.hp = Math.min(p.hp, player.maxHP);
            player.mp = Math.min(p.mp, player.maxMP);
            DOM.titleScreen.style.display = 'none';
            DOM.deathScreen.style.display = 'none';
            initFloor();
            player.x = p.x; player.y = p.y;
            if (!canWalk(player.x, player.y, 10)) {
                for (const room of dungeon.rooms) {
                    const rx = room.x * TILE + room.w * TILE / 2;
                    const ry = room.y * TILE + room.h * TILE / 2;
                    if (canWalk(rx, ry, 10)) { player.x = rx; player.y = ry; break; }
                }
            }
            G.camX = player.x - W / 2;
            G.camY = player.y - H / 2;
            addLog(`ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼B${G.floor}F Lv.${player.level}`, '#00ff88');
            addFloatingText(player.x, player.y - 30, 'LOADED!', '#00ff88');
            emitParticles(player.x, player.y, '#00ff88', 20, 60, 0.5, 4, -40);
            playSound(400, 'sine', 0.12, 0.06);
            const savedDate = new Date(save.timestamp);
            addLog(`ã‚»ãƒ¼ãƒ–æ—¥æ™‚: ${savedDate.toLocaleString('ja-JP')}`, '#888');
            return true;
        } catch (e) {
            addLog('ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—: ' + e.message, '#ff4444');
            console.error('Load error:', e);
            return false;
        }
    }

    function hasSaveData() {
        try { return !!localStorage.getItem('diablo_save'); } catch (e) { return false; }
    }

    // ========== MAIN GAME LOOP ==========
    let lastTime = 0;
    let fps = 0;
    let fpsAcc = 0;
    let fpsFrames = 0;
    function gameLoop(timestamp) {
        requestAnimationFrame(gameLoop);
        const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
        lastTime = timestamp;
        if (!G.started || G.dead) return;

        fpsAcc += dt;
        fpsFrames++;
        if (fpsAcc >= 0.5) { fps = fpsFrames / fpsAcc; fpsAcc = 0; fpsFrames = 0; }

        const canUpdate = !G.paused;
        if (canUpdate) {
            G.time += dt;
            sfxAmbient();
            if (G.hintTimer > 0) G.hintTimer -= dt;
            if (G.dmgFlashT > 0) G.dmgFlashT -= dt;
            updateAmbientParticles(dt);
            updateBloodPools(dt);
        }

        // Update
        if (canUpdate) {
            player.update(dt);
            for (const m of monsters) m.update(dt, player);
        }

        // Remove dead monsters after animation
        if (canUpdate) {
            for (let i = monsters.length - 1; i >= 0; i--) {
                if (!monsters[i].alive && monsters[i].deathT <= 0) monsters.splice(i, 1);
            }
        }

        // Projectiles
        if (canUpdate) for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.update(dt);
            if (p.life <= 0) { projectiles.splice(i, 1); continue; }

                // Frozen Orb shard emission
                if (p.frozen_orb) {
                    p.shardTimer = (p.shardTimer || 0) + dt;
                    if (p.shardTimer >= 0.15) {
                        p.shardTimer = 0;
                        const numShards = p.shardCount || 6;
                        for (let si = 0; si < numShards; si++) {
                            const sa = (Math.PI * 2 / numShards) * si + G.time * 3;
                            const sx = p.x + Math.cos(sa) * 15;
                            const sy = p.y + Math.sin(sa) * 15;
                            const tx = p.x + Math.cos(sa) * 200;
                            const ty = p.y + Math.sin(sa) * 200;
                            const shard = new Projectile(sx, sy, tx, ty, p.shardDmg || 10, '#aaddff', 300, 4);
                            shard.life = 0.4;
                            projectiles.push(shard);
                        }
                    }
                }

            // Check monster collision
            for (const m of monsters) {
                if (m.alive && dist(p.x, p.y, m.x, m.y) < p.r + m.r) {
                    const isCrit = Math.random() * 100 < player.getCritChance();
                    const d = isCrit ? p.dmg * 2 : p.dmg;
                    monsterTakeDmg(m, d, isCrit);
                    emitParticles(p.x, p.y, '#ffaa00', 10, 80, 0.4, 3, 0);
                    projectiles.splice(i, 1);
                    break;
                }
            }
        }

        // Traps
        if (canUpdate && G.traps) {
            for (let i = G.traps.length - 1; i >= 0; i--) {
                const tr = G.traps[i];
                tr.life -= dt;
                if (tr.life <= 0) { G.traps.splice(i, 1); continue; }
                if (!tr.triggered) {
                    for (const m of monsters) {
                        if (m.alive && dist(tr.x, tr.y, m.x, m.y) < tr.r) {
                            tr.triggered = true;
                            monsterTakeDmg(m, tr.dmg, false);
                            emitParticles(tr.x, tr.y, '#ff6600', 20, 100, 0.5, 4, 50);
                            playNoise(0.15, 0.1, 2000);
                            G.shakeT = 0.1; G.shakeAmt = 3;
                            addLog('ãƒˆãƒ©ãƒƒãƒ—ç™ºå‹•ï¼', '#ff6600');
                            G.traps.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }

        // Particles
        if (canUpdate) for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update(dt);
            if (!particles[i].alive()) particles.splice(i, 1);
        }

        // Floating texts
        if (canUpdate) for (let i = floatingTexts.length - 1; i >= 0; i--) {
            floatingTexts[i].life -= dt;
            if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
        }

                // Update summoned minions
        if (canUpdate && G.minions) {
            for (let mi = G.minions.length - 1; mi >= 0; mi--) {
                const mn = G.minions[mi];
                mn.life -= dt;
                if (mn.life <= 0 || mn.hp <= 0) {
                    emitParticles(mn.x, mn.y, '#88ddff', 10, 50, 0.3, 2, -20);
                    G.minions.splice(mi, 1); continue;
                }
                let nearM = null, nearD = 200;
                for (const m of monsters) {
                    if (!m.alive) continue;
                    const d = dist(mn.x, mn.y, m.x, m.y);
                    if (d < nearD) { nearD = d; nearM = m; }
                }
                if (nearM) {
                    const a = Math.atan2(nearM.y - mn.y, nearM.x - mn.x);
                    mn.x += Math.cos(a) * 140 * dt;
                    mn.y += Math.sin(a) * 140 * dt;
                    mn.attackCD -= dt;
                    if (nearD < 50 && mn.attackCD <= 0) {
                        mn.attackCD = 0.8;
                        monsterTakeDmg(nearM, mn.dmg, Math.random() < 0.1);
                        emitParticles(nearM.x, nearM.y, '#88ddff', 5, 30, 0.2, 2, 0);
                    }
                } else {
                    const pd = dist(mn.x, mn.y, player.x, player.y);
                    if (pd > 80) {
                        const a = Math.atan2(player.y - mn.y, player.x - mn.x);
                        mn.x += Math.cos(a) * 120 * dt;
                        mn.y += Math.sin(a) * 120 * dt;
                    }
                }
            }
        }

// Auto pickup
        if (canUpdate && G.autoPickup) {
            const rarityOrder = ['normal','magic','rare','legendary','unique'];
            const minRarity = rarityOrder.indexOf(G.autoPickupRarity);
            for (const gi of groundItems) {
                if (dist(player.x, player.y, gi.x, gi.y) < 60) {
                    if (gi.item.typeKey === 'potion') { player.pickupNearby(); break; }
                    const itemRarity = rarityOrder.indexOf(gi.item.rarityKey || 'normal');
                    if (itemRarity >= minRarity) { player.pickupNearby(); break; }
                }
            }
        } else if (canUpdate) {
            for (const gi of groundItems) {
                if (gi.item.typeKey === 'potion' && dist(player.x, player.y, gi.x, gi.y) < 40) {
                    player.pickupNearby(); break;
                }
            }
        }

        // Chest check - open chests when walked over
        const ptx = Math.floor(player.x / TILE), pty = Math.floor(player.y / TILE);
        if (canUpdate && dungeon.get(ptx, pty) === 3) {
            dungeon.set(ptx, pty, 1);
            sfxChestOpen();
            const numItems = rand(1, 3);
            for (let ci = 0; ci < numItems; ci++) {
                dropItem(player.x, player.y, generateItem(G.floor));
            }
            if (Math.random() < 0.5) dropItem(player.x, player.y, generatePotion());
            addLog('å®ç®±ã‚’é–‹ã‘ãŸï¼', '#ffd700');
            emitParticles(player.x, player.y, '#ffd700', 15, 60, 0.5, 3, -40);
        }

        // Stairs check
        const sd = dist(player.x, player.y, dungeon.stairsX * TILE + TILE/2, dungeon.stairsY * TILE + TILE/2);
        if (canUpdate && sd < 35 && monsters.filter(m => m.alive).length === 0) {
            sfxStairs();
            G.floor++;
            initFloor();
        }

        // Level up notice
        if (canUpdate && levelUpTimer > 0) {
            levelUpTimer -= dt;
            if (levelUpTimer <= 0) DOM.levelUpNotice.style.display = 'none';
        }

        // Camera
        if (canUpdate) {
            G.camX = lerp(G.camX, player.x - W / 2, 0.1);
            G.camY = lerp(G.camY, player.y - H / 2, 0.1);
        }

        // Screen shake
        let shakeX = 0, shakeY = 0;
        if (G.shakeT > 0) {
            G.shakeT -= dt;
            if (SETTINGS.screenShake) {
                shakeX = randf(-G.shakeAmt, G.shakeAmt);
                shakeY = randf(-G.shakeAmt, G.shakeAmt);
            }
        }

        // ===== RENDER =====
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#05050a';
        ctx.fillRect(0, 0, W, H);

        ctx.save();
        ctx.translate(shakeX, shakeY);

        dungeon.draw(G.camX, G.camY);

        // Blood pools (under everything else)
        drawBloodPools(G.camX, G.camY);

        // Ambient particles (dust/embers in the air)
        for (const ap of ambientParticles) ap.draw(G.camX, G.camY);

        // Meteor warning circle
        if (player.meteorT > 0 && G.meteorX) {
            const mx = G.meteorX - G.camX, my = G.meteorY - G.camY;
            const pulse = 0.3 + Math.sin(G.time * 12) * 0.2;
            ctx.strokeStyle = `rgba(255,80,0,${pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(mx, my, 100, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = `rgba(255,60,0,${pulse * 0.15})`;
            ctx.beginPath();
            ctx.arc(mx, my, 100, 0, Math.PI * 2);
            ctx.fill();
            // Inner shrinking circle
            const shrink = player.meteorT / 0.8;
            ctx.strokeStyle = `rgba(255,200,0,${pulse})`;
            ctx.beginPath();
            ctx.arc(mx, my, 100 * shrink, 0, Math.PI * 2);
            ctx.stroke();
        }

        drawGroundItems();
        // Draw traps
        if (G.traps) {
            for (const tr of G.traps) {
                const tx = tr.x - G.camX, ty = tr.y - G.camY;
                const pulse = 0.4 + Math.sin(G.time * 5) * 0.15;
                ctx.strokeStyle = `rgba(255,100,0,${pulse})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(tx, ty, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = `rgba(255,80,0,${pulse * 0.3})`;
                ctx.beginPath();
                ctx.arc(tx, ty, 6, 0, Math.PI * 2);
                ctx.fill();
                // Spikes
                for (let a = 0; a < 6; a++) {
                    const angle = a * Math.PI / 3 + G.time;
                    ctx.fillStyle = `rgba(200,100,0,${pulse * 0.5})`;
                    ctx.fillRect(tx + Math.cos(angle) * 6 - 1, ty + Math.sin(angle) * 6 - 1, 2, 2);
                }
            }
        }
        for (const p of projectiles) p.draw(G.camX, G.camY);
        for (const m of monsters) m.draw(G.camX, G.camY);
        // Draw summoned minions
        if (G.minions) {
            for (const mn of G.minions) {
                const mx = mn.x - G.camX, my = mn.y - G.camY;
                const pulse = 0.5 + Math.sin(G.time * 4) * 0.2;
                ctx.globalAlpha = 0.7 + pulse * 0.3;
                ctx.fillStyle = '#88ccff';
                ctx.beginPath(); ctx.arc(mx, my - 4, 10, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = pulse * 0.3;
                ctx.fillStyle = '#aaddff';
                ctx.beginPath(); ctx.arc(mx, my - 4, 16, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
                const hpPct = mn.hp / mn.maxHP;
                ctx.fillStyle = '#333'; ctx.fillRect(mx - 12, my - 18, 24, 3);
                ctx.fillStyle = hpPct > 0.5 ? '#00cc00' : '#cc6600';
                ctx.fillRect(mx - 12, my - 18, 24 * hpPct, 3);
            }
        }
        player.draw(G.camX, G.camY);
        for (const p of particles) p.draw(G.camX, G.camY);
        drawFloatingTexts();
        drawLighting();

        // Film grain overlay (lightweight pre-rendered noise)
        if (SETTINGS.filmGrain && TILE_TEXTURES['grain']) {
            ctx.globalAlpha = 0.15;
            ctx.globalCompositeOperation = 'overlay';
            const gx = (Math.random() * 256) | 0;
            const gy = (Math.random() * 256) | 0;
            const gc = TILE_TEXTURES['grain'];
            for (let py = -gy; py < H; py += 256) {
                for (let px = -gx; px < W; px += 256) {
                    ctx.drawImage(gc, px, py);
                }
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
        }

        ctx.restore();

        drawHUD();
        drawLog();

        // Update UI panels if open
        if (isPanelVisible(DOM.statsPanel)) updateStatsPanel();
        if (isPanelVisible(DOM.inventoryPanel)) updateInventoryPanel();
    }

    // Handle resize
    window.addEventListener('resize', () => {
        resizeCanvas();
    });

    document.addEventListener('visibilitychange', () => {
        if (document.hidden && G.started && !G.dead) setPaused(true);
    });

    // Tooltip on hover (ground items + skill bar)
    canvas.addEventListener('mousemove', e => {
        if (!G.started || G.paused || isPanelVisible(DOM.settingsPanel) || skillSelectOpen) { DOM.tooltip.style.display = 'none'; return; }
        const wx = e.clientX + G.camX, wy = e.clientY + G.camY;
        const tt = DOM.tooltip;
        let found = false;

        // Check skill bar hover
        const numSk = 6;
        const skW = 48, skGap = 5;
        const skTotalW = numSk * skW + (numSk - 1) * skGap;
        const skStartX = W / 2 - skTotalW / 2;
        const skY = H - 62;
        for (let i = 1; i <= numSk; i++) {
            const sx = skStartX + (i - 1) * (skW + skGap);
            if (e.clientX >= sx && e.clientX <= sx + skW && e.clientY >= skY && e.clientY <= skY + 48) {
                const sk = player.skills[i];
                tt.innerHTML = `<div class="tt-name" style="color:#ffd700">${sk.icon} ${sk.name}</div>
                    <div class="tt-type">ã‚­ãƒ¼: ${i} | MP: ${sk.mp}</div>
                    <div style="color:#ccc;margin-top:4px;font-size:11px">${sk.desc}</div>
                    <div style="color:#888;margin-top:4px;font-size:10px">CD: ${sk.maxCD}ç§’</div>`;
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 10) + 'px';
                tt.style.top = (skY - 90) + 'px';
                found = true;
                break;
            }
        }

        // Check ground items
        if (!found) {
        for (const gi of groundItems) {
            if (dist(wx, wy, gi.x, gi.y) < 25) {
                tt.innerHTML = buildTooltipHTML(gi.item);
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 15) + 'px';
                tt.style.top = (e.clientY - 10) + 'px';
                found = true;
                break;
            }
        }
        if (!found && !e.target.closest('.ui-panel')) {
            tt.style.display = 'none';
        }
        } // close if(!found) for ground items
    });

    // ========== TEST RUNNER ==========
    function runTests() {
        const results = [];
        const assert = (name, cond) => results.push({ name, ok: !!cond });
        assert('clamp lower', clamp(-1, 0, 1) === 0);
        assert('clamp upper', clamp(2, 0, 1) === 1);
        assert('lerp midpoint', lerp(0, 10, 0.5) === 5);
        assert('pickRarity common', pickRarity(0.0) === 'common');
        assert('pickRarity magic boundary', pickRarity(0.5) === 'magic');
        assert('pickRarity rare boundary', pickRarity(0.78) === 'rare');
        assert('pickRarity legendary boundary', pickRarity(0.93) === 'legendary');
        assert('pickRarity unique boundary', pickRarity(0.99) === 'unique');
        assert('affix count common', getAffixCount(RARITY.common) === 0);

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.inset = '0';
        wrap.style.background = 'rgba(0,0,0,0.92)';
        wrap.style.color = '#e8d7b8';
        wrap.style.fontFamily = FONT_UI;
        wrap.style.padding = '24px';
        wrap.style.zIndex = '3000';
        wrap.innerHTML = `<div style="font-family:${FONT_TITLE};font-size:24px;margin-bottom:10px;letter-spacing:2px">TEST RESULTS</div>`;
        const list = document.createElement('div');
        for (const r of results) {
            const row = document.createElement('div');
            row.style.padding = '6px 0';
            row.textContent = `${r.ok ? 'PASS' : 'FAIL'} - ${r.name}`;
            row.style.color = r.ok ? '#40d97b' : '#d24b4b';
            list.appendChild(row);
        }
        wrap.appendChild(list);
        document.body.appendChild(wrap);
        return results.every(r => r.ok);
    }

    // Start the loop
    const TEST_MODE = new URLSearchParams(window.location.search).has('test');
    if (TEST_MODE) {
        runTests();
    } else {
        requestAnimationFrame(gameLoop);
    }
    </script>
</body>
</html>
