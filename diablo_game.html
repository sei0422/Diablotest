<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»’ç„”ã®è¿·å®® - Diablo Style Hack & Slash</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-0: #040201;
            --bg-1: #0d0603;
            --bg-2: #140a06;
            --panel-bg: rgba(18,10,5,0.95);
            --panel-bg-strong: rgba(12,6,2,0.98);
            --panel-border: #8b6b3d;
            --panel-border-soft: #5a4a3a;
            --accent: #e5b35a;
            --accent-strong: #ffd270;
            --accent-dim: #aa8855;
            --text: #e8d7b8;
            --muted: #9b8a6f;
            --danger: #d24b4b;
            --good: #40d97b;
            --ui-glow: rgba(229,179,90,0.35);
            --font-title: "Cinzel", "IM Fell English", "Garamond", serif;
            --font-ui: "Spectral", "Garamond", "Georgia", serif;
            --font-mono: "Fira Mono", "Consolas", monospace;
            --font-emoji: "Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Twemoji Mozilla", sans-serif;
        }
        body {
            font-family: var(--font-ui);
            background: radial-gradient(1200px 800px at 50% 20%, #1b0c08 0%, var(--bg-1) 45%, var(--bg-0) 100%);
            color: var(--text);
            overflow: hidden;
            user-select: none;
            cursor: default;
            position: relative;
        }
        body::before {
            content: "";
            position: fixed;
            inset: 0;
            background:
                radial-gradient(circle at 20% 20%, rgba(255,120,60,0.05), transparent 40%),
                radial-gradient(circle at 80% 30%, rgba(120,80,40,0.06), transparent 45%),
                repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0 2px, transparent 2px 6px);
            pointer-events: none;
            opacity: 0.45;
            z-index: 0;
        }
        canvas { display: block; position: relative; z-index: 1; }
        #titleScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background:
                linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.85)),
                url("asset/2D Pixel Dungeon Asset Pack/Dungeon_Tileset_at.png");
            background-size: cover;
            background-position: center;
            image-rendering: pixelated;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: pointer;
        }
        #titleScreen::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 50% 30%, rgba(255,120,60,0.08), transparent 55%);
            pointer-events: none;
        }
        #titleScreen h1 {
            font-size: 64px;
            color: #ff5a2a;
            text-shadow: 0 0 30px #ff4400, 0 0 60px #ff2200, 0 0 90px #7a0000;
            letter-spacing: 8px;
            margin-bottom: 20px;
            animation: flicker 3s infinite;
            font-family: var(--font-title);
        }
        #titleScreen h2 {
            font-size: 18px;
            color: var(--accent-dim);
            letter-spacing: 4px;
            margin-bottom: 60px;
        }
        #titleScreen .start-text {
            font-size: 22px;
            color: var(--accent);
            animation: pulse 2s infinite;
            letter-spacing: 6px;
        }
        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.9; }
            75% { opacity: 1; }
            80% { opacity: 0.85; }
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }
        .promo-card {
            position: relative;
            display: inline-block;
            width: 45%;
            margin: 8px 2%;
            padding: 15px;
            background: rgba(30,20,10,0.9); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            border: 2px solid var(--panel-border-soft);
            border-radius: 6px;
            text-align: center;
            cursor: pointer;
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.2s;
            vertical-align: top;
            isolation: isolate;
            text-shadow: 0 1px 4px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.7);
        }
        .promo-card::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            border-radius: inherit;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_2.png") repeat;
            background-size: 20px 20px;
            image-rendering: pixelated;
            opacity: 0.22;
            transition: filter 0.2s;
            pointer-events: none;
        }
        .promo-card:hover {
            border-color: var(--accent-strong);
            box-shadow: 0 0 20px var(--ui-glow);
            transform: translateY(-3px);
        }
        .promo-card:hover::before {
            filter: brightness(1.2);
        }
        .emoji-font { font-family: var(--font-emoji); }
        .skill-slot-pick {
            width: 48px; height: 48px;
            background: rgba(30,25,20,0.9);
            border: 2px solid var(--panel-border-soft);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        .skill-slot-pick.selected {
            border-color: var(--accent-strong);
            box-shadow: 0 0 10px var(--ui-glow);
        }
        .skill-slot-pick.swap-from {
            border-color: #66ccff;
            box-shadow: 0 0 10px rgba(102,204,255,0.7);
        }
        .skill-pick-item {
            width: 70px;
            padding: 6px 4px;
            background: rgba(40,30,20,0.9);
            border: 1px solid var(--panel-border-soft);
            border-radius: 4px;
            text-align: center;
            cursor: pointer;
        }
        .skill-pick-item:hover:not(.locked) {
            border-color: var(--accent-strong);
            background: rgba(60,40,20,0.9);
        }
        .skill-pick-item.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .close-btn {
            position: relative;
            background: rgba(101, 67, 33, 0.95); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯èƒŒæ™¯ */
            color: var(--accent-strong);
            border: 1px solid var(--panel-border);
            padding: 8px 20px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
            isolation: isolate;
            transition: border-color 0.2s, box-shadow 0.2s, transform 0.1s;
        }
        .close-btn::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            border-radius: inherit;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_2.png") repeat;
            background-size: 16px 16px;
            image-rendering: pixelated;
            opacity: 0.5;
            transition: filter 0.2s, opacity 0.2s;
            pointer-events: none;
        }
        .close-btn:hover {
            border-color: var(--accent-strong);
            box-shadow: 0 0 15px rgba(229, 179, 90, 0.4);
            transform: translateY(-1px);
        }
        .close-btn:hover::before {
            filter: brightness(1.25);
            opacity: 0.6;
        }
        .close-btn:active {
            transform: translateY(0);
        }
        .close-btn:active::before {
            filter: brightness(0.85);
        }
        .ui-panel {
            position: absolute;
            background: linear-gradient(180deg, var(--panel-bg), rgba(10,5,2,0.95)); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            border: 2px solid var(--panel-border);
            border-image: linear-gradient(180deg, var(--accent), #8b6914, #654321) 1;
            color: var(--accent);
            font-size: 13px;
            padding: 15px;
            display: none;
            z-index: 100;
            max-height: 85vh;
            overflow-y: auto;
            font-family: var(--font-mono);
            box-shadow: 0 0 20px rgba(0,0,0,0.8), inset 0 0 30px rgba(0,0,0,0.5);
            isolation: isolate;
            text-shadow: 0 1px 4px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.7);
        }
        .ui-panel::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_1.png") repeat;
            background-size: 32px 32px;
            image-rendering: pixelated;
            opacity: 0.10;
            pointer-events: none;
        }
        #statsPanel { top: 60px; left: 10px; width: 280px; }
        #inventoryPanel { top: 60px; right: 10px; width: 320px; }
        .panel-header {
            font-size: 16px;
            border-bottom: 1px solid var(--panel-border);
            margin-bottom: 10px;
            padding-bottom: 8px;
            text-align: center;
            color: var(--accent-strong);
            font-weight: bold;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(255,215,0,0.3);
            font-family: var(--font-title);
        }
        .stat-row {
            margin: 6px 0;
            display: flex;
            justify-content: space-between;
            padding: 2px 5px;
        }
        .stat-row:hover { background: rgba(139,115,85,0.2); }
        .stat-label { color: #aaa; }
        .stat-value { color: #ffd700; font-weight: bold; }
        .stat-btn {
            position: relative;
            background: rgba(101, 67, 33, 0.9); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            color: #ffd700;
            border: 1px solid #8b7355;
            cursor: pointer;
            padding: 1px 8px;
            font-size: 12px;
            margin-left: 5px;
            isolation: isolate;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .stat-btn::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_2.png") repeat;
            background-size: 16px 16px;
            image-rendering: pixelated;
            opacity: 0.5;
            transition: filter 0.2s;
            pointer-events: none;
        }
        .stat-btn:hover {
            border-color: var(--accent-strong);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.4);
        }
        .stat-btn:hover::before {
            filter: brightness(1.25);
        }
        .equip-slots {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            margin: 10px 0;
        }
        .equip-slot {
            height: 50px;
            background: rgba(40,30,20,0.8);
            border: 1px solid #555;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            color: #888;
            cursor: pointer;
            position: relative;
        }
        .equip-slot:hover { border-color: #daa520; }
        .equip-slot.filled { border-color: #8b7355; }
        .equip-slot .slot-label { font-size: 8px; color: #555; margin-top: 2px; }
        .inv-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 3px;
            margin: 10px 0;
        }
        .inv-cell {
            height: 42px;
            background: rgba(40,30,20,0.6);
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            position: relative;
        }
        .inv-cell:hover { border-color: #daa520; background: rgba(80,60,30,0.5); }
        #tooltip {
            position: absolute;
            background: linear-gradient(180deg, rgba(20,10,5,0.98), rgba(5,2,0,0.98));
            border: 2px solid var(--panel-border);
            color: var(--accent);
            padding: 10px;
            font-size: 12px;
            display: none;
            z-index: 300;
            min-width: 180px;
            max-width: 240px;
            font-family: var(--font-mono);
            box-shadow: 0 0 15px rgba(0,0,0,0.9);
            pointer-events: none;
        }
        .tt-name { font-weight: bold; font-size: 14px; margin-bottom: 5px; }
        .tt-type { color: #888; font-size: 11px; margin-bottom: 6px; }
        .tt-affix { color: #4488ff; margin: 3px 0; font-size: 11px; }
        .tt-rarity { font-size: 10px; margin-top: 6px; font-style: italic; }
        .tt-equip { color: #00cc00; font-size: 10px; margin-top: 4px; }
        #logPanel {
            position: absolute;
            bottom: 90px;
            left: 10px;
            width: 350px;
            max-height: 150px;
            overflow: hidden;
            pointer-events: none;
            z-index: 50;
        }
        .log-msg {
            font-size: 12px;
            padding: 2px 0;
            opacity: 0.9;
            text-shadow: 0 0 3px #000, 1px 1px 2px #000;
        }
        .log-msg.fade { opacity: 0.4; }
        #levelUpNotice {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #ffd700;
            text-shadow: 0 0 30px #ffd700, 0 0 60px #ff8c00;
            display: none;
            z-index: 200;
            letter-spacing: 4px;
            pointer-events: none;
        }
        #deathScreen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(80,0,0,0.7);
            display: none;
            z-index: 500;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }
        #deathScreen h1 { font-size: 72px; color: #ff0000; text-shadow: 0 0 30px #ff0000; margin-bottom: 20px; font-family: var(--font-title); }
        #deathScreen p { font-size: 20px; color: #cc8888; }
        #controls-help {
            display: none;
        }
        .class-card {
            position: relative;
            width: 260px;
            background: linear-gradient(180deg, rgba(30,20,10,0.95), rgba(15,10,5,0.95)); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            border: 2px solid #5a4a3a;
            padding: 20px;
            cursor: pointer;
            text-align: center;
            transition: border-color 0.3s, box-shadow 0.3s, transform 0.3s;
            isolation: isolate;
            text-shadow: 0 1px 4px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.7);
        }
        .class-card::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_2.png") repeat;
            background-size: 24px 24px;
            image-rendering: pixelated;
            opacity: 0.2;
            transition: filter 0.3s, opacity 0.3s;
            pointer-events: none;
        }
        .class-card:hover {
            border-color: #daa520;
            transform: translateY(-5px);
            box-shadow: 0 5px 25px rgba(218,165,32,0.3);
        }
        .class-card:hover::before {
            filter: brightness(1.3);
            opacity: 0.4;
        }
        .class-icon { font-size: 48px; margin-bottom: 10px; font-family: var(--font-emoji); }
        .class-name { font-size: 24px; color: #daa520; font-weight: bold; letter-spacing: 4px; font-family: var(--font-title); }
        .class-eng { font-size: 11px; color: #886633; letter-spacing: 3px; margin-bottom: 12px; }
        .class-desc { font-size: 12px; color: #999; line-height: 1.6; margin-bottom: 12px; min-height: 60px; }
        .class-stats { font-size: 11px; color: #aa8844; letter-spacing: 1px; }
        #skillTreePanel {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 650px;
            max-height: 85vh;
            overflow-y: auto;
            background: linear-gradient(180deg, rgba(20,10,5,0.97), rgba(10,5,2,0.97)); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            border: 2px solid #8b7355;
            border-image: linear-gradient(180deg, #daa520, #8b6914, #654321) 1;
            color: #daa520;
            font-size: 13px;
            padding: 20px;
            display: none;
            z-index: 150;
            box-shadow: 0 0 30px rgba(0,0,0,0.9), inset 0 0 30px rgba(0,0,0,0.5);
            isolation: isolate;
            text-shadow: 0 1px 4px rgba(0,0,0,0.9), 0 0 8px rgba(0,0,0,0.7);
        }
        #skillTreePanel::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_1.png") repeat;
            background-size: 32px 32px;
            image-rendering: pixelated;
            opacity: 0.12;
            pointer-events: none;
        }
        .skill-branch { margin-bottom: 15px; }
        .skill-branch-title { color: #ffd700; font-size: 14px; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #5a4a3a; padding-bottom: 4px; }
        .skill-node {
            display: inline-block;
            width: 180px;
            background: rgba(30,20,10,0.8);
            border: 1px solid #5a4a3a;
            padding: 8px;
            margin: 4px;
            cursor: pointer;
            vertical-align: top;
            transition: border-color 0.2s;
        }
        .skill-node:hover { border-color: #daa520; }
        .skill-node.unlocked { border-color: #8b7355; }
        .skill-node.maxed { border-color: #ffd700; }
        .skill-node.locked { opacity: 0.5; cursor: default; }
        .skill-node .sn-icon { font-size: 20px; }
        .skill-node .sn-name { color: #daa520; font-size: 12px; font-weight: bold; }
        .skill-node .sn-level { color: #888; font-size: 10px; }
        .skill-node .sn-desc { color: #777; font-size: 10px; margin-top: 4px; }
        .skill-node .sn-btn {
            position: relative;
            background: rgba(74, 50, 16, 0.9); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            color: #daa520;
            border: 1px solid #8b7355;
            padding: 2px 8px;
            font-size: 10px;
            cursor: pointer;
            margin-top: 4px;
            isolation: isolate;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .skill-node .sn-btn::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_2.png") repeat;
            background-size: 16px 16px;
            image-rendering: pixelated;
            opacity: 0.5;
            transition: filter 0.2s;
            pointer-events: none;
        }
        .skill-node .sn-btn:hover {
            border-color: #daa520;
            box-shadow: 0 0 8px rgba(218, 165, 32, 0.4);
        }
        .skill-node .sn-btn:hover::before {
            filter: brightness(1.25);
        }
        #pauseOverlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.65);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1400;
            text-align: center;
            backdrop-filter: blur(2px);
        }
        #pauseOverlay .pause-card {
            background: linear-gradient(180deg, rgba(25,12,6,0.98), rgba(12,6,2,0.98));
            border: 2px solid var(--panel-border);
            padding: 30px 40px;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            min-width: 320px;
        }
        #pauseOverlay .pause-title {
            font-family: var(--font-title);
            font-size: 32px;
            letter-spacing: 6px;
            color: var(--accent-strong);
            margin-bottom: 8px;
        }
        #pauseOverlay .pause-sub {
            font-size: 12px;
            color: var(--muted);
            letter-spacing: 2px;
        }
        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 4px;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            gap: 10px;
        }
        .setting-row:last-child { border-bottom: none; }
        .setting-label { color: var(--text); font-size: 12px; }
        .setting-actions { display: flex; gap: 6px; align-items: center; }
        .toggle-btn {
            position: relative;
            background: rgba(58, 39, 22, 0.9); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            color: var(--accent-strong);
            border: 1px solid var(--panel-border);
            padding: 4px 10px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
            isolation: isolate;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .toggle-btn::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            border-radius: inherit;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_2.png") repeat;
            background-size: 16px 16px;
            image-rendering: pixelated;
            opacity: 0.5;
            transition: filter 0.2s, opacity 0.2s;
            pointer-events: none;
        }
        .toggle-btn:hover {
            border-color: var(--accent-strong);
            box-shadow: 0 0 10px rgba(229, 179, 90, 0.3);
        }
        .toggle-btn:hover::before {
            filter: brightness(1.2);
        }
        .toggle-btn.off {
            color: #b68a5d;
            opacity: 0.8;
        }
        .toggle-btn.off::before {
            opacity: 0.3; /* ã‚ªãƒ•æ™‚ã¯ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’è–„ã */
        }
        #titleSaveMenu {
            margin-top: 20px;
            padding: 12px 16px;
            border: 1px solid #5a4a3a;
            border-radius: 6px;
            background: linear-gradient(180deg, rgba(25,15,6,0.8), rgba(12,6,2,0.8));
            box-shadow: 0 0 20px rgba(0,0,0,0.35);
        }
        .title-save-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            padding: 6px 0;
            border-bottom: 1px solid rgba(90,74,58,0.4);
        }
        .title-save-row:last-child { border-bottom: none; }
        .title-save-info {
            font-size: 11px;
            color: #b08a60;
        }
        .title-save-actions {
            display: flex;
            gap: 6px;
        }
        #promotionOverlay,
        #skillSelectOverlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.85); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            z-index: 2000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(4px);
        }
        #skillSelectOverlay {
            z-index: 1500;
            background: rgba(0, 0, 0, 0.8);
        }
        #promotionOverlay::before,
        #skillSelectOverlay::before {
            content: "";
            position: fixed;
            inset: 0;
            z-index: -1;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_3.png") repeat;
            background-size: 48px 48px;
            image-rendering: pixelated;
            opacity: 0.08;
            pointer-events: none;
        }
        #promotionContent,
        #skillSelectContent {
            position: relative;
            background: linear-gradient(180deg, rgba(30,15,5,0.98), rgba(15,8,2,0.98)); /* ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ */
            border: 2px solid #daa520;
            padding: 25px;
            max-width: 600px;
            width: 90%;
            border-radius: 6px;
            box-shadow: 0 0 40px rgba(218,165,32,0.3);
            isolation: isolate;
        }
        #skillSelectContent {
            background: linear-gradient(180deg, rgba(20,12,5,0.98), rgba(10,6,2,0.98));
            border-color: #8b7355;
            padding: 20px;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(0,0,0,0.5);
            max-height: 80vh;
            overflow-y: auto;
        }
        #promotionContent::before,
        #skillSelectContent::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: -1;
            border-radius: inherit;
            background: url("asset/2D Pixel Dungeon Asset Pack/interface/square_up_down_1.png") repeat;
            background-size: 32px 32px;
            image-rendering: pixelated;
            opacity: 0.15;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="titleScreen">
        <h1>é»’ç„”ã®è¿·å®®</h1>
        <h2>DUNGEON OF BLACK FLAME</h2>
        <div id="classSelect" style="display:none;width:100%;max-width:900px;margin:0 auto">
            <div style="text-align:center;color:#daa520;font-size:16px;margin-bottom:20px;letter-spacing:3px">â”€ â† â†’ ã§ã‚¯ãƒ©ã‚¹ã‚’é¸æŠã€€Enter ã§æ±ºå®š â”€</div>
            <div style="display:flex;gap:20px;justify-content:center">
                <div class="class-card" onclick="selectClass('warrior')">
                    <div class="class-icon">âš”</div>
                    <div class="class-name">æˆ¦å£«</div>
                    <div class="class-eng">WARRIOR</div>
                    <div class="class-desc">è¿‘æ¥æˆ¦é—˜ã®é”äººã€‚é«˜ã„ä½“åŠ›ã¨ç­‹åŠ›ã§æ•µã‚’ãªãå€’ã™ã€‚é‡è£…å‚™ã‚’å¾—æ„ã¨ã—ã€å‰ç·šã§æˆ¦ã†ã€‚</div>
                    <div class="class-stats">STR â˜…â˜…â˜… DEX â˜…â˜†â˜† VIT â˜…â˜…â˜… INT â˜…â˜†â˜†</div>
                </div>
                <div class="class-card" onclick="selectClass('rogue')">
                    <div class="class-icon">ğŸ¹</div>
                    <div class="class-name">ç›—è³Š</div>
                    <div class="class-eng">ROGUE</div>
                    <div class="class-desc">ç´ æ—©ã•ã¨ç²¾å¯†ãªå°„æ’ƒã§æˆ¦ã†ã€‚ç½ ã‚’ä»•æ›ã‘ã€æ•µã®å¼±ç‚¹ã‚’çªãã€‚å›é¿ã«å„ªã‚Œã‚‹ã€‚</div>
                    <div class="class-stats">STR â˜…â˜†â˜† DEX â˜…â˜…â˜… VIT â˜…â˜…â˜† INT â˜…â˜…â˜†</div>
                </div>
                <div class="class-card" onclick="selectClass('sorcerer')">
                    <div class="class-icon">ğŸ”®</div>
                    <div class="class-name">é­”æ³•ä½¿ã„</div>
                    <div class="class-eng">SORCERER</div>
                    <div class="class-desc">å¼·åŠ›ãªé­”æ³•ã‚’æ“ã‚‹ã€‚ç‚ã€é›·ã€æ°·ã®é­”æ³•ã§é è·é›¢ã‹ã‚‰æ®²æ»…ã™ã‚‹ã€‚MPãŒè±Šå¯Œã€‚</div>
                    <div class="class-stats">STR â˜…â˜†â˜† DEX â˜…â˜†â˜† VIT â˜…â˜†â˜† INT â˜…â˜…â˜…</div>
                </div>
            </div>
        </div>
        <div id="titleStartText" class="start-text" style="margin-top:30px">â€• Enter / ã‚¯ãƒªãƒƒã‚¯ã§é¸æŠã‚¹ãƒ­ãƒƒãƒˆé–‹å§‹ â€•</div>
        <div id="titleSaveMenu">
            <div style="text-align:center;color:#ddb27a;font-size:12px;margin-bottom:6px;letter-spacing:2px">ã‚»ãƒ¼ãƒ–ã‚¹ãƒ­ãƒƒãƒˆ</div>
            <div id="titleSaveContent"></div>
        </div>
    </div>

    <!-- Promotion Overlay -->
    <div id="promotionOverlay">
        <div id="promotionContent"></div>
    </div>

    <!-- Skill Select Overlay -->
    <div id="skillSelectOverlay">
        <div id="skillSelectContent"></div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="statsPanel" class="ui-panel">
        <div class="panel-header">âš” ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼</div>
        <div id="statsContent"></div>
    </div>
    <div id="inventoryPanel" class="ui-panel">
        <div class="panel-header">ğŸ’ ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª</div>
        <div id="inventoryContent"></div>
    </div>
    <div id="tooltip"></div>
    <div id="logPanel"></div>
    <div id="levelUpNotice">LEVEL UP!</div>
    <div id="deathScreen">
        <h1>YOU DIED</h1>
        <p>Enter / ã‚¯ãƒªãƒƒã‚¯ã§å¾©æ´»...</p>
    </div>
    <div id="controls-help">
        å·¦ã‚¯ãƒªãƒƒã‚¯:ç§»å‹•/æ”»æ’ƒ | å³ã‚¯ãƒªãƒƒã‚¯:ã‚¹ã‚­ãƒ« | 1~6:ã‚¹ã‚­ãƒ«é¸æŠ | R:ã‚¹ã‚­ãƒ«ç·¨é›† | E:éšæ®µ | I:ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª | C:ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ | Space:ã‚¢ã‚¤ãƒ†ãƒ æ‹¾ã†
    </div>
    <button id="skillEditBtn" class="toggle-btn" tabindex="-1" style="position:fixed;left:50%;bottom:96px;transform:translateX(-50%);z-index:300;opacity:0.9">
        ã‚¹ã‚­ãƒ«ç·¨é›† (R)
    </button>

    <div id="helpOverlay" class="ui-panel" style="top:50%;left:50%;transform:translate(-50%,-50%);width:500px;max-height:80vh;display:none">
        <div class="panel-header">ğŸ“– æ“ä½œã‚¬ã‚¤ãƒ‰ (H ã§é–‰ã˜ã‚‹)</div>
        <div style="line-height:2;font-size:13px">
            <div style="color:#daa520;font-weight:bold;margin:8px 0 4px">åŸºæœ¬æ“ä½œ</div>
            <div><span style="color:#ffd700">å·¦ã‚¯ãƒªãƒƒã‚¯</span> â”€ ç§»å‹• / æ•µã‚’æ”»æ’ƒ</div>
            <div><span style="color:#ffd700">å³ã‚¯ãƒªãƒƒã‚¯</span> â”€ é¸æŠä¸­ã®ã‚¹ã‚­ãƒ«ã‚’ç™ºå‹•</div>
            <div><span style="color:#ffd700">Spaceã‚­ãƒ¼</span> â”€ è¿‘ãã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‹¾ã†</div>
            <div style="color:#daa520;font-weight:bold;margin:12px 0 4px">ãƒ¡ãƒ‹ãƒ¥ãƒ¼</div>
            <div><span style="color:#ffd700">Iã‚­ãƒ¼</span> â”€ ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªé–‹é–‰</div>
            <div><span style="color:#ffd700">Cã‚­ãƒ¼</span> â”€ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç”»é¢é–‹é–‰</div>
            <div><span style="color:#ffd700">Hã‚­ãƒ¼</span> â”€ ã“ã®ãƒ˜ãƒ«ãƒ—ç”»é¢ã®é–‹é–‰</div>
            <div><span style="color:#ffd700">Oã‚­ãƒ¼</span> â”€ è¨­å®šç”»é¢ã®é–‹é–‰</div>
            <div><span style="color:#ffd700">Rã‚­ãƒ¼</span> â”€ ã‚¹ã‚­ãƒ«ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆç·¨é›†</div>
            <div><span style="color:#ffd700">Eã‚­ãƒ¼</span> â”€ éšæ®µã‚’é™ã‚Šã‚‹</div>
            <div><span style="color:#ffd700">Esc</span> â”€ ä¸€æ™‚åœæ­¢</div>
            <div style="color:#daa520;font-weight:bold;margin:12px 0 4px">ã‚¹ã‚­ãƒ« (1~6ã‚­ãƒ¼ã§ç™ºå‹•)</div>
            <div id="helpSkillSlots" style="color:#ccc;font-size:12px">ã‚¹ã‚­ãƒ«ã‚¹ãƒ­ãƒƒãƒˆæƒ…å ±ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
            <div style="color:#daa520;font-weight:bold;margin:12px 0 4px">ãƒ’ãƒ³ãƒˆ</div>
            <div style="color:#999;font-size:12px">ãƒ»æ•µã‚’å…¨æ»…ã•ã›ã‚‹ã¨éšæ®µãŒä½¿ãˆã‚‹</div>
            <div style="color:#999;font-size:12px">ãƒ»æ·±ã„éšå±¤ã»ã©å¼·æ•µã¨è‰¯ã„ã‚¢ã‚¤ãƒ†ãƒ ãŒå‡ºç¾</div>
            <div style="color:#999;font-size:12px">ãƒ»è£…å‚™ã®ãƒ¬ã‚¢ãƒªãƒ†ã‚£: <span style="color:#ccc">ã‚³ãƒ¢ãƒ³</span> < <span style="color:#68f">ãƒã‚¸ãƒƒã‚¯</span> < <span style="color:#fd4">ãƒ¬ã‚¢</span> < <span style="color:#f80">ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼</span> < <span style="color:#0d6">ãƒ¦ãƒ‹ãƒ¼ã‚¯</span></div>
            <div id="helpDynamic"></div>
        </div>
    </div>

    <div id="settingsPanel" class="ui-panel" style="top:50%;left:50%;transform:translate(-50%,-50%);width:420px;max-height:80vh;display:none">
        <div class="panel-header">âš™ è¨­å®š (O ã§é–‰ã˜ã‚‹)</div>
        <div id="settingsContent"></div>
    </div>

    <div id="pauseOverlay">
        <div class="pause-card">
            <div class="pause-title">PAUSED</div>
            <div class="pause-sub">Esc ã§å†é–‹ | O ã§è¨­å®š</div>
        </div>
    </div>

    <div id="skillTreePanel">
        <div class="panel-header">ğŸŒ³ ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ (T ã§é–‰ã˜ã‚‹)</div>
        <div id="skillTreeContent"></div>
    </div>

    <script>
    // ========================================
    // é»’ç„”ã®è¿·å®® - Diablo Style Hack & Slash
    // ========================================
    'use strict';

    // --- Audio System (Web Audio API with Dungeon Reverb) ---
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx, reverbNode, masterGain, reverbSend, dryGain;
    let bgmNodes = null;

    // --- Sprite Sheet Loading ---
    const SPRITES = {};
    let spritesLoaded = false;
    function loadSprites() {
        const sheets = {
            tiles: 'asset/32rogues/tiles.png',
            monsters: 'asset/32rogues/monsters.png',
            rogues: 'asset/32rogues/rogues.png',
            items: 'asset/32rogues/items.png',
            animTiles: 'asset/32rogues/animated-tiles.png'
        };
        let loaded = 0;
        const total = Object.keys(sheets).length;
        function onAllLoaded() {
            spritesLoaded = true;
            console.log('All sprites loaded:', Object.keys(SPRITES).join(', '));
            try {
                if (typeof generateTileTextures === 'function') {
                    generateTileTextures();
                    tileTexturesReady = true;
                    console.log('Tile textures regenerated with sprites');
                }
            } catch(e) { console.warn('Sprite texture override deferred:', e); }
        }
        function loadOne(key, src, retries) {
            const img = new Image();
            img.onload = () => {
                // Use original sprite without pixel processing
                SPRITES[key] = img;
                console.log('Sprite loaded:', key, img.width + 'x' + img.height);
                if (++loaded === total) onAllLoaded();
            };
            img.onerror = () => {
                if (retries > 0) {
                    console.warn('Sprite retry:', src, 'remaining:', retries);
                    setTimeout(() => loadOne(key, src, retries - 1), 500);
                } else {
                    console.warn('Sprite FAIL:', src);
                    if (++loaded === total) onAllLoaded();
                }
            };
            img.src = src + '?v=' + Date.now();
        }
        for (const [key, src] of Object.entries(sheets)) {
            loadOne(key, src, 3);
        }
    }
    loadSprites();

    const SP = 32; // sprite pixel size in sprite sheet
    const ATLAS = {
        // tiles.png (544x832, 32px grid)
        wallTop:['tiles',0,64], wallSide1:['tiles',32,64], wallSide2:['tiles',64,64],
        deepWall:['tiles',0,96], catWallSide:['tiles',32,160],
        floorBlank:['tiles',0,192], floor1:['tiles',32,192],
        floor2:['tiles',64,192], floor3:['tiles',96,192],
        stairsDown:['tiles',224,512], chestClosed:['tiles',0,544], chestOpen:['tiles',32,544],
        blood1:['tiles',0,704], blood2:['tiles',32,704],
        corpse1:['tiles',0,672], corpse2:['tiles',32,672],
        // monsters.png (384x416, 32px grid)
        skeleton:['monsters',0,128], skelArcher:['monsters',32,128],
        lich:['monsters',64,128], deathKnight:['monsters',96,128],
        zombie:['monsters',128,128], ghoul:['monsters',160,128],
        banshee:['monsters',0,160], wraith:['monsters',64,160],
        imp:['monsters',32,352], minotaur:['monsters',224,224],
        // rogues.png (224x224, 32px grid)
        knight:['rogues',0,32], fighter:['rogues',32,32],
        ranger:['rogues',64,0], rogueChar:['rogues',96,0],
        wizardF:['rogues',0,128], wizardM:['rogues',32,128],
        // items.png (352x832, 32px grid)
        iSword:['items',96,0], iAxe:['items',32,96], iStaff:['items',0,320],
        iShield:['items',32,352], iHelmet:['items',128,480], iArmor:['items',96,384],
        iRing:['items',0,544], iAmulet:['items',0,512], iBoots:['items',32,448],
        iPotion:['items',32,608], iGold:['items',0,768],
        // animated-tiles.png torch lit frames (row 5, y=160)
        torch0:['animTiles',0,160], torch1:['animTiles',32,160],
        torch2:['animTiles',64,160], torch3:['animTiles',96,160],
        torch4:['animTiles',128,160], torch5:['animTiles',160,160],
        // === Promoted class sprites (rogues.png) ===
        paladin:['rogues',128,32],    // shield knight
        berserker:['rogues',0,96],    // male barbarian
        assassin:['rogues',128,0],    // bandit
        rangerCls:['rogues',64,0],    // ranger
        pyromancer:['rogues',0,128],  // female wizard
        cryomancer:['rogues',64,128], // druid (ice-themed)
        monk:['rogues',0,64],         // monk
        templar:['rogues',128,64],    // templar
        warlock:['rogues',160,128],   // warlock (6th col row5)
        fencer:['rogues',128,96],     // fencer
        priest:['rogues',32,64],      // priest
    };

    function drawSpr(key, dx, dy, dw, dh, flipX) {
        const a = ATLAS[key];
        if (!a || !SPRITES[a[0]]) return false;
        const prevSmooth = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        // multiplyãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã‚’å‰Šé™¤ - æš—ã„èƒŒæ™¯ã§ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆãŒé€æ˜åŒ–ã™ã‚‹ãŸã‚
        if (flipX) {
            ctx.save(); ctx.translate(dx + dw, dy); ctx.scale(-1, 1);
            ctx.drawImage(SPRITES[a[0]], a[1], a[2], SP, SP, 0, 0, dw, dh);
            ctx.restore();
        } else {
            ctx.drawImage(SPRITES[a[0]], a[1], a[2], SP, SP, dx, dy, dw, dh);
        }
        ctx.imageSmoothingEnabled = prevSmooth;
        return true;
    }

    const ITEM_ICON_SPRITE = {
        '\u2694': 'iSword', '\ud83e\udea3': 'iAxe', '\ud83d\udd2e': 'iStaff',
        '\ud83d\udee1': 'iShield', '\u26d1': 'iHelmet', '\ud83e\uddba': 'iArmor',
        '\ud83d\udc8d': 'iRing', '\ud83d\udcbf': 'iAmulet', '\ud83d\udc62': 'iBoots',
        '\ud83e\uddea': 'iPotion'
    };


    function initAudio() {
        if (!SETTINGS.sound) return;
        if (!audioCtx) {
            audioCtx = new AudioCtx();
            // Master output chain
            masterGain = audioCtx.createGain();
            masterGain.gain.value = 1.0;
            masterGain.connect(audioCtx.destination);

            // Dry path
            dryGain = audioCtx.createGain();
            dryGain.gain.value = 0.75;
            dryGain.connect(masterGain);

            // Reverb (dungeon echo)
            reverbNode = audioCtx.createConvolver();
            const rate = audioCtx.sampleRate;
            const len = rate * 2.2; // 2.2s reverb tail - cathedral feel
            const impulse = audioCtx.createBuffer(2, len, rate);
            for (let ch = 0; ch < 2; ch++) {
                const d = impulse.getChannelData(ch);
                for (let i = 0; i < len; i++) {
                    // Exponential decay with some early reflections
                    const t = i / rate;
                    const decay = Math.pow(1 - i / len, 1.8);
                    const earlyRef = t < 0.05 ? 0.8 : (t < 0.12 ? 0.4 : 1);
                    d[i] = (Math.random() * 2 - 1) * decay * earlyRef;
                }
            }
            reverbNode.buffer = impulse;
            reverbSend = audioCtx.createGain();
            reverbSend.gain.value = 0.35; // Reverb wet amount
            reverbNode.connect(reverbSend);
            reverbSend.connect(masterGain);

            // Start background music
            startBGM();
        }
    }

    // Route audio node to both dry + reverb
    function routeToOutput(node) {
        if (dryGain) { node.connect(dryGain); node.connect(reverbNode); }
        else node.connect(audioCtx.destination);
    }

    // Background music - dark ambient drone
    function startBGM() {
        if (bgmNodes) return;
        const t = audioCtx.currentTime;
        const bgmGain = audioCtx.createGain();
        bgmGain.gain.value = 0.025;

        // Sub bass drone
        const sub = audioCtx.createOscillator();
        sub.type = 'sine';
        sub.frequency.value = 36.7; // Low D
        sub.connect(bgmGain);
        sub.start(t);

        // Dark pad
        const pad1 = audioCtx.createOscillator();
        pad1.type = 'triangle';
        pad1.frequency.value = 73.4; // D2
        const padFilter = audioCtx.createBiquadFilter();
        padFilter.type = 'lowpass';
        padFilter.frequency.value = 200;
        pad1.connect(padFilter);
        padFilter.connect(bgmGain);
        pad1.start(t);

        // Dissonant fifth for tension
        const pad2 = audioCtx.createOscillator();
        pad2.type = 'sine';
        pad2.frequency.value = 108; // ~Ab2 (tritone tension)
        const pad2G = audioCtx.createGain();
        pad2G.gain.value = 0.4;
        pad2.connect(pad2G);
        pad2G.connect(bgmGain);
        pad2.start(t);

        // Slow LFO for eerie pulsing
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.08; // Very slow
        const lfoGain = audioCtx.createGain();
        lfoGain.gain.value = 0.012;
        lfo.connect(lfoGain);
        lfoGain.connect(bgmGain.gain);
        lfo.start(t);

        routeToOutput(bgmGain);
        bgmNodes = { sub, pad1, pad2, lfo, bgmGain };
    }
    function stopBGM() {
        if (!bgmNodes) return;
        for (const node of Object.values(bgmNodes)) {
            try { node.stop?.(); } catch (e) { /* ignore */ }
            try { node.disconnect?.(); } catch (e) { /* ignore */ }
        }
        bgmNodes = null;
    }

    function setSoundEnabled(enabled) {
        SETTINGS.sound = enabled;
        saveSettings();
        if (enabled) {
            initAudio();
            if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
            if (audioCtx && !bgmNodes) startBGM();
        } else {
            stopBGM();
            if (audioCtx && audioCtx.state !== 'closed') audioCtx.suspend();
        }
    }

    function playSound(freq, type, duration, volume = 0.15) {
        if (!audioCtx || !SETTINGS.sound) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        routeToOutput(gain);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    // Noise burst for impact/explosion sounds
    function playNoise(duration, volume = 0.1, filterFreq = 2000) {
        if (!audioCtx || !SETTINGS.sound) return;
        const bufferSize = audioCtx.sampleRate * duration;
        const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const filter = audioCtx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(filterFreq, audioCtx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(200, audioCtx.currentTime + duration);
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        src.connect(filter);
        filter.connect(gain);
        routeToOutput(gain);
        src.start();
        src.stop(audioCtx.currentTime + duration);
    }

    // Sweep sound (for magic effects)
    function playSweep(startFreq, endFreq, duration, type = 'sine', volume = 0.1) {
        if (!audioCtx || !SETTINGS.sound) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + duration);
        gain.gain.setValueAtTime(volume, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain);
        routeToOutput(gain);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    }

    // Melee hit - heavy metal clang + bone crunch + body impact
    function sfxHit() {
        // Metal clang
        playNoise(0.06, 0.12, 4000);
        playSound(220, 'sawtooth', 0.06, 0.12);
        // Body thud
        playSound(80, 'square', 0.08, 0.09);
        // Secondary impact
        setTimeout(() => { playNoise(0.04, 0.06, 1200); playSound(55, 'sine', 0.1, 0.05); }, 25);
        // Bone crack
        setTimeout(() => playNoise(0.02, 0.04, 6000), 40);
    }

    // Item pickup - metallic clink with echo
    function sfxPickup() {
        playSound(1200, 'sine', 0.04, 0.06);
        setTimeout(() => playSound(1500, 'sine', 0.06, 0.05), 40);
        setTimeout(() => playSound(1800, 'sine', 0.08, 0.04), 80);
        setTimeout(() => playSound(1200, 'triangle', 0.12, 0.02), 120);
    }

    // Fireball - deep whoosh + magical crackle
    function sfxFireball() {
        playSweep(500, 120, 0.35, 'sawtooth', 0.09);
        playNoise(0.2, 0.07, 1800);
        playSound(150, 'triangle', 0.15, 0.04);
        setTimeout(() => { playNoise(0.12, 0.05, 3000); playSweep(300, 80, 0.2, 'triangle', 0.03); }, 50);
    }

    // Whirlwind - rushing gale
    function sfxWhirlwind() {
        playNoise(0.5, 0.09, 1500);
        playSweep(180, 450, 0.25, 'triangle', 0.07);
        playSweep(350, 120, 0.35, 'triangle', 0.05);
        playSound(100, 'sawtooth', 0.3, 0.03);
        setTimeout(() => playNoise(0.3, 0.04, 800), 100);
    }

    // Heal - ethereal chime with holy resonance
    function sfxHeal() {
        playSound(523, 'sine', 0.2, 0.07);
        playSound(523 * 1.5, 'sine', 0.2, 0.03);
        setTimeout(() => { playSound(659, 'sine', 0.2, 0.06); playSound(659 * 1.5, 'sine', 0.15, 0.02); }, 100);
        setTimeout(() => { playSound(784, 'sine', 0.25, 0.06); playSound(1047, 'sine', 0.3, 0.04); }, 200);
        setTimeout(() => playSound(1320, 'sine', 0.4, 0.03), 300);
    }

    // Level up - triumphant cathedral fanfare
    function sfxLevelUp() {
        playSound(294, 'square', 0.15, 0.08);
        playSound(294, 'sine', 0.3, 0.05);
        setTimeout(() => { playSound(370, 'square', 0.15, 0.08); playSound(370, 'sine', 0.2, 0.04); }, 120);
        setTimeout(() => { playSound(440, 'square', 0.15, 0.1); playSound(440, 'sine', 0.2, 0.05); }, 240);
        setTimeout(() => {
            playSound(587, 'sine', 0.5, 0.12); playSound(294, 'sine', 0.5, 0.06);
            playSound(440, 'sine', 0.5, 0.04); playNoise(0.15, 0.03, 5000);
        }, 360);
    }

    // Death - deep dread + collapse
    function sfxDeath() {
        playSweep(250, 35, 0.8, 'sawtooth', 0.14);
        playNoise(0.4, 0.1, 600);
        playSound(30, 'square', 0.6, 0.12);
        setTimeout(() => { playSound(25, 'sawtooth', 0.5, 0.08); playNoise(0.5, 0.06, 300); }, 100);
        setTimeout(() => playNoise(0.3, 0.04, 200), 300);
    }

    // Stairs - ominous descending echo
    function sfxStairs() {
        playSound(440, 'sine', 0.15, 0.07);
        setTimeout(() => playSound(392, 'sine', 0.15, 0.07), 120);
        setTimeout(() => playSound(330, 'sine', 0.15, 0.07), 240);
        setTimeout(() => { playSound(294, 'sine', 0.3, 0.06); playSound(147, 'sine', 0.4, 0.04); }, 360);
        setTimeout(() => playNoise(0.2, 0.03, 400), 450);
    }

    // Legendary drop - heavenly choir
    function sfxLegendary() {
        playSound(440, 'sine', 0.15, 0.1);
        playSound(554, 'sine', 0.15, 0.05);
        setTimeout(() => { playSound(554, 'sine', 0.15, 0.1); playSound(659, 'sine', 0.15, 0.05); }, 80);
        setTimeout(() => { playSound(659, 'sine', 0.2, 0.1); playSound(831, 'sine', 0.2, 0.05); }, 160);
        setTimeout(() => {
            playSound(880, 'sine', 0.6, 0.14); playSound(1100, 'sine', 0.5, 0.06);
            playSound(440, 'sine', 0.6, 0.06); playNoise(0.15, 0.04, 6000);
        }, 260);
        setTimeout(() => playSound(1320, 'sine', 0.4, 0.05), 400);
    }

    // Frost Nova - glass shattering + icy wind
    function sfxFrostNova() {
        playNoise(0.25, 0.1, 5000);
        playSweep(3000, 400, 0.15, 'sine', 0.07);
        playSound(2000, 'square', 0.03, 0.06); // Sharp crack
        setTimeout(() => { playNoise(0.2, 0.06, 7000); playSweep(2000, 200, 0.25, 'sine', 0.04); }, 40);
        setTimeout(() => playNoise(0.15, 0.03, 3000), 100);
    }

    // Shield activate - deep energy hum with resonance
    function sfxShield() {
        playSweep(150, 600, 0.25, 'sine', 0.09);
        playSound(300, 'triangle', 0.4, 0.06);
        playSound(600, 'sine', 0.3, 0.04);
        setTimeout(() => { playSound(450, 'sine', 0.25, 0.04); playSweep(600, 800, 0.15, 'triangle', 0.03); }, 100);
    }

    // Meteor - ominous descent
    function sfxMeteorCast() {
        playSweep(120, 50, 0.6, 'sawtooth', 0.07);
        playNoise(0.5, 0.05, 500);
        playSweep(80, 40, 0.7, 'square', 0.03);
        setTimeout(() => playSweep(200, 60, 0.4, 'triangle', 0.03), 200);
    }

    // Meteor impact - massive explosion
    function sfxMeteorImpact() {
        playNoise(0.5, 0.18, 2500);
        playSound(50, 'square', 0.4, 0.15);
        playSound(35, 'sawtooth', 0.6, 0.1);
        playNoise(0.15, 0.1, 5000); // High freq debris
        setTimeout(() => { playNoise(0.4, 0.1, 1000); playSound(70, 'triangle', 0.3, 0.06); }, 50);
        setTimeout(() => { playNoise(0.3, 0.06, 500); playSound(40, 'sine', 0.4, 0.04); }, 150);
        setTimeout(() => playNoise(0.2, 0.03, 300), 300);
    }

    // Monster death - guttural collapse + bone crunch
    function sfxMonsterDeath() {
        playSound(100, 'sawtooth', 0.15, 0.1);
        playNoise(0.12, 0.08, 1500);
        playSound(55, 'square', 0.1, 0.07);
        setTimeout(() => { playNoise(0.08, 0.05, 3000); playSound(40, 'sine', 0.15, 0.04); }, 50);
        setTimeout(() => playNoise(0.06, 0.03, 800), 100);
    }

    // Footstep - alternating stone taps with variation
    let lastFootstepTime = 0;
    let footstepAlt = false;
    function sfxFootstep() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        if (now - lastFootstepTime < 0.28) return;
        lastFootstepTime = now;
        footstepAlt = !footstepAlt;
        const pitch = footstepAlt ? 90 : 75;
        const vol = 0.015 + Math.random() * 0.01;
        playNoise(0.035, vol, 500 + Math.random() * 300);
        playSound(pitch + Math.random() * 30, 'triangle', 0.03, vol * 0.8);
    }

    // Chest open - heavy creak + gold jingle
    function sfxChestOpen() {
        playSweep(120, 250, 0.2, 'sawtooth', 0.06);
        playNoise(0.12, 0.06, 1000);
        setTimeout(() => { playNoise(0.08, 0.04, 600); playSweep(250, 150, 0.15, 'triangle', 0.04); }, 80);
        setTimeout(() => sfxPickup(), 150);
        setTimeout(() => sfxPickup(), 200);
    }

    // Monster growl - when monster aggros player
    function sfxMonsterGrowl() {
        if (!audioCtx) return;
        playSweep(120, 60, 0.3, 'sawtooth', 0.04);
        playNoise(0.15, 0.02, 600);
    }

    // Player hit - pain grunt
    function sfxPlayerHit() {
        playNoise(0.06, 0.06, 1500);
        playSound(150, 'sawtooth', 0.08, 0.05);
        setTimeout(() => playSound(100, 'square', 0.05, 0.03), 30);
    }

    // Ambient dungeon - layered environmental sounds
    let lastAmbientTime = 0;
    let ambientDripTimer = 0;
    function sfxAmbient() {
        if (!audioCtx) return;
        const now = audioCtx.currentTime;
        if (now - lastAmbientTime < 3 + Math.random() * 6) return;
        lastAmbientTime = now;
        const r = Math.random();
        if (r < 0.25) {
            // Water drip with multiple echoes
            const freq = 1500 + Math.random() * 1000;
            playSound(freq, 'sine', 0.06, 0.025);
            setTimeout(() => playSound(freq * 0.7, 'sine', 0.05, 0.015), 100 + Math.random() * 80);
            setTimeout(() => playSound(freq * 0.5, 'sine', 0.04, 0.008), 250 + Math.random() * 100);
        } else if (r < 0.4) {
            // Distant rumble / earthquake
            playNoise(0.5, 0.015, 250);
            playSound(30, 'sine', 0.4, 0.008);
        } else if (r < 0.55) {
            // Wind through corridors
            playNoise(0.8, 0.012, 800);
            playSweep(400, 200, 0.6, 'sine', 0.005);
        } else if (r < 0.7) {
            // Distant chain rattle
            for (let i = 0; i < 3; i++) {
                setTimeout(() => playNoise(0.02, 0.015, 4000 + Math.random() * 2000), i * 60);
            }
        } else if (r < 0.85) {
            // Stone creak
            playSweep(60, 40, 0.3, 'sawtooth', 0.008);
            setTimeout(() => playNoise(0.05, 0.005, 300), 200);
        } else {
            // Distant moan / ghost
            playSweep(200, 150, 0.6, 'sine', 0.01);
            setTimeout(() => playSweep(170, 130, 0.4, 'sine', 0.006), 300);
        }
    }

    // --- Constants ---
    const TILE = 40;
    const MAP_W = 60, MAP_H = 60;
    const MAX_PARTICLES = 1500; // Diabloé¢¨ï¼šãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã®ä¸Šé™ã‚’3å€ã«ï¼ˆ500â†’1500ï¼‰
    let W = window.innerWidth, H = window.innerHeight;

    // --- Canvas Setup ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let DPR = Math.min(window.devicePixelRatio || 1, 2);
    function resizeCanvas() {
        W = window.innerWidth;
        H = window.innerHeight;
        DPR = Math.min(window.devicePixelRatio || 1, 2);
        canvas.width = Math.round(W * DPR);
        canvas.height = Math.round(H * DPR);
        canvas.style.width = W + 'px';
        canvas.style.height = H + 'px';
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        ctx.imageSmoothingEnabled = true;
    }
    resizeCanvas();

    const DOM = {
        titleScreen: document.getElementById('titleScreen'),
        titleStartText: document.getElementById('titleStartText'),
        titleSaveMenu: document.getElementById('titleSaveMenu'),
        titleSaveContent: document.getElementById('titleSaveContent'),
        classSelect: document.getElementById('classSelect'),
        statsPanel: document.getElementById('statsPanel'),
        statsContent: document.getElementById('statsContent'),
        inventoryPanel: document.getElementById('inventoryPanel'),
        inventoryContent: document.getElementById('inventoryContent'),
        tooltip: document.getElementById('tooltip'),
        logPanel: document.getElementById('logPanel'),
        levelUpNotice: document.getElementById('levelUpNotice'),
        deathScreen: document.getElementById('deathScreen'),
        helpOverlay: document.getElementById('helpOverlay'),
        skillTreePanel: document.getElementById('skillTreePanel'),
        skillTreeContent: document.getElementById('skillTreeContent'),
        skillEditBtn: document.getElementById('skillEditBtn'),
        promotionOverlay: document.getElementById('promotionOverlay'),
        promotionContent: document.getElementById('promotionContent'),
        skillSelectOverlay: document.getElementById('skillSelectOverlay'),
        skillSelectContent: document.getElementById('skillSelectContent'),
        settingsPanel: document.getElementById('settingsPanel'),
        settingsContent: document.getElementById('settingsContent'),
        pauseOverlay: document.getElementById('pauseOverlay')
    };

    // --- Game State ---
    const G = {
        started: false,
        titlePhase: 'start', // 'start' | 'classSelect'
        selectedClassIdx: 0,
        floor: 1,
        camX: 0, camY: 0,
        shakeT: 0, shakeAmt: 0, dmgFlashT: 0,
        time: 0,
        dead: false,
        paused: false,
        autoPickup: false,
        autoPickupRarity: 'normal',
        dungeonSeed: 0,
        saveSlot: 1,
        spawnTimer: 0, // æ•µãƒªã‚¹ãƒãƒ¼ãƒ³ã‚¿ã‚¤ãƒãƒ¼
        spawnInterval: 8 // 8ç§’ã”ã¨ã«æ•µã‚’è¿½åŠ å‡ºç¾
    };

    const SETTINGS = {
        sound: true,
        screenShake: true,
        reducedParticles: false,
        filmGrain: true,
        showFPS: false
    };

    function loadSettings() {
        try {
            const raw = localStorage.getItem('diablo_settings');
            if (!raw) return;
            const data = JSON.parse(raw);
            for (const k of Object.keys(SETTINGS)) {
                if (typeof data[k] === 'boolean') SETTINGS[k] = data[k];
            }
        } catch (e) { /* ignore */ }
    }
    function saveSettings() {
        try { localStorage.setItem('diablo_settings', JSON.stringify(SETTINGS)); } catch (e) { /* ignore */ }
    }
    const SAVE_SLOT_COUNT = 3;
    const SAVE_SLOT_KEY = 'diablo_save_slot';
    function getSaveKey(slot) { return `diablo_save_${slot}`; }
    function initSaveSlot() {
        try {
            const raw = localStorage.getItem(SAVE_SLOT_KEY);
            const slot = parseInt(raw, 10);
            if (slot >= 1 && slot <= SAVE_SLOT_COUNT) G.saveSlot = slot;
        } catch (e) { /* ignore */ }
    }
    window.setSaveSlot = function(slot) {
        if (slot < 1 || slot > SAVE_SLOT_COUNT) return;
        G.saveSlot = slot;
        try { localStorage.setItem(SAVE_SLOT_KEY, String(slot)); } catch (e) { /* ignore */ }
        renderSettingsUI();
        renderTitleSaveMenu();
    };
    function getSaveMeta(slot) {
        try {
            const raw = localStorage.getItem(getSaveKey(slot));
            if (!raw) return null;
            const save = JSON.parse(raw);
            if (!save || !save.player) return null;
            return {
                timestamp: save.timestamp || 0,
                level: save.player.level || 1,
                floor: save.floor || 1,
                className: save.player.className || save.playerClass || 'ä¸æ˜'
            };
        } catch (e) { return null; }
    }
    function hasSaveData(slot) {
        try { return !!localStorage.getItem(getSaveKey(slot)); } catch (e) { return false; }
    }
    function hasAnySaveData() {
        for (let i = 1; i <= SAVE_SLOT_COUNT; i++) {
            if (hasSaveData(i)) return true;
        }
        return false;
    }
    loadSettings();
    initSaveSlot();
    renderTitleSaveMenu();

    // --- Seeded PRNG (mulberry32) for dungeon reproducibility ---
    let _seedState = 0;
    let _useSeededRng = false;
    function mulberry32() {
        let t = (_seedState += 0x6D2B79F5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    }
    function seedRng(seed) { _seedState = seed | 0; _useSeededRng = true; }
    function unseedRng() { _useSeededRng = false; }
    function _rng() { return _useSeededRng ? mulberry32() : Math.random(); }

    // --- Utility ---
    const rand = (a, b) => Math.floor(_rng() * (b - a + 1)) + a;
    const randf = (a, b) => _rng() * (b - a) + a;
    const dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
    const lerp = (a, b, t) => a + (b - a) * t;
    const clamp = (v, mn, mx) => Math.max(mn, Math.min(mx, v));
    const FONT_UI = '"Spectral", "Garamond", "Georgia", serif';
    const FONT_EMOJI = '"Apple Color Emoji", "Segoe UI Emoji", "Noto Color Emoji", "Twemoji Mozilla", sans-serif';
    const FONT_TITLE = '"Cinzel", "IM Fell English", "Garamond", serif';

    // --- Log System ---
    const logMessages = [];
    let logDirty = false;
    let lastLogRender = 0;
    function addLog(msg, color = '#daa520') {
        logMessages.push({ msg, color, time: G.time });
        if (logMessages.length > 8) logMessages.shift();
        logDirty = true;
    }
    function drawLog() {
        if (!logDirty && G.time - lastLogRender < 0.25) return;
        const el = DOM.logPanel;
        el.innerHTML = logMessages.map((l) => {
            const age = G.time - l.time;
            const cls = age > 5 ? 'fade' : '';
            return `<div class="log-msg ${cls}" style="color:${l.color}">${l.msg}</div>`;
        }).join('');
        logDirty = false;
        lastLogRender = G.time;
    }

    // ========== ATTRIBUTE BEHAVIORS FOR PARTICLES ==========
    const ATTRIBUTE_BEHAVIORS = {
        fire: {
            motion: (p, dt) => {
                // Rising heat effect (exaggerated for visibility)
                p.vy -= 150 * dt;
                // Flickering sideways
                p.vx += Math.sin((p.maxLife - p.life) * 15) * 50 * dt;
            },
            sizeScale: (lifeRatio) => 1 + (1 - lifeRatio) * 0.5, // Expands as it dies
            alphaBoost: 1.2,
            glowColor: '#ffaa00'
        },
        ice: {
            motion: (p, dt) => {
                // Slow down crystallization
                p.vx *= 0.95;
                p.vy *= 0.95;
                // Spinning crystals
                p.rotation = (p.rotation || 0) + dt * 2;
            },
            sizeScale: (lifeRatio) => 1 + lifeRatio * 0.3, // Grows slightly
            alphaBoost: 1.0,
            glowColor: '#eeffff',
            shape: 'diamond' // Special rendering hint
        },
        lightning: {
            motion: (p, dt) => {
                // Jagged, fast motion with sudden direction changes (exaggerated)
                if (Math.random() < 0.3) {
                    p.vx += (Math.random() - 0.5) * 350;
                    p.vy += (Math.random() - 0.5) * 350;
                }
            },
            sizeScale: (lifeRatio) => lifeRatio > 0.5 ? 1.5 : 0.8, // Flash effect
            alphaBoost: 1.5,
            glowColor: '#ffffaa',
            trail: true // Leave trail particles (handled in emitParticles)
        },
        physical: {
            motion: (p, dt) => {
                // Heavy gravity for debris (exaggerated)
                p.grav = 400;
                // Bounce once
                if (!p.bounced && p.vy > 0 && p.y > p.startY + 20) {
                    p.vy *= -0.4;
                    p.bounced = true;
                }
            },
            sizeScale: (lifeRatio) => 1 - lifeRatio * 0.3, // Shrinks
            alphaBoost: 0.9,
            glowColor: '#aa7744'
        },
        holy: {
            motion: (p, dt) => {
                // Radial expansion from center
                const angle = Math.atan2(p.y - p.centerY, p.x - p.centerX);
                p.vx += Math.cos(angle) * 20 * dt;
                p.vy += Math.sin(angle) * 20 * dt;
                // Gentle upward drift
                p.vy -= 40 * dt;
            },
            sizeScale: (lifeRatio) => 1 + (1 - lifeRatio) * 0.6, // Expands gently
            alphaBoost: 0.8,
            glowColor: '#ffffdd',
            glow: 'soft' // Diffuse glow
        },
        arcane: {
            motion: (p, dt) => {
                // Swirling, ethereal motion (exaggerated)
                const t = p.maxLife - p.life;
                p.vx += Math.cos(t * 8) * 90 * dt;
                p.vy += Math.sin(t * 8) * 90 * dt;
            },
            sizeScale: (lifeRatio) => 1 + Math.sin(lifeRatio * Math.PI) * 0.4,
            alphaBoost: 1.1,
            glowColor: '#dd88ff',
            ethereal: true // Transparent rendering
        },
        nature: {
            motion: (p, dt) => {
                // Organic drift with sine wave
                p.vx += Math.sin((p.life + p.offset) * 3) * 30 * dt;
                // Slower falloff - lingering effect
                p.vy *= 0.98;
            },
            sizeScale: (lifeRatio) => 1 + (1 - lifeRatio) * 0.2,
            alphaBoost: 0.7,
            glowColor: '#88ff88',
            linger: true // Longer life (handled in constructor)
        }
    };

    // ========== PARTICLE SYSTEM (Round Soft-Glow) ==========
    class Particle {
        constructor(x, y, vx, vy, color, life, size = 3, grav = 150, attribute = null, skillLevel = 1) {
            this.x = x; this.y = y;
            this.startY = y; // For bounce detection
            this.centerX = x; this.centerY = y; // For radial effects
            this.vx = vx; this.vy = vy;
            this.color = color;
            this.life = this.maxLife = life;
            this.size = size;
            this.grav = grav;
            this.attribute = attribute; // NEW: attribute type
            this.skillLevel = skillLevel; // NEW: skill level (1-5)
            this.offset = Math.random() * Math.PI * 2; // For organic motion
            this.rotation = 0;
            this.bounced = false;

            // Apply skill level scaling (enhanced for visibility)
            if (skillLevel && skillLevel > 0) {
                const levelScale = 0.7 + (skillLevel - 1) * 0.3; // 0.7x at L1, 1.9x at L5
                this.size *= (0.8 + (skillLevel - 1) * 0.12); // Size: 0.8x to 1.28x
                this.maxLife *= (1 + (skillLevel - 1) * 0.06); // Life: +6% per level
                this.life = this.maxLife;
            }
        }
        update(dt) {
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.vy += this.grav * dt;
            this.life -= dt;

            // Apply attribute-specific motion behavior
            if (this.attribute && ATTRIBUTE_BEHAVIORS[this.attribute]) {
                ATTRIBUTE_BEHAVIORS[this.attribute].motion(this, dt);
            }
        }
        draw(cx, cy) {
            const lifeRatio = clamp(this.life / this.maxLife, 0, 1);
            const sx = this.x - cx, sy = this.y - cy;

            // Base size with attribute scaling
            let s = this.size * (0.5 + lifeRatio * 0.5);
            if (this.attribute && ATTRIBUTE_BEHAVIORS[this.attribute]) {
                s *= ATTRIBUTE_BEHAVIORS[this.attribute].sizeScale(lifeRatio);
            }

            // Alpha with attribute boost
            let alpha = lifeRatio * 0.8;
            if (this.attribute && ATTRIBUTE_BEHAVIORS[this.attribute]) {
                alpha *= ATTRIBUTE_BEHAVIORS[this.attribute].alphaBoost;
            }

            // Core particle
            ctx.globalAlpha = clamp(alpha, 0, 1);
            ctx.fillStyle = this.color;

            // Shape rendering - diamond for ice
            if (this.attribute === 'ice' && ATTRIBUTE_BEHAVIORS[this.attribute].shape === 'diamond') {
                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(this.rotation);
                ctx.beginPath();
                ctx.moveTo(0, -s);
                ctx.lineTo(s, 0);
                ctx.lineTo(0, s);
                ctx.lineTo(-s, 0);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            } else {
                ctx.beginPath();
                ctx.arc(sx, sy, s, 0, Math.PI * 2);
                ctx.fill();
            }

            // Enhanced glow for high-level skills (level 3+)
            if (this.skillLevel && this.skillLevel >= 3) {
                const glowColor = this.attribute && ATTRIBUTE_BEHAVIORS[this.attribute]
                    ? ATTRIBUTE_BEHAVIORS[this.attribute].glowColor
                    : '#fff';
                ctx.globalAlpha = clamp(alpha * 0.6, 0, 0.6);
                ctx.fillStyle = glowColor;
                ctx.beginPath();
                ctx.arc(sx, sy, s * 1.8, 0, Math.PI * 2);
                ctx.fill();
            }

            // Hot center
            ctx.globalAlpha = clamp(alpha * 0.4, 0, 0.4);
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(sx, sy, s * 0.3, 0, Math.PI * 2);
            ctx.fill();

            ctx.globalAlpha = 1;
        }
        alive() { return this.life > 0; }
    }

    const particles = [];
    function emitParticles(x, y, color, count, speed = 80, life = 0.5, size = 3, grav = 150, attribute = null, skillLevel = 1) {
        // Diablo Mode: Triple particle count for spectacular effects
        const DIABLO_MODE = !SETTINGS.reducedParticles; // ä½è² è·ãƒ¢ãƒ¼ãƒ‰ã§ãªã„å ´åˆã«æœ‰åŠ¹
        if (DIABLO_MODE) {
            count = Math.round(count * 3.0); // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ã‚’3å€ã«
        }

        // Apply skill level scaling to count (enhanced for visibility)
        if (skillLevel && skillLevel > 0) {
            const levelScale = 0.7 + (skillLevel - 1) * 0.3; // 0.7x at L1, 1.9x at L5
            count = Math.round(count * levelScale);
        }

        if (SETTINGS.reducedParticles) count = Math.max(1, Math.floor(count * 0.55));
        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°ä¸Šé™ãƒã‚§ãƒƒã‚¯
        const availableSlots = MAX_PARTICLES - particles.length;
        if (availableSlots <= 0) return; // ä¸Šé™ã«é”ã—ãŸã‚‰ç”Ÿæˆã—ãªã„
        count = Math.min(count, availableSlots); // ä¸Šé™ã‚’è¶…ãˆãªã„ã‚ˆã†ã«èª¿æ•´
        for (let i = 0; i < count; i++) {
            const a = randf(0, Math.PI * 2);
            const s = randf(20, speed);
            particles.push(new Particle(
                x + randf(-4,4),
                y + randf(-4,4),
                Math.cos(a)*s,
                Math.sin(a)*s,
                color,
                randf(life*0.5, life),
                randf(size*0.5, size*1.5),
                grav,
                attribute,  // NEW
                skillLevel  // NEW
            ));
        }

        // Trail effect for lightning (skill level 3+)
        if (attribute === 'lightning' && skillLevel >= 3) {
            setTimeout(() => {
                if (particles.length < MAX_PARTICLES - 5) {
                    for (let i = 0; i < 3; i++) {
                        particles.push(new Particle(x, y, randf(-20,20), randf(-20,20), color, 0.2, 1, 0, attribute, skillLevel));
                    }
                }
            }, 50);
        }
    }

    // Trail particle system for max-level skills (Level 5)
    function emitTrailParticles(x, y, color, attribute, skillLevel) {
        if (skillLevel < 5) return; // Only for max level
        if (particles.length >= MAX_PARTICLES - 10) return; // Reserve slots

        const trailCount = 5;
        for (let i = 0; i < trailCount; i++) {
            setTimeout(() => {
                if (particles.length < MAX_PARTICLES - 3) {
                    particles.push(new Particle(
                        x + randf(-8, 8),
                        y + randf(-8, 8),
                        randf(-15, 15),
                        randf(-15, 15),
                        color,
                        0.3,
                        2,
                        50,
                        attribute,
                        skillLevel
                    ));
                }
            }, i * 40); // Staggered timing
        }
    }

    // ========== AMBIENT PARTICLES (Dust motes, embers) ==========
    const ambientParticles = [];
    class AmbientParticle {
        constructor() { this.reset(); }
        reset() {
            this.x = player.x + randf(-400, 400);
            this.y = player.y + randf(-300, 300);
            this.vx = randf(-5, 5);
            this.vy = randf(-15, -3);
            this.size = randf(0.5, 2);
            this.life = this.maxLife = randf(3, 8);
            this.type = Math.random() < 0.3 ? 'ember' : 'dust';
            this.drift = randf(0, Math.PI * 2);
            if (this.type === 'ember') {
                const hue = 20 + Math.random() * 20;
                const light = 50 + Math.random() * 30;
                this.color = `hsl(${hue}, 100%, ${light}%)`;
                this.alpha = 0.6;
            } else {
                this.color = '#aa997766';
                this.alpha = 0.25;
            }
        }
        update(dt) {
            this.drift += dt * 0.5;
            this.x += (this.vx + Math.sin(this.drift) * 3) * dt;
            this.y += this.vy * dt;
            this.life -= dt;
        }
        draw(cx, cy) {
            const sx = this.x - cx, sy = this.y - cy;
            if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) return;
            const a = clamp(this.life / this.maxLife, 0, 1) * (this.life < 1 ? this.life : 1);
            ctx.globalAlpha = a * this.alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(sx, sy, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
        alive() { return this.life > 0; }
    }
    function updateAmbientParticles(dt) {
        const target = SETTINGS.reducedParticles ? 8 : 15;
        while (ambientParticles.length < target) ambientParticles.push(new AmbientParticle());
        while (ambientParticles.length > target) ambientParticles.pop();
        for (let i = ambientParticles.length - 1; i >= 0; i--) {
            ambientParticles[i].update(dt);
            if (!ambientParticles[i].alive()) ambientParticles[i].reset();
        }
    }

    // ========== BLOOD POOLS (persist after monster death) ==========
    const bloodPools = [];
    function addBloodPool(x, y, size) {
        bloodPools.push({ x, y, size: size * 0.5, maxSize: size, alpha: 0.6, growT: 0.5 });
        if (bloodPools.length > 50) bloodPools.shift(); // Limit
    }
    function updateBloodPools(dt) {
        for (const bp of bloodPools) {
            if (bp.growT > 0) {
                bp.growT -= dt;
                bp.size = bp.maxSize * (1 - bp.growT / 0.5);
            }
        }
    }
    function drawBloodPools(cx, cy) {
        for (const bp of bloodPools) {
            const sx = bp.x - cx, sy = bp.y - cy;
            if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) continue;
            ctx.globalAlpha = bp.alpha * 0.7;
            ctx.fillStyle = '#300505';
            ctx.beginPath();
            ctx.ellipse(sx, sy + 2, bp.size, bp.size * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // ========== FLOATING DAMAGE ==========
    const floatingTexts = [];
    function addFloatingText(x, y, text, color, big = false) {
        floatingTexts.push({ x, y, text: String(text), color, life: 1.2, maxLife: 1.2, big, vy: -60 });
    }

    // ========== TILE TEXTURE SYSTEM (Offscreen Canvas) ==========
    // Pre-render tile textures for much better visual quality
    const TILE_TEXTURES = {};

    function generateTileTextures() {
        // Helper: create noise pattern on a canvas
        function addNoise(tctx, w, h, intensity, r, g, b) {
            const id = tctx.getImageData(0, 0, w, h);
            const d = id.data;
            for (let i = 0; i < d.length; i += 4) {
                const n = (Math.random() - 0.5) * intensity;
                d[i] = clamp(d[i] + n * r, 0, 255);
                d[i+1] = clamp(d[i+1] + n * g, 0, 255);
                d[i+2] = clamp(d[i+2] + n * b, 0, 255);
            }
            tctx.putImageData(id, 0, 0);
        }

        // --- FLOOR TILES (4 variants) ---
        for (let v = 0; v < 4; v++) {
            const c = document.createElement('canvas');
            c.width = TILE; c.height = TILE;
            const tc = c.getContext('2d');

            // Base stone color (dark, warm gray)
            const baseR = 28 + v * 3, baseG = 25 + v * 2, baseB = 22 + v * 2;
            tc.fillStyle = `rgb(${baseR},${baseG},${baseB})`;
            tc.fillRect(0, 0, TILE, TILE);

            // Large stone slab pattern (Diablo cathedral feel)
            tc.strokeStyle = `rgba(15,12,10,0.6)`;
            tc.lineWidth = 1;
            tc.strokeRect(1, 1, TILE - 2, TILE - 2);

            // Inner bevel highlight (top-left edges brighter)
            tc.fillStyle = `rgba(255,240,220,0.04)`;
            tc.fillRect(2, 2, TILE - 4, 1);
            tc.fillRect(2, 2, 1, TILE - 4);
            // Inner bevel shadow (bottom-right edges darker)
            tc.fillStyle = `rgba(0,0,0,0.08)`;
            tc.fillRect(2, TILE - 3, TILE - 4, 1);
            tc.fillRect(TILE - 3, 2, 1, TILE - 4);

            // Add stone grain noise
            addNoise(tc, TILE, TILE, 15, 1, 0.9, 0.8);

            // Random surface details per variant
            if (v === 0) {
                // Scratch marks
                tc.strokeStyle = 'rgba(10,8,6,0.3)';
                tc.lineWidth = 0.5;
                tc.beginPath();
                tc.moveTo(8, 5); tc.lineTo(28, 18); tc.stroke();
            } else if (v === 1) {
                // Small crack
                tc.strokeStyle = 'rgba(8,5,3,0.4)';
                tc.lineWidth = 0.5;
                tc.beginPath();
                tc.moveTo(15, 2); tc.lineTo(18, 15); tc.lineTo(14, 30); tc.lineTo(17, 38); tc.stroke();
            } else if (v === 2) {
                // Worn center
                tc.fillStyle = 'rgba(0,0,0,0.04)';
                tc.beginPath();
                tc.ellipse(TILE/2, TILE/2, 12, 10, 0.3, 0, Math.PI * 2);
                tc.fill();
            }

            TILE_TEXTURES['floor_' + v] = c;
        }

        // --- WALL TILE (exposed to floor) ---
        const wallC = document.createElement('canvas');
        wallC.width = TILE; wallC.height = TILE;
        const wc = wallC.getContext('2d');

        // Dark stone base
        wc.fillStyle = '#3d3228';
        wc.fillRect(0, 0, TILE, TILE);

        // Brick pattern (2 rows)
        const halfH = TILE / 2;
        // Row 1: full width brick
        wc.fillStyle = '#44382c';
        wc.fillRect(2, 2, TILE - 4, halfH - 3);
        // Row 2: two half bricks
        wc.fillStyle = '#403428';
        wc.fillRect(2, halfH + 1, TILE / 2 - 3, halfH - 3);
        wc.fillStyle = '#3e3226';
        wc.fillRect(TILE / 2 + 1, halfH + 1, TILE / 2 - 3, halfH - 3);

        // Mortar lines
        wc.strokeStyle = '#2a2018';
        wc.lineWidth = 1;
        wc.beginPath();
        wc.moveTo(0, halfH); wc.lineTo(TILE, halfH); wc.stroke();
        wc.beginPath();
        wc.moveTo(TILE / 2, halfH); wc.lineTo(TILE / 2, TILE); wc.stroke();

        // Top bevel
        wc.fillStyle = 'rgba(255,240,200,0.06)';
        wc.fillRect(0, 0, TILE, 2);

        // Stone grain
        addNoise(wc, TILE, TILE, 12, 1, 0.9, 0.7);

        TILE_TEXTURES['wall'] = wallC;

        // --- WALL TILE VARIANT 2 ---
        const wallC2 = document.createElement('canvas');
        wallC2.width = TILE; wallC2.height = TILE;
        const wc2 = wallC2.getContext('2d');
        wc2.fillStyle = '#3a3025';
        wc2.fillRect(0, 0, TILE, TILE);
        // Offset brick pattern
        wc2.fillStyle = '#403428';
        wc2.fillRect(2, 2, TILE / 2 - 3, halfH - 3);
        wc2.fillStyle = '#3e3226';
        wc2.fillRect(TILE / 2 + 1, 2, TILE / 2 - 3, halfH - 3);
        wc2.fillStyle = '#44382c';
        wc2.fillRect(2, halfH + 1, TILE - 4, halfH - 3);
        wc2.strokeStyle = '#2a2018';
        wc2.lineWidth = 1;
        wc2.beginPath();
        wc2.moveTo(0, halfH); wc2.lineTo(TILE, halfH); wc2.stroke();
        wc2.beginPath();
        wc2.moveTo(TILE / 2, 0); wc2.lineTo(TILE / 2, halfH); wc2.stroke();
        wc2.fillStyle = 'rgba(255,240,200,0.05)';
        wc2.fillRect(0, 0, TILE, 2);
        addNoise(wc2, TILE, TILE, 12, 1, 0.9, 0.7);
        TILE_TEXTURES['wall2'] = wallC2;

        // --- DEEP WALL (not adjacent to floor) ---
        const deepC = document.createElement('canvas');
        deepC.width = TILE; deepC.height = TILE;
        const dc = deepC.getContext('2d');
        dc.fillStyle = '#141210';
        dc.fillRect(0, 0, TILE, TILE);
        addNoise(dc, TILE, TILE, 8, 0.6, 0.5, 0.4);
        TILE_TEXTURES['deep_wall'] = deepC;

        // --- WALL FACE (3D bottom of wall when floor below) ---
        const faceC = document.createElement('canvas');
        faceC.width = TILE; faceC.height = 10;
        const fc = faceC.getContext('2d');
        const faceG = fc.createLinearGradient(0, 0, 0, 10);
        faceG.addColorStop(0, '#352a20');
        faceG.addColorStop(0.6, '#2a201a');
        faceG.addColorStop(1, '#1a1510');
        fc.fillStyle = faceG;
        fc.fillRect(0, 0, TILE, 10);
        // Bottom line
        fc.fillStyle = 'rgba(0,0,0,0.5)';
        fc.fillRect(0, 9, TILE, 1);
        addNoise(fc, TILE, 10, 8, 0.7, 0.6, 0.5);
        TILE_TEXTURES['wall_face'] = faceC;

        // --- BLOOD SPLATTER variants ---
        for (let v = 0; v < 3; v++) {
            const bc = document.createElement('canvas');
            bc.width = TILE; bc.height = TILE;
            const btc = bc.getContext('2d');
            btc.clearRect(0, 0, TILE, TILE);
            // Random blood drops
            const drops = 3 + v * 2;
            for (let d = 0; d < drops; d++) {
                const bx = 5 + Math.random() * (TILE - 10);
                const by = 5 + Math.random() * (TILE - 10);
                const br = 1 + Math.random() * (3 + v);
                btc.fillStyle = `rgba(${60 + v * 15},${8 + v * 3},${5 + v * 2},${0.15 + Math.random() * 0.15})`;
                btc.beginPath();
                btc.ellipse(bx, by, br, br * (0.6 + Math.random() * 0.8), Math.random() * Math.PI, 0, Math.PI * 2);
                btc.fill();
            }
            TILE_TEXTURES['blood_' + v] = bc;
        }

        // --- FLOOR SHADOW (cast from wall above) ---
        const shadowTopC = document.createElement('canvas');
        shadowTopC.width = TILE; shadowTopC.height = 14;
        const stc = shadowTopC.getContext('2d');
        const sg = stc.createLinearGradient(0, 0, 0, 14);
        sg.addColorStop(0, 'rgba(0,0,0,0.4)');
        sg.addColorStop(1, 'rgba(0,0,0,0)');
        stc.fillStyle = sg;
        stc.fillRect(0, 0, TILE, 14);
        TILE_TEXTURES['shadow_top'] = shadowTopC;

        // --- FLOOR SHADOW (cast from wall on left) ---
        const shadowLeftC = document.createElement('canvas');
        shadowLeftC.width = 10; shadowLeftC.height = TILE;
        const slc = shadowLeftC.getContext('2d');
        const slg = slc.createLinearGradient(0, 0, 10, 0);
        slg.addColorStop(0, 'rgba(0,0,0,0.25)');
        slg.addColorStop(1, 'rgba(0,0,0,0)');
        slc.fillStyle = slg;
        slc.fillRect(0, 0, 10, TILE);
        TILE_TEXTURES['shadow_left'] = shadowLeftC;

        // --- FILM GRAIN (Pre-rendered noise overlay) ---
        const grainC = document.createElement('canvas');
        grainC.width = 256; grainC.height = 256;
        const gctx = grainC.getContext('2d');
        const gid = gctx.createImageData(256, 256);
        const gdata = gid.data;
        for (let i = 0; i < gdata.length; i += 4) {
            const v = (Math.random() * 30) | 0;
            gdata[i] = gdata[i+1] = gdata[i+2] = v;
            gdata[i+3] = 25;
        }
        gctx.putImageData(gid, 0, 0);
        TILE_TEXTURES['grain'] = grainC;

        // Override tile textures with sprite sheet if loaded
        if (spritesLoaded && SPRITES.tiles) {
            const overrides = {
                wall:'wallTop', wall2:'wallSide1', deep_wall:'deepWall',
                floor_0:'floorBlank', floor_1:'floor1', floor_2:'floor2', floor_3:'floor3',
                blood_0:'blood1', blood_1:'blood2', blood_2:'corpse1'
            };
            for (const [texKey, atlasKey] of Object.entries(overrides)) {
                const a = ATLAS[atlasKey];
                if (!a || !SPRITES[a[0]] || !TILE_TEXTURES[texKey]) continue;
                const c = TILE_TEXTURES[texKey];
                const tc = c.getContext('2d');
                tc.imageSmoothingEnabled = false;
                tc.clearRect(0, 0, c.width, c.height);
                tc.drawImage(SPRITES[a[0]], a[1], a[2], SP, SP, 0, 0, c.width, c.height);
            }
            // Wall face: bottom portion of catacomb wall side
            const wf = TILE_TEXTURES['wall_face'];
            if (wf) {
                const a = ATLAS.catWallSide;
                if (a && SPRITES[a[0]]) {
                    const wfc = wf.getContext('2d');
                    wfc.imageSmoothingEnabled = false;
                    wfc.clearRect(0, 0, wf.width, wf.height);
                    wfc.drawImage(SPRITES[a[0]], a[1], a[2] + 22, SP, 10, 0, 0, wf.width, wf.height);
                }
            }
        }
    }

    // ========== DUNGEON GENERATION ==========
    class Dungeon {
        constructor(floor) {
            this.floor = floor;
            this.tiles = new Uint8Array(MAP_W * MAP_H); // 0=wall, 1=floor, 2=stairs, 3=chest
            this.rooms = [];
            this.explored = new Uint8Array(MAP_W * MAP_H);
            this.generate();
        }
        idx(x, y) { return y * MAP_W + x; }
        get(x, y) {
            if (x < 0 || x >= MAP_W || y < 0 || y >= MAP_H) return 0;
            return this.tiles[this.idx(x, y)];
        }
        set(x, y, v) {
            if (x >= 0 && x < MAP_W && y >= 0 && y < MAP_H) this.tiles[this.idx(x, y)] = v;
        }
        walkable(x, y) { const t = this.get(x, y); return t === 1 || t === 2 || t === 3; }

        generate() {
            this.tiles.fill(0);
            const roomCount = 8 + Math.min(this.floor, 8);

            // Generate rooms with varied sizes
            for (let i = 0; i < roomCount * 3 && this.rooms.length < roomCount; i++) {
                // Varied room shapes
                const shapeRoll = _rng();
                let w, h;
                if (shapeRoll < 0.4) {
                    // Normal room
                    w = rand(4, 9); h = rand(4, 7);
                } else if (shapeRoll < 0.7) {
                    // Long corridor room
                    if (_rng() < 0.5) { w = rand(8, 14); h = rand(3, 4); }
                    else { w = rand(3, 4); h = rand(8, 14); }
                } else if (shapeRoll < 0.9) {
                    // Large room
                    w = rand(8, 12); h = rand(7, 10);
                } else {
                    // Tiny room
                    w = rand(3, 5); h = rand(3, 5);
                }

                const rx = rand(2, MAP_W - w - 2);
                const ry = rand(2, MAP_H - h - 2);

                let valid = true;
                for (const r of this.rooms) {
                    if (rx < r.x + r.w + 2 && rx + w + 2 > r.x && ry < r.y + r.h + 2 && ry + h + 2 > r.y) {
                        valid = false; break;
                    }
                }
                if (!valid) continue;

                this.rooms.push({ x: rx, y: ry, w, h, cx: rx + (w>>1), cy: ry + (h>>1) });

                // Carve room with optional irregular edges
                for (let yy = ry; yy < ry + h; yy++) {
                    for (let xx = rx; xx < rx + w; xx++) {
                        // Cut corners for organic feel
                        const isCorner = (xx === rx && yy === ry) || (xx === rx + w - 1 && yy === ry) ||
                                        (xx === rx && yy === ry + h - 1) || (xx === rx + w - 1 && yy === ry + h - 1);
                        if (isCorner && _rng() < 0.4) continue;
                        this.set(xx, yy, 1);
                    }
                }
            }

            // Sort rooms for better connectivity (nearest-neighbor)
            if (this.rooms.length > 2) {
                const sorted = [this.rooms[0]];
                const remaining = this.rooms.slice(1);
                while (remaining.length > 0) {
                    const last = sorted[sorted.length - 1];
                    let bestIdx = 0, bestDist = Infinity;
                    for (let i = 0; i < remaining.length; i++) {
                        const d = Math.hypot(remaining[i].cx - last.cx, remaining[i].cy - last.cy);
                        if (d < bestDist) { bestDist = d; bestIdx = i; }
                    }
                    sorted.push(remaining.splice(bestIdx, 1)[0]);
                }
                this.rooms = sorted;
            }

            // Connect rooms with winding corridors
            for (let i = 1; i < this.rooms.length; i++) {
                const a = this.rooms[i - 1], b = this.rooms[i];
                let cx = a.cx, cy = a.cy;

                // Randomly choose horizontal-first or vertical-first
                if (_rng() < 0.5) {
                    // Horizontal then vertical
                    while (cx !== b.cx) {
                        this.set(cx, cy, 1);
                        // Widen corridor occasionally
                        if (_rng() < 0.3) this.set(cx, cy + 1, 1);
                        cx += cx < b.cx ? 1 : -1;
                    }
                    while (cy !== b.cy) {
                        this.set(cx, cy, 1);
                        if (_rng() < 0.3) this.set(cx + 1, cy, 1);
                        cy += cy < b.cy ? 1 : -1;
                    }
                } else {
                    // Vertical then horizontal
                    while (cy !== b.cy) {
                        this.set(cx, cy, 1);
                        if (_rng() < 0.3) this.set(cx + 1, cy, 1);
                        cy += cy < b.cy ? 1 : -1;
                    }
                    while (cx !== b.cx) {
                        this.set(cx, cy, 1);
                        if (_rng() < 0.3) this.set(cx, cy + 1, 1);
                        cx += cx < b.cx ? 1 : -1;
                    }
                }
                this.set(cx, cy, 1);
            }

            // Extra connections for loops (makes dungeon more interesting)
            const extraLoops = rand(2, Math.min(this.rooms.length - 1, 5));
            for (let i = 0; i < extraLoops; i++) {
                const a = this.rooms[rand(0, this.rooms.length - 1)];
                const b = this.rooms[rand(0, this.rooms.length - 1)];
                if (a === b) continue;
                let cx = a.cx, cy = a.cy;
                // Slightly drunk walk for organic corridors
                while (cx !== b.cx || cy !== b.cy) {
                    this.set(cx, cy, 1);
                    if (_rng() < 0.15 && cx !== b.cx && cy !== b.cy) {
                        // Random wobble
                        if (_rng() < 0.5) cx += cx < b.cx ? 1 : -1;
                        else cy += cy < b.cy ? 1 : -1;
                    } else {
                        // Move toward target
                        if (Math.abs(b.cx - cx) > Math.abs(b.cy - cy))
                            cx += cx < b.cx ? 1 : -1;
                        else
                            cy += cy < b.cy ? 1 : -1;
                    }
                }
                this.set(cx, cy, 1);
            }

            // Place stairs in the room farthest from start
            const startRoom = this.rooms[0];
            let farthestRoom = this.rooms[this.rooms.length - 1];
            let farthestDist = 0;
            for (const r of this.rooms) {
                const d = Math.hypot(r.cx - startRoom.cx, r.cy - startRoom.cy);
                if (d > farthestDist) { farthestDist = d; farthestRoom = r; }
            }
            this.stairsX = farthestRoom.cx;
            this.stairsY = farthestRoom.cy;
            this.set(this.stairsX, this.stairsY, 2);

            // Chests in some rooms (never in first or stairs room)
            for (let i = 1; i < this.rooms.length; i++) {
                const r = this.rooms[i];
                if (r === farthestRoom) continue;
                if (_rng() < 0.3) {
                    const cx = r.x + rand(1, r.w - 2);
                    const cy = r.y + rand(1, r.h - 2);
                    if (this.get(cx, cy) === 1) this.set(cx, cy, 3);
                }
            }

            // Scatter some random floor decorations (pillars = unwalkable in floor)
            for (const r of this.rooms) {
                if (r.w >= 7 && r.h >= 6 && _rng() < 0.4) {
                    // Add pillars to big rooms
                    const px1 = r.x + 2, py1 = r.y + 2;
                    const px2 = r.x + r.w - 3, py2 = r.y + r.h - 3;
                    this.set(px1, py1, 0); this.set(px2, py1, 0);
                    this.set(px1, py2, 0); this.set(px2, py2, 0);
                }
            }
        }

        reveal(px, py, radius) {
            const tr = Math.ceil(radius / TILE);
            const tx = Math.floor(px / TILE), ty = Math.floor(py / TILE);
            for (let dy = -tr; dy <= tr; dy++) {
                for (let dx = -tr; dx <= tr; dx++) {
                    const xx = tx + dx, yy = ty + dy;
                    if (xx >= 0 && xx < MAP_W && yy >= 0 && yy < MAP_H) {
                        if (dx*dx + dy*dy <= tr*tr) this.explored[this.idx(xx, yy)] = 1;
                    }
                }
            }
        }

        draw(camX, camY) {
            const startX = Math.max(0, Math.floor(camX / TILE) - 1);
            const startY = Math.max(0, Math.floor(camY / TILE) - 1);
            const endX = Math.min(MAP_W, startX + Math.ceil(W / TILE) + 3);
            const endY = Math.min(MAP_H, startY + Math.ceil(H / TILE) + 3);

            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    const sx = x * TILE - camX, sy = y * TILE - camY;
                    const t = this.get(x, y);

                    if (t === 0) {
                        // === WALL ===
                        const hasFloorBelow = this.walkable(x, y + 1);
                        const hasFloorRight = this.walkable(x + 1, y);
                        const hasFloorLeft = this.walkable(x - 1, y);
                        const hasFloorAbove = this.walkable(x, y - 1);
                        const isExposed = hasFloorBelow || hasFloorRight || hasFloorLeft || hasFloorAbove;

                        if (isExposed) {
                            // Pre-rendered wall texture
                            const wallTex = (x + y) % 2 === 0 ? TILE_TEXTURES['wall'] : TILE_TEXTURES['wall2'];
                            ctx.drawImage(wallTex, sx, sy);

                            // 3D wall face below
                            if (hasFloorBelow) {
                                ctx.drawImage(TILE_TEXTURES['wall_face'], sx, sy + TILE - 10);
                            }

                            // Moss (deterministic)
                            if ((x * 13 + y * 7) % 23 === 0) {
                                ctx.fillStyle = 'rgba(35,60,25,0.2)';
                                ctx.fillRect(sx + 2, sy + TILE - 14, 8, 5);
                                ctx.fillStyle = 'rgba(40,70,28,0.15)';
                                ctx.fillRect(sx + 4, sy + TILE - 16, 4, 3);
                            }

                            // Wall crack
                            if ((x * 11 + y * 3) % 31 === 0) {
                                ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                                ctx.lineWidth = 0.5;
                                ctx.beginPath();
                                ctx.moveTo(sx + 10, sy + 4);
                                ctx.lineTo(sx + 16, sy + 14);
                                ctx.lineTo(sx + 13, sy + 28);
                                ctx.stroke();
                            }
                        } else {
                            ctx.drawImage(TILE_TEXTURES['deep_wall'], sx, sy);
                        }

                        // Torch on wall (animated sprite)
                        if (isExposed && (x * 7 + y * 13) % 29 === 0) {
                            const torchFrame = Math.floor((G.time * 6 + x * 3 + y * 5) % 6);
                            drawSpr('torch' + torchFrame, sx, sy, TILE, TILE);
                            // Warm glow around torch
                            const fl = Math.sin(G.time * 8 + x * 3 + y * 5) * 2;
                            const gr = 45 + fl * 3;
                            ctx.globalAlpha = 0.08;
                            ctx.fillStyle = '#ff8020';
                            ctx.beginPath();
                            ctx.arc(sx + TILE/2, sy + TILE/2 - 4, gr, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.globalAlpha = 1;
                        }

                    } else if (t === 1) {
                        // === FLOOR ===
                        const variant = ((x * 7 + y * 13) % 4);
                        ctx.drawImage(TILE_TEXTURES['floor_' + variant], sx, sy);

                        // Blood splatters (deterministic)
                        const bloodHash = (x * 17 + y * 31) % 53;
                        if (bloodHash < 3) {
                            ctx.drawImage(TILE_TEXTURES['blood_' + (bloodHash % 3)], sx, sy);
                        }

                        // Bone fragment
                        if ((x * 23 + y * 11) % 67 < 2) {
                            ctx.fillStyle = 'rgba(160,150,120,0.12)';
                            ctx.save();
                            ctx.translate(sx + 18, sy + 24);
                            ctx.rotate((x * 3 + y * 7) * 0.7);
                            ctx.fillRect(-5, -1, 10, 2);
                            ctx.fillRect(-2, -3, 2, 6); // cross bone
                            ctx.restore();
                        }

                        // Pebble
                        if ((x * 19 + y * 29) % 41 < 3) {
                            ctx.fillStyle = 'rgba(50,45,38,0.5)';
                            ctx.beginPath();
                            ctx.arc(sx + ((x * 7) % 30) + 5, sy + ((y * 11) % 30) + 5, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }

                        // Wall shadows
                        if (this.get(x, y - 1) === 0) {
                            ctx.drawImage(TILE_TEXTURES['shadow_top'], sx, sy);
                        }
                        if (this.get(x - 1, y) === 0) {
                            ctx.drawImage(TILE_TEXTURES['shadow_left'], sx, sy);
                        }

                    } else if (t === 2) {
                        // === STAIRS (Sprite) ===
                        const variant = ((x * 7 + y * 13) % 4);
                        ctx.drawImage(TILE_TEXTURES['floor_' + variant], sx, sy);
                        drawSpr('stairsDown', sx, sy, TILE, TILE);

                        // Mystical glow
                        const sg = ctx.createRadialGradient(sx + TILE/2, sy + TILE/2, 0, sx + TILE/2, sy + TILE/2, TILE * 1.3);
                        sg.addColorStop(0, 'rgba(100,70,180,0.3)');
                        sg.addColorStop(0.4, 'rgba(100,70,180,0.1)');
                        sg.addColorStop(1, 'rgba(100,70,180,0)');
                        ctx.fillStyle = sg;
                        ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE * 2, TILE * 2);

                        // Sparkles
                        for (let i = 0; i < 3; i++) {
                            const sa = G.time * 2 + i * 2.1;
                            const spx = sx + TILE/2 + Math.cos(sa) * 12;
                            const spy = sy + TILE/2 + Math.sin(sa * 1.3) * 10 - 4;
                            ctx.fillStyle = `rgba(180,160,255,${0.2 + Math.sin(sa * 3) * 0.15})`;
                            ctx.beginPath();
                            ctx.arc(spx, spy, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }

                    } else if (t === 3) {
                        // === CHEST (Sprite) ===
                        const variant = ((x * 7 + y * 13) % 4);
                        ctx.drawImage(TILE_TEXTURES['floor_' + variant], sx, sy);
                        drawSpr('chestClosed', sx, sy, TILE, TILE);
                        // Gold glow
                        ctx.globalAlpha = 0.12;
                        ctx.fillStyle = '#c8a030';
                        ctx.beginPath();
                        ctx.arc(sx + TILE/2, sy + TILE/2, TILE * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }
                }
            }
        }
    }

    // ========== ITEM SYSTEM ==========
    const ITEM_TYPES = {
        sword:   { name: 'å‰£', icon: 'âš”', slot: 'weapon', baseDmg: [5, 12] },
        axe:     { name: 'æˆ¦æ–§', icon: 'ğŸª“', slot: 'weapon', baseDmg: [8, 16] },
        staff:   { name: 'æ–', icon: 'ğŸ”®', slot: 'weapon', baseDmg: [3, 8] },
        shield:  { name: 'ç›¾', icon: 'ğŸ›¡', slot: 'offhand', baseDef: [3, 8] },
        helmet:  { name: 'å…œ', icon: 'â›‘', slot: 'head', baseDef: [2, 5] },
        armor:   { name: 'é§', icon: 'ğŸ¦º', slot: 'body', baseDef: [4, 10] },
        ring:    { name: 'æŒ‡è¼ª', icon: 'ğŸ’', slot: 'ring', baseDef: [0, 1] },
        amulet:  { name: 'è­·ç¬¦', icon: 'ğŸ“¿', slot: 'amulet', baseDef: [0, 1] },
        boots:   { name: 'é´', icon: 'ğŸ‘¢', slot: 'feet', baseDef: [1, 4] },
        potion:  { name: 'å›å¾©è–¬', icon: 'ğŸ§ª', slot: null, heal: 50 }
    };

    const RARITY = {
        common:    { name: 'ã‚³ãƒ¢ãƒ³', color: '#cccccc', affixes: 0, mult: 1 },
        magic:     { name: 'ãƒã‚¸ãƒƒã‚¯', color: '#6688ff', affixes: [1,2], mult: 1.3 },
        rare:      { name: 'ãƒ¬ã‚¢', color: '#ffdd44', affixes: [2,3], mult: 1.6 },
        legendary: { name: 'ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼', color: '#ff8800', affixes: [3,4], mult: 2.0 },
        unique:    { name: 'ãƒ¦ãƒ‹ãƒ¼ã‚¯', color: '#00dd66', affixes: [4,5], mult: 2.5 }
    };

    function pickRarity(r) {
        return r < 0.50 ? 'common' :
               r < 0.78 ? 'magic' :
               r < 0.93 ? 'rare' :
               r < 0.99 ? 'legendary' : 'unique';
    }
    function getAffixCount(rarity) {
        return Array.isArray(rarity.affixes)
            ? rand(rarity.affixes[0], rarity.affixes[1])
            : rarity.affixes;
    }

    const AFFIXES = [
        { stat: 'str', fmt: '+{v} ç­‹åŠ›', min: 1, max: 8 },
        { stat: 'dex', fmt: '+{v} æ•æ·', min: 1, max: 8 },
        { stat: 'vit', fmt: '+{v} ä½“åŠ›', min: 1, max: 8 },
        { stat: 'int', fmt: '+{v} çŸ¥åŠ›', min: 1, max: 8 },
        { stat: 'dmgPct', fmt: '+{v}% ãƒ€ãƒ¡ãƒ¼ã‚¸', min: 3, max: 25 },
        { stat: 'hp', fmt: '+{v} HP', min: 10, max: 80 },
        { stat: 'mp', fmt: '+{v} MP', min: 10, max: 60 },
        { stat: 'lifesteal', fmt: '{v}% ãƒ©ã‚¤ãƒ•ã‚¹ãƒ†ã‚£ãƒ¼ãƒ«', min: 2, max: 10 },
        { stat: 'atkSpd', fmt: '+{v}% æ”»æ’ƒé€Ÿåº¦', min: 5, max: 20 },
        { stat: 'def', fmt: '+{v} é˜²å¾¡', min: 2, max: 12 },
        { stat: 'critChance', fmt: '+{v}% ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«', min: 2, max: 10 },
        { stat: 'moveSpd', fmt: '+{v}% ç§»å‹•é€Ÿåº¦', min: 3, max: 15 }
    ];

    const UNIQUE_NAMES = {
        sword: ['é­”å‰£ãƒ€ãƒ¼ãƒ³ã‚¹ãƒ¬ã‚¤ãƒ´', 'ç‚ã®æ–­è£‚', 'è™šç©ºã®ç‰™'],
        axe: ['ç²‰ç •è€…', 'è¡€å¡—ã‚Œã®ä¸‰æ—¥æœˆ', 'åµã®åˆƒ'],
        staff: ['ä¸æ­»é³¥ã®æ–', 'æš—é»’ã®å¤§æ–', 'æ˜Ÿéœœã®å°ã'],
        shield: ['ä¸æ»…ã®å£', 'å®ˆè­·è€…ã®èª“ã„'],
        helmet: ['é¾ç‹ã®å† ', 'æ·±æ·µã®é¢'],
        armor: ['ä¸å±ˆã®é§', 'ç…‰ç„ã®èƒ¸å½“ã¦'],
        ring: ['é‹å‘½ã®ç’°', 'é—‡ã®ç³'],
        amulet: ['é­‚ã®é¦–é£¾ã‚Š', 'æ°¸é ã®å¿ƒè‡“'],
        boots: ['ç–¾é¢¨ã®é´', 'å½±æ¸¡ã‚Šã®é•·é´']
    };

    function generateItem(floor, forceRarity = null) {
        const typeKeys = Object.keys(ITEM_TYPES).filter(k => k !== 'potion');
        const typeKey = typeKeys[rand(0, typeKeys.length - 1)];
        const typeInfo = ITEM_TYPES[typeKey];

        let rarityKey = forceRarity;
        if (!rarityKey) {
            const r = Math.random();
            rarityKey = pickRarity(r);
        }
        const rarity = RARITY[rarityKey];

        const floorMult = 1 + (floor - 1) * 0.2;
        const item = {
            typeKey, typeInfo, rarityKey, rarity,
            icon: typeInfo.icon,
            affixes: [],
            baseDmg: typeInfo.baseDmg ? [Math.round(typeInfo.baseDmg[0] * rarity.mult * floorMult), Math.round(typeInfo.baseDmg[1] * rarity.mult * floorMult)] : null,
            baseDef: typeInfo.baseDef ? Math.round((typeInfo.baseDef[0] + rand(0, typeInfo.baseDef[1] - typeInfo.baseDef[0])) * rarity.mult * floorMult) : null,
        };

        // Name
        if (rarityKey === 'unique' && UNIQUE_NAMES[typeKey]) {
            const names = UNIQUE_NAMES[typeKey];
            item.name = names[rand(0, names.length - 1)];
        } else {
            const prefixes = ['å‘ªã‚ã‚Œã—', 'è–ãªã‚‹', 'å¤ä»£ã®', 'é›ãˆã‚‰ã‚Œã—', 'æœ½ã¡ãŸ', 'è¼ã', 'è¡€æŸ“ã‚ã®', 'å½±ã®', 'è’¼ã', 'ç¼ç†±ã®'];
            const prefix = rarityKey !== 'common' ? prefixes[rand(0, prefixes.length-1)] + ' ' : '';
            item.name = prefix + typeInfo.name;
        }

        // Generate affixes
        const affixCount = getAffixCount(rarity);
        const pool = [...AFFIXES];
        for (let i = 0; i < affixCount && pool.length > 0; i++) {
            const idx = rand(0, pool.length - 1);
            const a = pool.splice(idx, 1)[0];
            const v = Math.round(rand(a.min, a.max) * floorMult);
            item.affixes.push({ stat: a.stat, value: v, text: a.fmt.replace('{v}', v) });
        }

        return item;
    }

    function generatePotion() {
        return {
            typeKey: 'potion', typeInfo: ITEM_TYPES.potion, rarityKey: 'common',
            rarity: RARITY.common, icon: 'ğŸ§ª', name: 'å›å¾©è–¬',
            affixes: [], baseDmg: null, baseDef: null
        };
    }

    // ========== CLASS DEFINITIONS ==========
    const CLASS_DEFS = {
        warrior: {
            name: 'ãƒãƒ¼ãƒãƒªã‚¢ãƒ³',
            icon: 'âš”',
            engName: 'Barbarian',
            tier: 0,
            sprite: 'knight',
            baseStr: 20,
            baseDex: 10,
            baseVit: 20,
            baseInt: 5,
            branches: ['ã‚³ãƒ³ãƒãƒƒãƒˆã‚¹ã‚­ãƒ«', 'ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤', 'ãƒã‚¹ã‚¿ãƒªãƒ¼'],
            promotions: ['paladin', 'berserker'],
            skills: [
                // Branch 0: ã‚³ãƒ³ãƒãƒƒãƒˆã‚¹ã‚­ãƒ«
                { id: 'w_bash', name: 'ãƒãƒƒã‚·ãƒ¥', icon: 'ğŸ’¥', mp: 8, cd: 0.8, branch: 0, desc: 'Single target burst', prereq: null, effect: 'melee_burst', baseMult: [1.8, 2.1, 2.5, 3.0, 3.6], range: 60 },
                { id: 'w_doubleswing', name: 'ãƒ€ãƒ–ãƒ«ã‚¹ã‚¤ãƒ³ã‚°', icon: 'âš”', mp: 14, cd: 1.5, branch: 0, desc: 'Whirlwind attack', prereq: 'w_bash', effect: 'whirlwind', baseMult: [1.4, 1.8, 2.2, 2.8, 3.4], range: 80 },
                { id: 'w_stun', name: 'ã‚¹ã‚¿ãƒ³', icon: 'ğŸ”¨', mp: 12, cd: 2.0, branch: 0, desc: 'Stun AoE', prereq: 'w_bash', effect: 'stun_aoe', duration: [1.2, 1.6, 2.0, 2.5, 3.0], range: 70 },
                { id: 'w_concentrate', name: 'ã‚³ãƒ³ã‚»ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆ', icon: 'ğŸ¯', mp: 18, cd: 2.0, branch: 0, desc: 'Focused burst', prereq: 'w_doubleswing', effect: 'melee_burst', baseMult: [2.2, 2.8, 3.5, 4.2, 5.0], range: 55 },
                { id: 'w_whirlwind', name: 'ãƒ¯ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰', icon: 'ğŸŒ€', mp: 30, cd: 3.0, branch: 0, desc: 'Spinning attack', prereq: 'w_concentrate', effect: 'whirlwind', baseMult: [1.6, 2.0, 2.6, 3.2, 4.0], range: 120 },
                { id: 'w_cleave', name: 'ã‚¯ãƒªãƒ¼ãƒ–', icon: 'ğŸª“', mp: 35, cd: 4.0, branch: 0, desc: 'Large cleave', prereq: 'w_whirlwind', effect: 'whirlwind', baseMult: [2.0, 2.6, 3.2, 4.0, 5.0], range: 140 },
                { id: 'w_warfrenzy', name: 'ã‚¦ã‚©ãƒ¼ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼', icon: 'ğŸ˜¤', mp: 42, cd: 8.0, branch: 0, desc: 'Attack buff', prereq: 'w_cleave', effect: 'buff_frenzy', duration: [6, 8, 10, 12, 15], atkBonus: [0.4, 0.5, 0.6, 0.8, 1.0], spdBonus: [0.2, 0.3, 0.4, 0.5, 0.6] },
                { id: 'w_furyslash', name: 'ãƒ•ãƒ¥ãƒ¼ãƒªãƒ¼ã‚¹ãƒ©ãƒƒã‚·ãƒ¥', icon: 'ğŸ’€', mp: 55, cd: 10.0, branch: 0, desc: 'Execute attack', prereq: 'w_warfrenzy', effect: 'execute', baseMult: [4.0, 5.0, 6.5, 8.0, 10.0], threshold: [0.4, 0.5, 0.55, 0.6, 0.7], range: 70 },
                // Branch 1: ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤
                { id: 'w_howl', name: 'ãƒã‚¦ãƒ«', icon: 'ğŸ“¯', mp: 10, cd: 4.0, branch: 1, desc: 'Stun shout', prereq: null, effect: 'stun_aoe', duration: [1.2, 1.6, 2.0, 2.5, 3.0], range: 120 },
                { id: 'w_taunt', name: 'ã‚¿ã‚¦ãƒ³ãƒˆ', icon: 'ğŸ˜¡', mp: 12, cd: 5.0, branch: 1, desc: 'Debuff defense', prereq: 'w_howl', effect: 'debuff_defense', duration: [3, 4, 5, 6, 8], reduction: [0.2, 0.3, 0.4, 0.5, 0.6], range: 130 },
                { id: 'w_shout', name: 'ã‚·ãƒ£ã‚¦ãƒˆ', icon: 'ğŸ›¡', mp: 18, cd: 6.0, branch: 1, desc: 'Defense buff', prereq: 'w_howl', effect: 'buff_defense', duration: [5, 7, 9, 11, 14], reduction: [0.3, 0.4, 0.5, 0.6, 0.7] },
                { id: 'w_finditem', name: 'ãƒ•ã‚¡ã‚¤ãƒ³ãƒ‰ã‚¢ã‚¤ãƒ†ãƒ ', icon: 'ğŸ’', mp: 15, cd: 8.0, branch: 1, desc: 'Crit boost', prereq: 'w_taunt', effect: 'buff_crit', duration: [5, 7, 9, 12, 15], bonus: [10, 15, 20, 30, 40] },
                { id: 'w_battleorders', name: 'ãƒãƒˆãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼', icon: 'âšœ', mp: 35, cd: 12.0, branch: 1, desc: 'Battle orders', prereq: 'w_shout', effect: 'battle_orders', duration: [8, 12, 15, 18, 22], bonus: [0.15, 0.2, 0.3, 0.4, 0.5] },
                { id: 'w_grimward', name: 'ã‚°ãƒªãƒ ã‚¦ã‚©ãƒ¼ãƒ‰', icon: 'â˜ ', mp: 40, cd: 10.0, branch: 1, desc: 'Stun shout', prereq: 'w_battleorders', effect: 'stun_aoe', duration: [2.0, 2.5, 3.0, 3.5, 4.5], range: 160 },
                { id: 'w_warcrylv2', name: 'ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤II', icon: 'ğŸ“£', mp: 48, cd: 12.0, branch: 1, desc: 'Enhanced stun', prereq: 'w_grimward', effect: 'stun_aoe', duration: [2.5, 3.0, 3.5, 4.0, 5.0], range: 180 },
                { id: 'w_naturalorder', name: 'ãƒŠãƒãƒ¥ãƒ©ãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼', icon: 'âšœ', mp: 55, cd: 18.0, branch: 1, desc: 'Ultimate orders', prereq: 'w_warcrylv2', effect: 'battle_orders', duration: [12, 16, 20, 25, 30], bonus: [0.25, 0.35, 0.45, 0.55, 0.7] },
                // Branch 2: ãƒã‚¹ã‚¿ãƒªãƒ¼
                { id: 'w_leap', name: 'ãƒªãƒ¼ãƒ—ã‚¢ã‚¿ãƒƒã‚¯', icon: 'ğŸ¦˜', mp: 12, cd: 3.0, branch: 2, desc: 'Leap charge', prereq: null, effect: 'charge', baseMult: [1.8, 2.2, 2.8, 3.5, 4.2], range: 200 },
                { id: 'w_stomp', name: 'ã‚¹ãƒˆãƒ³ãƒ—', icon: 'ğŸ‘¢', mp: 15, cd: 4.0, branch: 2, desc: 'Ground slam', prereq: 'w_leap', effect: 'ground_slam', baseMult: [1.5, 2.0, 2.5, 3.0, 3.8], range: 100, slow: [0.5, 0.45, 0.4, 0.35, 0.3] },
                { id: 'w_ironskin', name: 'ã‚¢ã‚¤ã‚¢ãƒ³ã‚¹ã‚­ãƒ³', icon: 'ğŸ”°', mp: 22, cd: 10.0, branch: 2, desc: 'Defense buff', prereq: 'w_leap', effect: 'buff_defense', duration: [6, 8, 10, 12, 15], reduction: [0.4, 0.5, 0.55, 0.6, 0.7] },
                { id: 'w_naturalres', name: 'ãƒŠãƒãƒ¥ãƒ©ãƒ«ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ³ã‚¹', icon: 'ğŸ’ª', mp: 25, cd: 12.0, branch: 2, desc: 'Defense boost', prereq: 'w_ironskin', effect: 'buff_defense', duration: [8, 10, 12, 14, 18], reduction: [0.45, 0.55, 0.6, 0.65, 0.75] },
                { id: 'w_berserk', name: 'ãƒãƒ¼ã‚µãƒ¼ã‚¯', icon: 'ğŸ‘¹', mp: 35, cd: 10.0, branch: 2, desc: 'Berserk mode', prereq: 'w_naturalres', effect: 'buff_berserk', duration: [6, 8, 10, 12, 16] },
                { id: 'w_increasedspeed', name: 'ã‚¤ãƒ³ã‚¯ãƒªãƒ¼ã‚¹ãƒ‰ã‚¹ãƒ”ãƒ¼ãƒ‰', icon: 'ğŸ’¨', mp: 28, cd: 10.0, branch: 2, desc: 'Speed boost', prereq: 'w_stomp', effect: 'buff_speed', duration: [6, 8, 10, 12, 15], bonus: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'w_swordmastery', name: 'ã‚½ãƒ¼ãƒ‰ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'âš”', mp: 35, cd: 12.0, branch: 2, desc: 'Attack speed', prereq: 'w_increasedspeed', effect: 'buff_atkspd', duration: [6, 8, 10, 12, 16], bonus: [0.4, 0.5, 0.6, 0.8, 1.0] },
                { id: 'w_ironfist', name: 'ã‚¢ã‚¤ã‚¢ãƒ³ãƒ•ã‚£ã‚¹ãƒˆ', icon: 'ğŸ¤œ', mp: 55, cd: 12.0, branch: 2, desc: 'Ultimate punch', prereq: 'w_swordmastery', effect: 'melee_burst', baseMult: [5.0, 6.5, 8.0, 10.0, 13.0], range: 65 }
            ]
        },
        rogue: {
            name: 'ã‚¢ãƒã‚¾ãƒ³',
            icon: 'ğŸ¹',
            engName: 'Rogue',
            tier: 0,
            sprite: 'rogueChar',
            baseStr: 10,
            baseDex: 20,
            baseVit: 15,
            baseInt: 10,
            branches: ['å¼“ã‚¹ã‚­ãƒ«', 'ã‚¸ãƒ£ãƒ™ãƒªãƒ³', 'ãƒ‘ãƒƒã‚·ãƒ–'],
            promotions: ['assassin', 'ranger'],
            skills: [
                // Branch 0: å¼“ã‚¹ã‚­ãƒ«
                { id: 'r_firearrow', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ”¥', mp: 8, cd: 0.8, branch: 0, desc: 'Fire arrow', prereq: null, effect: 'projectile_fire', baseMult: [1.6, 1.9, 2.2, 2.6, 3.2], speed: 400 },
                { id: 'r_coldarrow', name: 'ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¢ãƒ­ãƒ¼', icon: 'â„', mp: 10, cd: 1.2, branch: 0, desc: 'Cold arrow', prereq: 'r_firearrow', effect: 'projectile_fire', baseMult: [1.4, 1.7, 2.0, 2.4, 3.0], speed: 380 },
                { id: 'r_multishot', name: 'ãƒãƒ«ãƒãƒ—ãƒ«ã‚·ãƒ§ãƒƒãƒˆ', icon: 'ğŸŒŸ', mp: 22, cd: 2.5, branch: 0, desc: 'Multi arrows', prereq: 'r_coldarrow', effect: 'multi_shot', arrows: [3, 4, 5, 6, 8], baseMult: [1.0, 1.3, 1.6, 2.0, 2.5] },
                { id: 'r_guidedarrow', name: 'ã‚¬ã‚¤ãƒ‡ãƒƒãƒ‰ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ¯', mp: 18, cd: 1.5, branch: 0, desc: 'Guided shot', prereq: 'r_firearrow', effect: 'projectile_fire', baseMult: [2.2, 2.8, 3.5, 4.2, 5.0], speed: 500 },
                { id: 'r_strafe', name: 'ã‚¹ãƒˆãƒ¬ã‚¤ãƒ•', icon: 'ğŸ¹', mp: 35, cd: 5.0, branch: 0, desc: 'Arrow barrage', prereq: 'r_multishot', effect: 'arrow_rain', baseMult: [2.0, 2.6, 3.2, 4.0, 5.0], range: 100 },
                { id: 'r_immolation', name: 'ã‚¤ãƒ¢ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ”¥', mp: 40, cd: 6.0, branch: 0, desc: 'Fire rain', prereq: 'r_strafe', effect: 'arrow_rain', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], range: 110 },
                { id: 'r_freezingarrow', name: 'ãƒ•ãƒªãƒ¼ã‚¸ãƒ³ã‚°ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ§Š', mp: 45, cd: 7.0, branch: 0, desc: 'Freeze arrows', prereq: 'r_immolation', effect: 'frost_nova', baseMult: [2.0, 2.8, 3.5, 4.5, 6.0], freeze: [2, 3, 4, 5, 6] },
                { id: 'r_magicarrow', name: 'ãƒã‚¸ãƒƒã‚¯ã‚¢ãƒ­ãƒ¼', icon: 'âœ¨', mp: 55, cd: 8.0, branch: 0, desc: 'Magic arrow', prereq: 'r_freezingarrow', effect: 'projectile_fire', baseMult: [4.0, 5.0, 6.5, 8.0, 10.0], speed: 550 },
                // Branch 1: ã‚¸ãƒ£ãƒ™ãƒªãƒ³
                { id: 'r_jab', name: 'ã‚¸ãƒ£ãƒ–', icon: 'ğŸ”±', mp: 8, cd: 1.0, branch: 1, desc: 'Quick jab', prereq: null, effect: 'melee_burst', baseMult: [1.8, 2.1, 2.5, 3.0, 3.6], range: 55 },
                { id: 'r_poisonjav', name: 'ãƒã‚¤ã‚ºãƒ³ã‚¸ãƒ£ãƒ™ãƒªãƒ³', icon: 'â˜ ', mp: 14, cd: 3.0, branch: 1, desc: 'Poison javelin', prereq: 'r_jab', effect: 'buff_poison', duration: [4, 5, 6, 8, 10], dps: [5, 8, 12, 18, 25] },
                { id: 'r_powerstrike', name: 'ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'âš¡', mp: 18, cd: 2.5, branch: 1, desc: 'Power strike', prereq: 'r_jab', effect: 'melee_burst', baseMult: [2.5, 3.0, 3.8, 4.5, 5.5], range: 60 },
                { id: 'r_chargedstrike', name: 'ãƒãƒ£ãƒ¼ã‚¸ãƒ‰ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸŒ©', mp: 25, cd: 3.0, branch: 1, desc: 'Chain lightning', prereq: 'r_powerstrike', effect: 'chain_lightning', bounces: [2, 3, 4, 5, 6], baseMult: [1.8, 2.2, 2.8, 3.5, 4.5] },
                { id: 'r_plaguejav', name: 'ãƒ—ãƒ¬ã‚¤ã‚°ã‚¸ãƒ£ãƒ™ãƒªãƒ³', icon: 'ğŸ’š', mp: 30, cd: 5.0, branch: 1, desc: 'Plague javelin', prereq: 'r_poisonjav', effect: 'consecrate', baseMult: [0.6, 0.8, 1.0, 1.3, 1.6], range: 90, duration: [4, 5, 6, 8, 10] },
                { id: 'r_fend', name: 'ãƒ•ã‚§ãƒ³ãƒ‰', icon: 'ğŸ”±', mp: 35, cd: 4.0, branch: 1, desc: 'Spinning attack', prereq: 'r_chargedstrike', effect: 'whirlwind', baseMult: [1.6, 2.0, 2.5, 3.2, 4.0], range: 85 },
                { id: 'r_ltfury', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ãƒ•ãƒ¥ãƒ¼ãƒªãƒ¼', icon: 'ğŸŒ©', mp: 45, cd: 6.0, branch: 1, desc: 'Lightning fury', prereq: 'r_fend', effect: 'chain_lightning', bounces: [3, 4, 5, 6, 8], baseMult: [2.0, 2.8, 3.5, 4.5, 6.0] },
                { id: 'r_lightningstrike', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'âš¡', mp: 55, cd: 8.0, branch: 1, desc: 'Lightning strike', prereq: 'r_ltfury', effect: 'melee_burst', baseMult: [4.0, 5.5, 7.0, 9.0, 12.0], range: 65 },
                // Branch 2: ãƒ‘ãƒƒã‚·ãƒ–
                { id: 'r_innersight', name: 'ã‚¤ãƒ³ãƒŠãƒ¼ã‚µã‚¤ãƒˆ', icon: 'ğŸ‘', mp: 12, cd: 6.0, branch: 2, desc: 'Debuff armor', prereq: null, effect: 'debuff_defense', duration: [4, 5, 6, 8, 10], reduction: [0.2, 0.3, 0.4, 0.5, 0.6], range: 150 },
                { id: 'r_slowmissiles', name: 'ã‚¹ãƒ­ãƒ¼ãƒŸã‚µã‚¤ãƒ«', icon: 'ğŸ•¸', mp: 15, cd: 6.0, branch: 2, desc: 'Slow aura', prereq: 'r_innersight', effect: 'stun_aoe', duration: [1.5, 2.0, 2.5, 3.0, 4.0], range: 130 },
                { id: 'r_dodge', name: 'ãƒ‰ãƒƒã‚¸', icon: 'ğŸ’¨', mp: 18, cd: 10.0, branch: 2, desc: 'Dodge chance', prereq: 'r_innersight', effect: 'buff_dodge', duration: [5, 7, 9, 12, 15], chance: [30, 40, 50, 60, 75] },
                { id: 'r_avoid', name: 'ã‚¢ãƒ´ã‚©ã‚¤ãƒ‰', icon: 'ğŸŒ€', mp: 22, cd: 10.0, branch: 2, desc: 'Avoid attacks', prereq: 'r_dodge', effect: 'buff_dodge', duration: [6, 8, 10, 13, 16], chance: [35, 45, 55, 65, 80] },
                { id: 'r_critstrike', name: 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸ’', mp: 20, cd: 10.0, branch: 2, desc: 'Crit boost', prereq: 'r_slowmissiles', effect: 'buff_crit', duration: [5, 7, 9, 12, 15], bonus: [15, 22, 30, 40, 55] },
                { id: 'r_evade', name: 'ã‚¤ãƒ´ã‚§ã‚¤ãƒ‰', icon: 'ğŸŒŠ', mp: 28, cd: 12.0, branch: 2, desc: 'Evasion', prereq: 'r_avoid', effect: 'buff_speed', duration: [5, 7, 9, 12, 15], bonus: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'r_penetrate', name: 'ãƒšãƒãƒˆãƒ¬ã‚¤ãƒˆ', icon: 'ğŸ¯', mp: 30, cd: 12.0, branch: 2, desc: 'Pierce armor', prereq: 'r_critstrike', effect: 'buff_crit', duration: [6, 8, 10, 14, 18], bonus: [20, 30, 40, 55, 70] },
                { id: 'r_valkyrie', name: 'ãƒ´ã‚¡ãƒ«ã‚­ãƒªãƒ¼', icon: 'ğŸ›¡', mp: 55, cd: 20.0, branch: 2, desc: 'Summon valkyrie', prereq: 'r_penetrate', effect: 'summon_minion', duration: [10, 14, 18, 22, 28], minionHP: [150, 250, 350, 500, 700], minionDmg: [12, 20, 30, 42, 60] }
            ]
        },
        sorcerer: {
            name: 'ã‚½ãƒ¼ã‚µãƒ¬ã‚¹',
            icon: 'âœ¨',
            engName: 'Sorcerer',
            tier: 0,
            sprite: 'wizardM',
            baseStr: 5,
            baseDex: 10,
            baseVit: 10,
            baseInt: 25,
            branches: ['ãƒ•ã‚¡ã‚¤ã‚¢ã‚¹ãƒšãƒ«', 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°', 'ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒšãƒ«'],
            promotions: ['pyromancer', 'cryomancer'],
            skills: [
                // Branch 0: ãƒ•ã‚¡ã‚¤ã‚¢ã‚¹ãƒšãƒ«
                { id: 's_firebolt', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ«ãƒˆ', icon: 'ğŸ”¥', mp: 6, cd: 0.5, branch: 0, desc: 'Fire bolt', prereq: null, effect: 'projectile_fire', baseMult: [1.4, 1.7, 2.0, 2.4, 3.0], speed: 350 },
                { id: 's_warmth', name: 'ã‚¦ã‚©ãƒ¼ãƒ ã‚¹', icon: 'ğŸŒ¡', mp: 12, cd: 10.0, branch: 0, desc: 'Warmth aura', prereq: 's_firebolt', effect: 'buff_aura', duration: [8, 10, 12, 15, 20], regen: [3, 5, 8, 12, 16], reduction: [0.1, 0.15, 0.2, 0.25, 0.3] },
                { id: 's_fireball', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ«', icon: 'â˜€', mp: 18, cd: 1.5, branch: 0, desc: 'Fireball', prereq: 's_firebolt', effect: 'projectile_fire', baseMult: [2.2, 2.8, 3.5, 4.2, 5.5], speed: 320 },
                { id: 's_firewall', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«', icon: 'ğŸ§±', mp: 25, cd: 5.0, branch: 0, desc: 'Wall of fire', prereq: 's_fireball', effect: 'consecrate', baseMult: [0.6, 0.8, 1.0, 1.3, 1.6], range: 80, duration: [3, 4, 5, 6, 8] },
                { id: 's_enchant', name: 'ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆ', icon: 'âœ¨', mp: 28, cd: 12.0, branch: 0, desc: 'Fire enchant', prereq: 's_warmth', effect: 'buff_berserk', duration: [6, 8, 10, 12, 16] },
                { id: 's_meteor', name: 'ãƒ¡ãƒ†ã‚ª', icon: 'â˜„', mp: 45, cd: 8.0, branch: 0, desc: 'Meteor strike', prereq: 's_firewall', effect: 'meteor', baseMult: [3.0, 4.0, 5.0, 6.5, 8.5], range: 110 },
                { id: 's_hydra', name: 'ãƒ’ãƒ‰ãƒ©', icon: 'ğŸ', mp: 50, cd: 8.0, branch: 0, desc: 'Hydra spell', prereq: 's_enchant', effect: 'consecrate', baseMult: [0.8, 1.0, 1.3, 1.6, 2.0], range: 100, duration: [5, 7, 9, 12, 15] },
                { id: 's_firemastery', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'ğŸ”¥', mp: 55, cd: 15.0, branch: 0, desc: 'Fire mastery', prereq: 's_meteor', effect: 'buff_atkspd', duration: [8, 10, 12, 15, 20], bonus: [0.4, 0.5, 0.6, 0.8, 1.0] },
                // Branch 1: ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°
                { id: 's_chargedbolt', name: 'ãƒãƒ£ãƒ¼ã‚¸ãƒ‰ãƒœãƒ«ãƒˆ', icon: 'âš¡', mp: 8, cd: 1.0, branch: 1, desc: 'Charged bolts', prereq: null, effect: 'multi_shot', arrows: [3, 3, 4, 5, 6], baseMult: [1.0, 1.3, 1.6, 2.0, 2.5] },
                { id: 's_staticfield', name: 'ã‚¹ã‚¿ãƒ†ã‚£ãƒƒã‚¯ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰', icon: 'ğŸ”µ', mp: 14, cd: 4.0, branch: 1, desc: 'Static field', prereq: 's_chargedbolt', effect: 'debuff_defense', duration: [3, 4, 5, 6, 8], reduction: [0.2, 0.3, 0.35, 0.4, 0.5], range: 120 },
                { id: 's_teleport', name: 'ãƒ†ãƒ¬ãƒãƒ¼ãƒˆ', icon: 'ğŸŒ€', mp: 16, cd: 2.5, branch: 1, desc: 'Teleport', prereq: 's_chargedbolt', effect: 'teleport', range: [180, 220, 260, 320, 400] },
                { id: 's_lightning', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°', icon: 'ğŸŒ©', mp: 22, cd: 2.0, branch: 1, desc: 'Lightning', prereq: 's_staticfield', effect: 'chain_lightning', bounces: [2, 3, 3, 4, 5], baseMult: [1.6, 2.0, 2.5, 3.2, 4.2] },
                { id: 's_nova', name: 'ãƒãƒ´ã‚¡', icon: 'ğŸ’«', mp: 30, cd: 4.0, branch: 1, desc: 'Nova burst', prereq: 's_lightning', effect: 'frost_nova', baseMult: [1.5, 2.0, 2.5, 3.2, 4.0], freeze: [1, 1, 2, 2, 3] },
                { id: 's_energyshield', name: 'ã‚¨ãƒŠã‚¸ãƒ¼ã‚·ãƒ¼ãƒ«ãƒ‰', icon: 'ğŸ”·', mp: 35, cd: 12.0, branch: 1, desc: 'Energy shield', prereq: 's_teleport', effect: 'mana_shield', duration: [5, 7, 9, 12, 16], absorb: [0.4, 0.5, 0.6, 0.7, 0.8] },
                { id: 's_ltgmastery', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'âš¡', mp: 40, cd: 12.0, branch: 1, desc: 'Lightning mastery', prereq: 's_nova', effect: 'buff_atkspd', duration: [6, 8, 10, 14, 18], bonus: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 's_thunderstorm', name: 'ã‚µãƒ³ãƒ€ãƒ¼ã‚¹ãƒˆãƒ¼ãƒ ', icon: 'â›ˆ', mp: 55, cd: 10.0, branch: 1, desc: 'Thunder storm', prereq: 's_ltgmastery', effect: 'consecrate', baseMult: [1.0, 1.4, 1.8, 2.4, 3.2], range: 120, duration: [6, 8, 10, 13, 16] },
                // Branch 2: ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒšãƒ«
                { id: 's_icebolt', name: 'ã‚¢ã‚¤ã‚¹ãƒœãƒ«ãƒˆ', icon: 'ğŸ”·', mp: 6, cd: 0.8, branch: 2, desc: 'Ice bolt', prereq: null, effect: 'projectile_fire', baseMult: [1.2, 1.5, 1.8, 2.2, 2.8], speed: 380 },
                { id: 's_frozenarmor', name: 'ãƒ•ãƒ­ãƒ¼ã‚ºãƒ³ã‚¢ãƒ¼ãƒãƒ¼', icon: 'ğŸ›¡', mp: 15, cd: 10.0, branch: 2, desc: 'Frozen armor', prereq: 's_icebolt', effect: 'buff_defense', duration: [6, 8, 10, 12, 16], reduction: [0.3, 0.4, 0.45, 0.5, 0.6] },
                { id: 's_frostnova', name: 'ãƒ•ãƒ­ã‚¹ãƒˆãƒãƒ´ã‚¡', icon: 'â„', mp: 18, cd: 4.0, branch: 2, desc: 'Frost nova', prereq: 's_icebolt', effect: 'frost_nova', baseMult: [0.8, 1.0, 1.4, 1.8, 2.4], freeze: [2, 2, 3, 4, 5] },
                { id: 's_glacialspike', name: 'ã‚°ãƒ¬ã‚¤ã‚·ãƒ£ãƒ«ã‚¹ãƒ‘ã‚¤ã‚¯', icon: 'ğŸ§Š', mp: 22, cd: 3.0, branch: 2, desc: 'Glacial spike', prereq: 's_frostnova', effect: 'frost_nova', baseMult: [1.5, 2.0, 2.5, 3.2, 4.0], freeze: [2, 3, 3, 4, 5] },
                { id: 's_shiverarmor', name: 'ã‚·ãƒ´ã‚¡ãƒ¼ã‚¢ãƒ¼ãƒãƒ¼', icon: 'ğŸª', mp: 25, cd: 8.0, branch: 2, desc: 'Shiver armor', prereq: 's_frozenarmor', effect: 'buff_counter', duration: [5, 7, 9, 11, 14], reflect: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 's_blizzard', name: 'ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰', icon: 'ğŸŒ¨', mp: 40, cd: 7.0, branch: 2, desc: 'Blizzard', prereq: 's_glacialspike', effect: 'arrow_rain', baseMult: [2.2, 2.8, 3.5, 4.5, 6.0], range: 120 },
                { id: 's_coldmastery', name: 'ã‚³ãƒ¼ãƒ«ãƒ‰ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'ğŸ¥¶', mp: 35, cd: 10.0, branch: 2, desc: 'Cold mastery', prereq: 's_blizzard', effect: 'debuff_defense', duration: [4, 6, 8, 10, 13], reduction: [0.3, 0.4, 0.5, 0.6, 0.7], range: 140 },
                { id: 's_frozenorb', name: 'ãƒ•ãƒ­ãƒ¼ã‚ºãƒ³ã‚ªãƒ¼ãƒ–', icon: 'ğŸŒ', mp: 55, cd: 8.0, branch: 2, desc: 'Frozen orb', prereq: 's_coldmastery', effect: 'frozen_orb', baseMult: [2.5, 3.5, 4.5, 6.0, 8.0], speed: 200, shardCount: [5, 6, 8, 10, 12] }
            ]
        },
        paladin: {
            name: 'ãƒ‘ãƒ©ãƒ‡ã‚£ãƒ³',
            icon: 'âœ',
            engName: 'Paladin',
            tier: 1,
            baseClass: 'warrior',
            sprite: 'paladin',
            baseStr: 22,
            baseDex: 10,
            baseVit: 25,
            baseInt: 8,
            branches: ['ã‚³ãƒ³ãƒãƒƒãƒˆ', 'ã‚ªãƒ•ã‚§ãƒ³ã‚¹ã‚ªãƒ¼ãƒ©', 'ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ã‚ªãƒ¼ãƒ©'],
            promotions: [],
            skills: [
                // Branch 0: ã‚³ãƒ³ãƒãƒƒãƒˆ
                { id: 'p_sacrifice', name: 'ã‚µã‚¯ãƒªãƒ•ã‚¡ã‚¤ã‚¹', icon: 'ğŸ’‰', mp: 8, cd: 1.0, branch: 0, desc: 'Sacrifice', prereq: null, effect: 'melee_burst', baseMult: [2.0, 2.5, 3.0, 3.8, 4.5], range: 55 },
                { id: 'p_smite', name: 'ã‚¹ãƒã‚¤ãƒˆ', icon: 'âœ', mp: 12, cd: 1.5, branch: 0, desc: 'Smite', prereq: 'p_sacrifice', effect: 'melee_burst', baseMult: [2.2, 2.8, 3.5, 4.2, 5.0], range: 60 },
                { id: 'p_charge', name: 'ãƒãƒ£ãƒ¼ã‚¸', icon: 'ğŸ', mp: 15, cd: 3.0, branch: 0, desc: 'Charge', prereq: 'p_sacrifice', effect: 'charge', baseMult: [2.0, 2.5, 3.2, 4.0, 5.0], range: 250 },
                { id: 'p_zeal', name: 'ã‚¸ãƒ¼ãƒ«', icon: 'âš”', mp: 22, cd: 6.0, branch: 0, desc: 'Zeal', prereq: 'p_smite', effect: 'buff_atkspd', duration: [4, 6, 8, 10, 13], bonus: [0.4, 0.5, 0.6, 0.8, 1.0] },
                { id: 'p_vengeance', name: 'ãƒ´ã‚§ãƒ³ã‚¸ã‚§ãƒ³ã‚¹', icon: 'ğŸ—¡', mp: 28, cd: 3.0, branch: 0, desc: 'Vengeance', prereq: 'p_zeal', effect: 'melee_burst', baseMult: [3.0, 3.8, 4.5, 5.5, 7.0], range: 60 },
                { id: 'p_conversion', name: 'ã‚³ãƒ³ãƒãƒ¼ã‚¸ãƒ§ãƒ³', icon: 'ğŸ™', mp: 35, cd: 8.0, branch: 0, desc: 'Conversion heal', prereq: 'p_vengeance', effect: 'self_heal_pct', pct: [0.15, 0.2, 0.25, 0.3, 0.4] },
                { id: 'p_blessedhammer', name: 'ãƒ–ãƒ¬ã‚¹ãƒ‰ãƒãƒ³ãƒãƒ¼', icon: 'ğŸ”¨', mp: 42, cd: 4.0, branch: 0, desc: 'Blessed hammer', prereq: 'p_conversion', effect: 'holy_burst', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], range: 140 },
                { id: 'p_fistofheavens', name: 'ãƒ•ã‚£ã‚¹ãƒˆã‚ªãƒ–ãƒ˜ãƒ´ãƒ³', icon: 'ğŸŒŸ', mp: 55, cd: 8.0, branch: 0, desc: 'Fist of heavens', prereq: 'p_blessedhammer', effect: 'meteor', baseMult: [4.0, 5.0, 6.5, 8.0, 10.5], range: 130 },
                // Branch 1: ã‚ªãƒ•ã‚§ãƒ³ã‚¹ã‚ªãƒ¼ãƒ©
                { id: 'p_might', name: 'ãƒã‚¤ãƒˆ', icon: 'ğŸ’ª', mp: 12, cd: 8.0, branch: 1, desc: 'Might aura', prereq: null, effect: 'buff_berserk', duration: [6, 8, 10, 12, 16] },
                { id: 'p_holyfire', name: 'ãƒ›ãƒ¼ãƒªãƒ¼ãƒ•ã‚¡ã‚¤ã‚¢', icon: 'ğŸ”¥', mp: 18, cd: 6.0, branch: 1, desc: 'Holy fire', prereq: 'p_might', effect: 'consecrate', baseMult: [0.5, 0.7, 0.9, 1.2, 1.5], range: 90, duration: [3, 4, 5, 6, 8] },
                { id: 'p_thorns', name: 'ã‚½ãƒ¼ãƒ³ã‚º', icon: 'ğŸŒ¹', mp: 20, cd: 8.0, branch: 1, desc: 'Thorns aura', prereq: 'p_might', effect: 'buff_counter', duration: [5, 7, 9, 11, 14], reflect: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'p_holyshock', name: 'ãƒ›ãƒ¼ãƒªãƒ¼ã‚·ãƒ§ãƒƒã‚¯', icon: 'âš¡', mp: 25, cd: 5.0, branch: 1, desc: 'Holy shock', prereq: 'p_holyfire', effect: 'chain_lightning', bounces: [2, 3, 3, 4, 5], baseMult: [1.5, 2.0, 2.5, 3.2, 4.0] },
                { id: 'p_sanctuary', name: 'ã‚µãƒ³ã‚¯ãƒãƒ¥ã‚¢ãƒª', icon: 'ğŸ›', mp: 30, cd: 6.0, branch: 1, desc: 'Sanctuary', prereq: 'p_holyshock', effect: 'holy_burst', baseMult: [1.8, 2.2, 2.8, 3.5, 4.5], range: 120 },
                { id: 'p_conviction', name: 'ã‚³ãƒ³ãƒ´ã‚£ã‚¯ã‚·ãƒ§ãƒ³', icon: 'ğŸ‘', mp: 35, cd: 10.0, branch: 1, desc: 'Conviction', prereq: 'p_sanctuary', effect: 'debuff_defense', duration: [5, 7, 9, 12, 15], reduction: [0.3, 0.4, 0.5, 0.6, 0.7], range: 160 },
                { id: 'p_fanaticism', name: 'ãƒ•ã‚¡ãƒŠãƒ†ã‚£ã‚·ã‚ºãƒ ', icon: 'ğŸ”±', mp: 42, cd: 12.0, branch: 1, desc: 'Fanaticism', prereq: 'p_conviction', effect: 'buff_frenzy', duration: [6, 8, 10, 13, 16], atkBonus: [0.4, 0.5, 0.6, 0.8, 1.0], spdBonus: [0.2, 0.3, 0.4, 0.5, 0.6] },
                { id: 'p_holyfreeze', name: 'ãƒ›ãƒ¼ãƒªãƒ¼ãƒ•ãƒªãƒ¼ã‚º', icon: 'â„', mp: 50, cd: 8.0, branch: 1, desc: 'Holy freeze', prereq: 'p_fanaticism', effect: 'frost_nova', baseMult: [2.0, 2.8, 3.5, 4.5, 6.0], freeze: [2, 3, 4, 5, 6] },
                // Branch 2: ãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹ã‚ªãƒ¼ãƒ©
                { id: 'p_prayer', name: 'ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼', icon: 'ğŸ’š', mp: 12, cd: 8.0, branch: 2, desc: 'Prayer', prereq: null, effect: 'self_heal_pct', pct: [0.15, 0.2, 0.25, 0.3, 0.4] },
                { id: 'p_cleansing', name: 'ã‚¯ãƒ¬ãƒ³ã‚¸ãƒ³ã‚°', icon: 'ğŸ’§', mp: 15, cd: 8.0, branch: 2, desc: 'Cleansing', prereq: 'p_prayer', effect: 'self_heal_pct', pct: [0.18, 0.22, 0.28, 0.35, 0.45] },
                { id: 'p_defiance', name: 'ãƒ‡ã‚£ãƒ•ã‚¡ã‚¤ã‚¢ãƒ³ã‚¹', icon: 'ğŸ›¡', mp: 18, cd: 8.0, branch: 2, desc: 'Defiance', prereq: 'p_prayer', effect: 'buff_defense', duration: [5, 7, 9, 12, 15], reduction: [0.35, 0.45, 0.55, 0.6, 0.7] },
                { id: 'p_vigor', name: 'ãƒ´ã‚£ã‚¬ãƒ¼', icon: 'ğŸƒ', mp: 20, cd: 10.0, branch: 2, desc: 'Vigor', prereq: 'p_cleansing', effect: 'buff_speed', duration: [6, 8, 10, 12, 16], bonus: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'p_meditation', name: 'ãƒ¡ãƒ‡ã‚£ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³', icon: 'ğŸ§˜', mp: 25, cd: 10.0, branch: 2, desc: 'Meditation', prereq: 'p_vigor', effect: 'buff_aura', duration: [6, 8, 10, 14, 18], regen: [4, 6, 8, 12, 16], reduction: [0.15, 0.2, 0.25, 0.3, 0.4] },
                { id: 'p_redemption', name: 'ãƒªãƒ‡ãƒ³ãƒ—ã‚·ãƒ§ãƒ³', icon: 'ğŸŒŸ', mp: 30, cd: 12.0, branch: 2, desc: 'Redemption', prereq: 'p_meditation', effect: 'self_heal_pct', pct: [0.25, 0.3, 0.35, 0.4, 0.5] },
                { id: 'p_resist', name: 'ãƒ¬ã‚¸ã‚¹ãƒˆ', icon: 'ğŸ”°', mp: 35, cd: 12.0, branch: 2, desc: 'Resist', prereq: 'p_defiance', effect: 'buff_defense', duration: [8, 10, 12, 16, 20], reduction: [0.5, 0.55, 0.6, 0.7, 0.8] },
                { id: 'p_salvation', name: 'ã‚µãƒ«ãƒ™ãƒ¼ã‚·ãƒ§ãƒ³', icon: 'âœ¨', mp: 50, cd: 18.0, branch: 2, desc: 'Salvation', prereq: 'p_resist', effect: 'buff_aura', duration: [10, 12, 15, 20, 25], regen: [5, 8, 12, 16, 22], reduction: [0.3, 0.35, 0.4, 0.5, 0.6] }
            ]
        },
        berserker: {
            name: 'ãƒãƒ¼ã‚µãƒ¼ã‚«ãƒ¼',
            icon: 'âš”',
            engName: 'Berserker',
            tier: 1,
            baseClass: 'warrior',
            sprite: 'berserker',
            baseStr: 28,
            baseDex: 12,
            baseVit: 18,
            baseInt: 3,
            branches: ['ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼', 'ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤', 'ãƒã‚¹ã‚¿ãƒªãƒ¼'],
            promotions: [],
            skills: [
                // Branch 0: ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼
                { id: 'b_frenzy', name: 'ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼', icon: 'ğŸ˜¤', mp: 14, cd: 6.0, branch: 0, desc: 'Frenzy mode', prereq: null, effect: 'buff_frenzy', duration: [5, 7, 9, 11, 14], atkBonus: [0.4, 0.5, 0.6, 0.7, 0.9], spdBonus: [0.2, 0.3, 0.4, 0.5, 0.6] },
                { id: 'b_bash', name: 'ãƒãƒƒã‚·ãƒ¥', icon: 'ğŸ’¥', mp: 10, cd: 1.0, branch: 0, desc: 'Bash', prereq: 'b_frenzy', effect: 'melee_burst', baseMult: [2.0, 2.5, 3.0, 3.8, 4.5], range: 60 },
                { id: 'b_doubleswing', name: 'ãƒ€ãƒ–ãƒ«ã‚¹ã‚¤ãƒ³ã‚°', icon: 'âš”', mp: 16, cd: 1.5, branch: 0, desc: 'Double swing', prereq: 'b_bash', effect: 'whirlwind', baseMult: [1.6, 2.0, 2.5, 3.0, 3.8], range: 85 },
                { id: 'b_concentrate', name: 'ã‚³ãƒ³ã‚»ãƒ³ãƒˆãƒ¬ã‚¤ãƒˆ', icon: 'ğŸ¯', mp: 20, cd: 2.0, branch: 0, desc: 'Concentrate', prereq: 'b_doubleswing', effect: 'melee_burst', baseMult: [2.8, 3.5, 4.2, 5.0, 6.5], range: 55 },
                { id: 'b_whirlwind', name: 'ãƒ¯ãƒ¼ãƒ«ã‚¦ã‚£ãƒ³ãƒ‰', icon: 'ğŸŒ€', mp: 35, cd: 3.0, branch: 0, desc: 'Whirlwind', prereq: 'b_concentrate', effect: 'whirlwind', baseMult: [2.0, 2.5, 3.2, 4.0, 5.5], range: 150 },
                { id: 'b_cleave', name: 'ã‚¯ãƒªãƒ¼ãƒ–', icon: 'ğŸª“', mp: 38, cd: 4.0, branch: 0, desc: 'Cleave', prereq: 'b_whirlwind', effect: 'whirlwind', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], range: 160 },
                { id: 'b_warfrenzy', name: 'ã‚¦ã‚©ãƒ¼ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼', icon: 'ğŸ”¥', mp: 45, cd: 8.0, branch: 0, desc: 'War frenzy', prereq: 'b_cleave', effect: 'buff_frenzy', duration: [8, 10, 12, 15, 18], atkBonus: [0.6, 0.7, 0.8, 1.0, 1.2], spdBonus: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'b_executioner', name: 'ã‚¨ã‚¯ã‚»ã‚­ãƒ¥ãƒ¼ã‚·ãƒ§ãƒŠãƒ¼', icon: 'ğŸ’€', mp: 55, cd: 10.0, branch: 0, desc: 'Executioner', prereq: 'b_warfrenzy', effect: 'execute', baseMult: [5.0, 6.5, 8.0, 10.0, 13.0], threshold: [0.5, 0.55, 0.6, 0.65, 0.75], range: 70 },
                // Branch 1: ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤
                { id: 'b_warcry', name: 'ã‚¦ã‚©ãƒ¼ã‚¯ãƒ©ã‚¤', icon: 'ğŸ“¯', mp: 14, cd: 5.0, branch: 1, desc: 'War cry', prereq: null, effect: 'stun_aoe', duration: [1.5, 2.0, 2.5, 3.0, 3.5], range: 130 },
                { id: 'b_taunt', name: 'ã‚¿ã‚¦ãƒ³ãƒˆ', icon: 'ğŸ˜¡', mp: 12, cd: 5.0, branch: 1, desc: 'Taunt', prereq: 'b_warcry', effect: 'debuff_defense', duration: [3, 4, 5, 6, 8], reduction: [0.25, 0.35, 0.45, 0.55, 0.65], range: 140 },
                { id: 'b_howl', name: 'ãƒã‚¦ãƒ«', icon: 'ğŸ“£', mp: 16, cd: 6.0, branch: 1, desc: 'Howl', prereq: 'b_warcry', effect: 'stun_aoe', duration: [1.8, 2.2, 2.8, 3.5, 4.0], range: 150 },
                { id: 'b_findpotion', name: 'ãƒ•ã‚¡ã‚¤ãƒ³ãƒ‰ãƒãƒ¼ã‚·ãƒ§ãƒ³', icon: 'ğŸ§ª', mp: 15, cd: 8.0, branch: 1, desc: 'Find potion', prereq: 'b_taunt', effect: 'self_heal_pct', pct: [0.15, 0.2, 0.25, 0.3, 0.4] },
                { id: 'b_battlecmd', name: 'ãƒãƒˆãƒ«ã‚³ãƒãƒ³ãƒ‰', icon: 'ğŸ–', mp: 25, cd: 10.0, branch: 1, desc: 'Battle command', prereq: 'b_howl', effect: 'buff_atkspd', duration: [5, 7, 9, 12, 15], bonus: [0.4, 0.5, 0.6, 0.8, 1.0] },
                { id: 'b_battleorders', name: 'ãƒãƒˆãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼', icon: 'âšœ', mp: 40, cd: 15.0, branch: 1, desc: 'Battle orders', prereq: 'b_battlecmd', effect: 'battle_orders', duration: [10, 14, 18, 22, 28], bonus: [0.2, 0.3, 0.4, 0.5, 0.6] },
                { id: 'b_grimward', name: 'ã‚°ãƒªãƒ ã‚¦ã‚©ãƒ¼ãƒ‰', icon: 'â˜ ', mp: 45, cd: 10.0, branch: 1, desc: 'Grim ward', prereq: 'b_battleorders', effect: 'stun_aoe', duration: [2.5, 3.0, 3.5, 4.0, 5.0], range: 170 },
                { id: 'b_battlecommand2', name: 'ãƒãƒˆãƒ«ã‚³ãƒãƒ³ãƒ‰II', icon: 'ğŸ†', mp: 55, cd: 18.0, branch: 1, desc: 'Battle command 2', prereq: 'b_grimward', effect: 'battle_orders', duration: [12, 16, 20, 25, 32], bonus: [0.3, 0.4, 0.5, 0.6, 0.75] },
                // Branch 2: ãƒã‚¹ã‚¿ãƒªãƒ¼
                { id: 'b_leap', name: 'ãƒªãƒ¼ãƒ—ã‚¢ã‚¿ãƒƒã‚¯', icon: 'ğŸ¦˜', mp: 14, cd: 3.0, branch: 2, desc: 'Leap', prereq: null, effect: 'charge', baseMult: [2.0, 2.5, 3.0, 3.8, 4.5], range: 220 },
                { id: 'b_stomp', name: 'ã‚¹ãƒˆãƒ³ãƒ—', icon: 'ğŸ‘¢', mp: 16, cd: 4.0, branch: 2, desc: 'Stomp', prereq: 'b_leap', effect: 'ground_slam', baseMult: [1.8, 2.2, 2.8, 3.5, 4.2], range: 110, slow: [0.5, 0.45, 0.4, 0.35, 0.3] },
                { id: 'b_ironskin', name: 'ã‚¢ã‚¤ã‚¢ãƒ³ã‚¹ã‚­ãƒ³', icon: 'ğŸ”°', mp: 20, cd: 10.0, branch: 2, desc: 'Iron skin', prereq: 'b_leap', effect: 'buff_defense', duration: [6, 8, 10, 12, 16], reduction: [0.4, 0.5, 0.55, 0.6, 0.7] },
                { id: 'b_increasedspeed', name: 'ã‚¤ãƒ³ã‚¯ãƒªãƒ¼ã‚¹ãƒ‰ã‚¹ãƒ”ãƒ¼ãƒ‰', icon: 'ğŸ’¨', mp: 22, cd: 10.0, branch: 2, desc: 'Increased speed', prereq: 'b_stomp', effect: 'buff_speed', duration: [6, 8, 10, 12, 16], bonus: [0.35, 0.45, 0.55, 0.65, 0.8] },
                { id: 'b_natres', name: 'ãƒŠãƒãƒ¥ãƒ©ãƒ«ãƒ¬ã‚¸ã‚¹ã‚¿ãƒ³ã‚¹', icon: 'ğŸ’ª', mp: 28, cd: 12.0, branch: 2, desc: 'Natural resistance', prereq: 'b_ironskin', effect: 'buff_defense', duration: [8, 10, 12, 15, 18], reduction: [0.45, 0.55, 0.6, 0.7, 0.8] },
                { id: 'b_swordmastery', name: 'ã‚½ãƒ¼ãƒ‰ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'âš”', mp: 30, cd: 12.0, branch: 2, desc: 'Sword mastery', prereq: 'b_increasedspeed', effect: 'buff_atkspd', duration: [6, 8, 10, 13, 16], bonus: [0.45, 0.55, 0.65, 0.8, 1.0] },
                { id: 'b_berserk', name: 'ãƒãƒ¼ã‚µãƒ¼ã‚¯', icon: 'ğŸ‘¹', mp: 40, cd: 8.0, branch: 2, desc: 'Berserk', prereq: 'b_natres', effect: 'buff_berserk', duration: [6, 8, 10, 13, 16] },
                { id: 'b_ironfist', name: 'ã‚¢ã‚¤ã‚¢ãƒ³ãƒ•ã‚£ã‚¹ãƒˆ', icon: 'ğŸ¤œ', mp: 55, cd: 10.0, branch: 2, desc: 'Iron fist', prereq: 'b_berserk', effect: 'execute', baseMult: [4.5, 6.0, 7.5, 9.5, 12.0], threshold: [0.45, 0.5, 0.55, 0.6, 0.7], range: 65 }
            ]
        },
        assassin: {
            name: 'ã‚¢ã‚µã‚·ãƒ³',
            icon: 'ğŸ—¡',
            engName: 'Assassin',
            tier: 1,
            baseClass: 'rogue',
            sprite: 'assassin',
            baseStr: 14,
            baseDex: 26,
            baseVit: 12,
            baseInt: 12,
            branches: ['ãƒãƒ¼ã‚·ãƒ£ãƒ«ã‚¢ãƒ¼ãƒ„', 'ã‚·ãƒ£ãƒ‰ã‚¦', 'ãƒˆãƒ©ãƒƒãƒ—'],
            promotions: [],
            skills: [
                // Branch 0: ãƒãƒ¼ã‚·ãƒ£ãƒ«ã‚¢ãƒ¼ãƒ„
                { id: 'a_tigerstrike', name: 'ã‚¿ã‚¤ã‚¬ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸ¯', mp: 8, cd: 1.0, branch: 0, desc: 'Tiger strike', prereq: null, effect: 'melee_burst', baseMult: [2.0, 2.5, 3.0, 3.6, 4.5], range: 55 },
                { id: 'a_cobrastrike', name: 'ã‚³ãƒ–ãƒ©ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸ', mp: 12, cd: 1.5, branch: 0, desc: 'Cobra strike', prereq: 'a_tigerstrike', effect: 'melee_burst', baseMult: [2.2, 2.8, 3.4, 4.0, 5.0], range: 55 },
                { id: 'a_fistsoffire', name: 'ãƒ•ã‚£ã‚¹ãƒ„ã‚ªãƒ–ãƒ•ã‚¡ã‚¤ã‚¢', icon: 'ğŸ”¥', mp: 16, cd: 2.0, branch: 0, desc: 'Fists of fire', prereq: 'a_cobrastrike', effect: 'melee_burst', baseMult: [2.5, 3.0, 3.8, 4.5, 5.5], range: 60 },
                { id: 'a_dragontalon', name: 'ãƒ‰ãƒ©ã‚´ãƒ³ã‚¿ãƒ­ãƒ³', icon: 'ğŸ‰', mp: 22, cd: 2.5, branch: 0, desc: 'Dragon talon', prereq: 'a_fistsoffire', effect: 'shadow_strike', baseMult: [3.0, 3.8, 4.5, 5.5, 7.0] },
                { id: 'a_bladesofice', name: 'ãƒ–ãƒ¬ã‚¤ã‚ºã‚ªãƒ–ã‚¢ã‚¤ã‚¹', icon: 'â„', mp: 28, cd: 3.0, branch: 0, desc: 'Blades of ice', prereq: 'a_dragontalon', effect: 'frost_nova', baseMult: [1.5, 2.0, 2.5, 3.2, 4.0], freeze: [2, 2, 3, 3, 4] },
                { id: 'a_clawsofthunder', name: 'ã‚¯ãƒ­ã‚¦ã‚ºã‚ªãƒ–ã‚µãƒ³ãƒ€ãƒ¼', icon: 'âš¡', mp: 35, cd: 4.0, branch: 0, desc: 'Claws of thunder', prereq: 'a_bladesofice', effect: 'chain_lightning', bounces: [2, 3, 4, 5, 6], baseMult: [1.8, 2.2, 2.8, 3.5, 4.5] },
                { id: 'a_bladesentinel', name: 'ãƒ–ãƒ¬ãƒ¼ãƒ‰ã‚»ãƒ³ãƒãƒãƒ«', icon: 'ğŸ—¡', mp: 42, cd: 6.0, branch: 0, desc: 'Blade sentinel', prereq: 'a_clawsofthunder', effect: 'arrow_rain', baseMult: [2.0, 2.5, 3.2, 4.0, 5.5], range: 100 },
                { id: 'a_phoenixstrike', name: 'ãƒ•ã‚§ãƒ‹ãƒƒã‚¯ã‚¹ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸ”¥', mp: 55, cd: 8.0, branch: 0, desc: 'Phoenix strike', prereq: 'a_bladesentinel', effect: 'execute', baseMult: [5.0, 6.5, 8.0, 10.0, 13.0], threshold: [1.0, 1.0, 1.0, 1.0, 1.0], range: 80 },
                // Branch 1: ã‚·ãƒ£ãƒ‰ã‚¦
                { id: 'a_burstspeed', name: 'ãƒãƒ¼ã‚¹ãƒˆã‚ªãƒ–ã‚¹ãƒ”ãƒ¼ãƒ‰', icon: 'ğŸ’¨', mp: 12, cd: 8.0, branch: 1, desc: 'Burst speed', prereq: null, effect: 'buff_speed', duration: [5, 7, 9, 12, 15], bonus: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'a_fade', name: 'ãƒ•ã‚§ãƒ¼ãƒ‰', icon: 'ğŸŒ‘', mp: 15, cd: 10.0, branch: 1, desc: 'Fade', prereq: 'a_burstspeed', effect: 'buff_defense', duration: [6, 8, 10, 12, 16], reduction: [0.3, 0.4, 0.5, 0.55, 0.65] },
                { id: 'a_cloak', name: 'ã‚¯ãƒ­ãƒ¼ã‚¯ã‚ªãƒ–ã‚·ãƒ£ãƒ‰ã‚¦', icon: 'ğŸŒ‘', mp: 20, cd: 12.0, branch: 1, desc: 'Cloak of shadow', prereq: 'a_burstspeed', effect: 'smoke_screen', duration: [3, 4, 5, 6, 8], range: 110, evade: [30, 40, 50, 60, 75] },
                { id: 'a_weaponblock', name: 'ã‚¦ã‚§ãƒãƒ³ãƒ–ãƒ­ãƒƒã‚¯', icon: 'ğŸ›¡', mp: 18, cd: 8.0, branch: 1, desc: 'Weapon block', prereq: 'a_fade', effect: 'buff_dodge', duration: [5, 7, 9, 12, 15], chance: [25, 35, 45, 55, 70] },
                { id: 'a_mindblast', name: 'ãƒã‚¤ãƒ³ãƒ‰ãƒ–ãƒ©ã‚¹ãƒˆ', icon: 'ğŸ§ ', mp: 25, cd: 5.0, branch: 1, desc: 'Mind blast', prereq: 'a_cloak', effect: 'stun_aoe', duration: [1.5, 2.0, 2.5, 3.0, 4.0], range: 120 },
                { id: 'a_venom', name: 'ãƒ´ã‚§ãƒãƒ ', icon: 'â˜ ', mp: 28, cd: 10.0, branch: 1, desc: 'Venom', prereq: 'a_mindblast', effect: 'buff_poison', duration: [6, 8, 10, 13, 16], dps: [8, 12, 18, 25, 35] },
                { id: 'a_shadowwarrior', name: 'ã‚·ãƒ£ãƒ‰ã‚¦ã‚¦ã‚©ãƒªã‚¢ãƒ¼', icon: 'ğŸ‘¤', mp: 40, cd: 15.0, branch: 1, desc: 'Shadow warrior', prereq: 'a_weaponblock', effect: 'summon_minion', duration: [10, 14, 18, 22, 28], minionHP: [120, 200, 300, 420, 600], minionDmg: [10, 15, 22, 30, 42] },
                { id: 'a_shadowmaster', name: 'ã‚·ãƒ£ãƒ‰ã‚¦ãƒã‚¹ã‚¿ãƒ¼', icon: 'ğŸ‘¥', mp: 55, cd: 20.0, branch: 1, desc: 'Shadow master', prereq: 'a_shadowwarrior', effect: 'summon_minion', duration: [12, 16, 20, 25, 32], minionHP: [200, 320, 450, 600, 850], minionDmg: [15, 22, 32, 45, 65] },
                // Branch 2: ãƒˆãƒ©ãƒƒãƒ—
                { id: 'a_fireblast', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒ–ãƒ©ã‚¹ãƒˆ', icon: 'ğŸ’£', mp: 10, cd: 3.0, branch: 2, desc: 'Fire blast', prereq: null, effect: 'place_trap', baseMult: [1.8, 2.2, 2.8, 3.5, 4.2] },
                { id: 'a_wakeoffire', name: 'ã‚¦ã‚§ã‚¤ã‚¯ã‚ªãƒ–ãƒ•ã‚¡ã‚¤ã‚¢', icon: 'ğŸ”¥', mp: 16, cd: 4.0, branch: 2, desc: 'Wake of fire', prereq: 'a_fireblast', effect: 'consecrate', baseMult: [0.6, 0.8, 1.0, 1.3, 1.6], range: 80, duration: [3, 4, 5, 6, 8] },
                { id: 'a_ltgsentry', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ã‚»ãƒ³ãƒˆãƒªãƒ¼', icon: 'âš¡', mp: 22, cd: 5.0, branch: 2, desc: 'Lightning sentry', prereq: 'a_fireblast', effect: 'consecrate', baseMult: [0.7, 0.9, 1.2, 1.5, 2.0], range: 90, duration: [4, 5, 6, 8, 10] },
                { id: 'a_bladefury', name: 'ãƒ–ãƒ¬ãƒ¼ãƒ‰ãƒ•ãƒ¥ãƒ¼ãƒªãƒ¼', icon: 'ğŸŒ€', mp: 25, cd: 3.0, branch: 2, desc: 'Blade fury', prereq: 'a_wakeoffire', effect: 'multi_shot', arrows: [3, 4, 5, 6, 8], baseMult: [1.0, 1.3, 1.6, 2.0, 2.5] },
                { id: 'a_wakeofinferno', name: 'ã‚¦ã‚§ã‚¤ã‚¯ã‚ªãƒ–ã‚¤ãƒ³ãƒ•ã‚§ãƒ«ãƒ', icon: 'ğŸŒ‹', mp: 30, cd: 6.0, branch: 2, desc: 'Wake of inferno', prereq: 'a_ltgsentry', effect: 'consecrate', baseMult: [0.8, 1.0, 1.3, 1.6, 2.2], range: 100, duration: [4, 5, 7, 8, 10] },
                { id: 'a_chargedboltsentry', name: 'ãƒãƒ£ãƒ¼ã‚¸ãƒ‰ãƒœãƒ«ãƒˆã‚»ãƒ³ãƒˆãƒªãƒ¼', icon: 'ğŸ”µ', mp: 35, cd: 6.0, branch: 2, desc: 'Charged bolt sentry', prereq: 'a_wakeofinferno', effect: 'multi_shot', arrows: [4, 5, 6, 7, 9], baseMult: [1.2, 1.5, 1.8, 2.2, 2.8] },
                { id: 'a_deathsentry', name: 'ãƒ‡ã‚¹ã‚»ãƒ³ãƒˆãƒªãƒ¼', icon: 'ğŸ’€', mp: 42, cd: 8.0, branch: 2, desc: 'Death sentry', prereq: 'a_chargedboltsentry', effect: 'arrow_rain', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], range: 120 },
                { id: 'a_bladeshield', name: 'ãƒ–ãƒ¬ãƒ¼ãƒ‰ã‚·ãƒ¼ãƒ«ãƒ‰', icon: 'ğŸ›¡', mp: 55, cd: 12.0, branch: 2, desc: 'Blade shield', prereq: 'a_deathsentry', effect: 'buff_counter', duration: [6, 8, 10, 13, 16], reflect: [0.4, 0.5, 0.6, 0.8, 1.0] }
            ]
        },
        ranger: {
            name: 'ãƒ¬ãƒ³ã‚¸ãƒ£ãƒ¼',
            icon: 'ğŸ¹',
            engName: 'Ranger',
            tier: 1,
            baseClass: 'rogue',
            sprite: 'rangerCls',
            baseStr: 12,
            baseDex: 24,
            baseVit: 16,
            baseInt: 12,
            branches: ['ã‚¢ãƒ¼ãƒã‚§ãƒªãƒ¼', 'ã‚¹ãƒ”ã‚¢ã‚¹ã‚­ãƒ«', 'ãƒ‘ãƒƒã‚·ãƒ–'],
            promotions: [],
            skills: [
                // Branch 0: ã‚¢ãƒ¼ãƒã‚§ãƒªãƒ¼
                { id: 'rg_guided', name: 'ã‚¬ã‚¤ãƒ‡ãƒƒãƒ‰ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ¯', mp: 10, cd: 0.8, branch: 0, desc: 'Guided arrow', prereq: null, effect: 'projectile_fire', baseMult: [1.8, 2.2, 2.6, 3.2, 4.0], speed: 500 },
                { id: 'rg_coldarrow', name: 'ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¢ãƒ­ãƒ¼', icon: 'â„', mp: 12, cd: 1.2, branch: 0, desc: 'Cold arrow', prereq: 'rg_guided', effect: 'projectile_fire', baseMult: [1.6, 2.0, 2.4, 3.0, 3.8], speed: 420 },
                { id: 'rg_multishot', name: 'ãƒãƒ«ãƒãƒ—ãƒ«ã‚·ãƒ§ãƒƒãƒˆ', icon: 'ğŸŒŸ', mp: 20, cd: 2.0, branch: 0, desc: 'Multi shot', prereq: 'rg_guided', effect: 'multi_shot', arrows: [3, 4, 5, 6, 8], baseMult: [1.0, 1.3, 1.6, 2.0, 2.5] },
                { id: 'rg_strafe', name: 'ã‚¹ãƒˆãƒ¬ã‚¤ãƒ•', icon: 'ğŸ¹', mp: 25, cd: 2.5, branch: 0, desc: 'Strafe', prereq: 'rg_multishot', effect: 'multi_shot', arrows: [4, 5, 6, 8, 10], baseMult: [1.2, 1.5, 1.8, 2.2, 2.8] },
                { id: 'rg_explodingarrow', name: 'ã‚¨ã‚¯ã‚¹ãƒ—ãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ’¥', mp: 28, cd: 4.0, branch: 0, desc: 'Exploding arrow', prereq: 'rg_coldarrow', effect: 'arrow_rain', baseMult: [2.0, 2.5, 3.2, 4.0, 5.0], range: 90 },
                { id: 'rg_immolation', name: 'ã‚¤ãƒ¢ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ”¥', mp: 35, cd: 6.0, branch: 0, desc: 'Immolation', prereq: 'rg_explodingarrow', effect: 'arrow_rain', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], range: 100 },
                { id: 'rg_freezingarrow', name: 'ãƒ•ãƒªãƒ¼ã‚¸ãƒ³ã‚°ã‚¢ãƒ­ãƒ¼', icon: 'ğŸ§Š', mp: 42, cd: 6.0, branch: 0, desc: 'Freezing arrow', prereq: 'rg_immolation', effect: 'frost_nova', baseMult: [2.0, 2.5, 3.2, 4.0, 5.5], freeze: [2, 3, 3, 4, 5] },
                { id: 'rg_magicarrow', name: 'ãƒã‚¸ãƒƒã‚¯ã‚¢ãƒ­ãƒ¼', icon: 'âœ¨', mp: 55, cd: 8.0, branch: 0, desc: 'Magic arrow', prereq: 'rg_freezingarrow', effect: 'projectile_fire', baseMult: [4.0, 5.0, 6.5, 8.0, 10.5], speed: 550 },
                // Branch 1: ã‚¹ãƒ”ã‚¢ã‚¹ã‚­ãƒ«
                { id: 'rg_jab', name: 'ã‚¸ãƒ£ãƒ–', icon: 'ğŸ”±', mp: 8, cd: 1.0, branch: 1, desc: 'Jab', prereq: null, effect: 'melee_burst', baseMult: [1.8, 2.2, 2.6, 3.2, 4.0], range: 58 },
                { id: 'rg_chargedstrike', name: 'ãƒãƒ£ãƒ¼ã‚¸ãƒ‰ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'âš¡', mp: 14, cd: 2.0, branch: 1, desc: 'Charged strike', prereq: 'rg_jab', effect: 'melee_burst', baseMult: [2.0, 2.5, 3.2, 4.0, 5.0], range: 60 },
                { id: 'rg_powerstrike', name: 'ãƒ‘ãƒ¯ãƒ¼ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'ğŸ’ª', mp: 18, cd: 2.5, branch: 1, desc: 'Power strike', prereq: 'rg_chargedstrike', effect: 'melee_burst', baseMult: [2.5, 3.0, 3.8, 4.5, 5.8], range: 62 },
                { id: 'rg_fend', name: 'ãƒ•ã‚§ãƒ³ãƒ‰', icon: 'ğŸ”±', mp: 22, cd: 3.5, branch: 1, desc: 'Fend', prereq: 'rg_powerstrike', effect: 'whirlwind', baseMult: [1.6, 2.0, 2.5, 3.2, 4.0], range: 85 },
                { id: 'rg_poisonjav', name: 'ãƒã‚¤ã‚ºãƒ³ã‚¸ãƒ£ãƒ™ãƒªãƒ³', icon: 'â˜ ', mp: 25, cd: 4.0, branch: 1, desc: 'Poison javelin', prereq: 'rg_fend', effect: 'buff_poison', duration: [4, 5, 6, 8, 10], dps: [6, 10, 15, 22, 30] },
                { id: 'rg_plaguejav', name: 'ãƒ—ãƒ¬ã‚¤ã‚°ã‚¸ãƒ£ãƒ™ãƒªãƒ³', icon: 'ğŸ’š', mp: 30, cd: 5.0, branch: 1, desc: 'Plague javelin', prereq: 'rg_poisonjav', effect: 'consecrate', baseMult: [0.6, 0.8, 1.0, 1.3, 1.6], range: 90, duration: [4, 5, 6, 8, 10] },
                { id: 'rg_ltfury', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ãƒ•ãƒ¥ãƒ¼ãƒªãƒ¼', icon: 'ğŸŒ©', mp: 42, cd: 6.0, branch: 1, desc: 'Lightning fury', prereq: 'rg_plaguejav', effect: 'chain_lightning', bounces: [3, 4, 5, 6, 8], baseMult: [2.0, 2.5, 3.2, 4.0, 5.5] },
                { id: 'rg_lightningstrike', name: 'ãƒ©ã‚¤ãƒˆãƒ‹ãƒ³ã‚°ã‚¹ãƒˆãƒ©ã‚¤ã‚¯', icon: 'âš¡', mp: 55, cd: 8.0, branch: 1, desc: 'Lightning strike', prereq: 'rg_ltfury', effect: 'chain_lightning', bounces: [4, 5, 6, 7, 9], baseMult: [2.8, 3.5, 4.5, 5.5, 7.5] },
                // Branch 2: ãƒ‘ãƒƒã‚·ãƒ–
                { id: 'rg_penetrate', name: 'ãƒšãƒãƒˆãƒ¬ã‚¤ãƒˆ', icon: 'ğŸ¯', mp: 12, cd: 10.0, branch: 2, desc: 'Penetrate', prereq: null, effect: 'buff_crit', duration: [5, 7, 9, 12, 15], bonus: [15, 22, 30, 40, 55] },
                { id: 'rg_dodge', name: 'ãƒ‰ãƒƒã‚¸', icon: 'ğŸ’¨', mp: 15, cd: 10.0, branch: 2, desc: 'Dodge', prereq: 'rg_penetrate', effect: 'buff_dodge', duration: [5, 7, 9, 12, 15], chance: [25, 35, 45, 55, 70] },
                { id: 'rg_avoid', name: 'ã‚¢ãƒ´ã‚©ã‚¤ãƒ‰', icon: 'ğŸŒ€', mp: 18, cd: 10.0, branch: 2, desc: 'Avoid', prereq: 'rg_dodge', effect: 'buff_dodge', duration: [6, 8, 10, 13, 16], chance: [30, 40, 50, 60, 75] },
                { id: 'rg_evade', name: 'ã‚¤ãƒ´ã‚§ã‚¤ãƒ‰', icon: 'ğŸŒŠ', mp: 22, cd: 10.0, branch: 2, desc: 'Evade', prereq: 'rg_avoid', effect: 'buff_speed', duration: [5, 7, 9, 12, 16], bonus: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'rg_slowmissiles', name: 'ã‚¹ãƒ­ãƒ¼ãƒŸã‚µã‚¤ãƒ«', icon: 'ğŸ•¸', mp: 20, cd: 6.0, branch: 2, desc: 'Slow missiles', prereq: 'rg_penetrate', effect: 'stun_aoe', duration: [1.5, 2.0, 2.5, 3.0, 4.0], range: 120 },
                { id: 'rg_critmastery', name: 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'âš”', mp: 30, cd: 12.0, branch: 2, desc: 'Crit mastery', prereq: 'rg_evade', effect: 'buff_crit', duration: [6, 8, 10, 14, 18], bonus: [25, 35, 45, 60, 80] },
                { id: 'rg_pierce', name: 'ãƒ”ã‚¢ãƒ¼ã‚¹', icon: 'ğŸ¹', mp: 35, cd: 10.0, branch: 2, desc: 'Pierce', prereq: 'rg_slowmissiles', effect: 'buff_atkspd', duration: [6, 8, 10, 12, 16], bonus: [0.4, 0.5, 0.6, 0.8, 1.0] },
                { id: 'rg_decoy', name: 'ãƒ‡ã‚³ã‚¤', icon: 'ğŸ‘¤', mp: 50, cd: 15.0, branch: 2, desc: 'Decoy', prereq: 'rg_critmastery', effect: 'summon_minion', duration: [8, 12, 16, 20, 25], minionHP: [100, 160, 240, 340, 480], minionDmg: [8, 12, 18, 25, 35] }
            ]
        },
        pyromancer: {
            name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚½ãƒ¼ã‚µãƒ¬ã‚¹',
            icon: 'ğŸ”¥',
            engName: 'Pyromancer',
            tier: 1,
            baseClass: 'sorcerer',
            sprite: 'pyromancer',
            baseStr: 5,
            baseDex: 10,
            baseVit: 12,
            baseInt: 30,
            branches: ['ãƒ•ã‚¡ã‚¤ã‚¢ã‚¹ãƒšãƒ«', 'ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆ', 'ã‚¤ãƒ³ãƒ•ã‚§ãƒ«ãƒ'],
            promotions: [],
            skills: [
                // Branch 0: ãƒ•ã‚¡ã‚¤ã‚¢ã‚¹ãƒšãƒ«
                { id: 'py_firebolt', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ«ãƒˆ', icon: 'ğŸ”¥', mp: 6, cd: 0.5, branch: 0, desc: 'Fire bolt', prereq: null, effect: 'projectile_fire', baseMult: [1.8, 2.2, 2.6, 3.2, 4.0], speed: 360 },
                { id: 'py_fireball', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒœãƒ¼ãƒ«', icon: 'â˜€', mp: 14, cd: 0.8, branch: 0, desc: 'Fireball', prereq: 'py_firebolt', effect: 'projectile_fire', baseMult: [2.5, 3.0, 3.8, 4.5, 5.5], speed: 380 },
                { id: 'py_firewall', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚¦ã‚©ãƒ¼ãƒ«', icon: 'ğŸ§±', mp: 22, cd: 4.0, branch: 0, desc: 'Fire wall', prereq: 'py_fireball', effect: 'consecrate', baseMult: [0.7, 0.9, 1.2, 1.5, 2.0], range: 80, duration: [3, 4, 5, 7, 9] },
                { id: 'py_combustion', name: 'ã‚³ãƒ³ãƒãƒƒã‚·ãƒ§ãƒ³', icon: 'ğŸ’¥', mp: 28, cd: 5.0, branch: 0, desc: 'Combustion', prereq: 'py_firewall', effect: 'meteor', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], range: 90 },
                { id: 'py_meteor', name: 'ãƒ¡ãƒ†ã‚ª', icon: 'â˜„', mp: 40, cd: 7.0, branch: 0, desc: 'Meteor', prereq: 'py_combustion', effect: 'meteor', baseMult: [3.5, 4.5, 5.5, 7.0, 9.0], range: 120 },
                { id: 'py_armageddon', name: 'ã‚¢ãƒ«ãƒã‚²ãƒ‰ãƒ³', icon: 'ğŸŒ ', mp: 50, cd: 10.0, branch: 0, desc: 'Armageddon', prereq: 'py_meteor', effect: 'arrow_rain', baseMult: [3.0, 4.0, 5.0, 6.5, 8.5], range: 150 },
                { id: 'py_firemastery2', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'ğŸ”¥', mp: 45, cd: 12.0, branch: 0, desc: 'Fire mastery', prereq: 'py_armageddon', effect: 'buff_atkspd', duration: [6, 8, 10, 14, 18], bonus: [0.4, 0.5, 0.6, 0.8, 1.0] },
                { id: 'py_meteorstorm', name: 'ãƒ¡ãƒ†ã‚ªã‚¹ãƒˆãƒ¼ãƒ ', icon: 'ğŸŒ‹', mp: 65, cd: 12.0, branch: 0, desc: 'Meteor storm', prereq: 'py_firemastery2', effect: 'meteor', baseMult: [5.5, 7.0, 9.0, 11.0, 14.0], range: 160 },
                // Branch 1: ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆ
                { id: 'py_warmth', name: 'ã‚¦ã‚©ãƒ¼ãƒ ã‚¹', icon: 'ğŸŒ¡', mp: 10, cd: 8.0, branch: 1, desc: 'Warmth', prereq: null, effect: 'buff_aura', duration: [6, 8, 10, 12, 16], regen: [3, 5, 7, 10, 14], reduction: [0.1, 0.15, 0.2, 0.25, 0.3] },
                { id: 'py_enchant', name: 'ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆ', icon: 'âœ¨', mp: 18, cd: 10.0, branch: 1, desc: 'Enchant', prereq: 'py_warmth', effect: 'buff_berserk', duration: [6, 8, 10, 12, 16] },
                { id: 'py_blazingaura', name: 'ãƒ–ãƒ¬ã‚¤ã‚¸ãƒ³ã‚°ã‚ªãƒ¼ãƒ©', icon: 'ğŸ”†', mp: 22, cd: 8.0, branch: 1, desc: 'Blazing aura', prereq: 'py_enchant', effect: 'consecrate', baseMult: [0.5, 0.7, 0.9, 1.2, 1.5], range: 70, duration: [4, 5, 6, 8, 10] },
                { id: 'py_infernalguard', name: 'ã‚¤ãƒ³ãƒ•ã‚¡ãƒ¼ãƒŠãƒ«ã‚¬ãƒ¼ãƒ‰', icon: 'ğŸ”°', mp: 25, cd: 10.0, branch: 1, desc: 'Infernal guard', prereq: 'py_blazingaura', effect: 'buff_counter', duration: [5, 7, 9, 12, 15], reflect: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'py_moltenarmor', name: 'ãƒ¢ãƒ«ãƒ†ãƒ³ã‚¢ãƒ¼ãƒãƒ¼', icon: 'ğŸ›¡', mp: 28, cd: 10.0, branch: 1, desc: 'Molten armor', prereq: 'py_infernalguard', effect: 'buff_defense', duration: [6, 8, 10, 13, 16], reduction: [0.35, 0.45, 0.55, 0.6, 0.7] },
                { id: 'py_flamebarrier', name: 'ãƒ•ãƒ¬ã‚¤ãƒ ãƒãƒªã‚¢', icon: 'ğŸ”¥', mp: 32, cd: 8.0, branch: 1, desc: 'Flame barrier', prereq: 'py_moltenarmor', effect: 'buff_counter', duration: [6, 8, 10, 12, 16], reflect: [0.4, 0.5, 0.6, 0.8, 1.0] },
                { id: 'py_hydra', name: 'ãƒ’ãƒ‰ãƒ©', icon: 'ğŸ', mp: 40, cd: 8.0, branch: 1, desc: 'Hydra', prereq: 'py_flamebarrier', effect: 'consecrate', baseMult: [0.8, 1.0, 1.3, 1.6, 2.2], range: 100, duration: [5, 7, 9, 12, 15] },
                { id: 'py_innerflame', name: 'ã‚¤ãƒ³ãƒŠãƒ¼ãƒ•ãƒ¬ã‚¤ãƒ ', icon: 'ğŸ’›', mp: 55, cd: 15.0, branch: 1, desc: 'Inner flame', prereq: 'py_hydra', effect: 'buff_frenzy', duration: [8, 10, 12, 16, 20], atkBonus: [0.5, 0.6, 0.7, 0.9, 1.2], spdBonus: [0.2, 0.3, 0.4, 0.5, 0.6] },
                // Branch 2: ã‚¤ãƒ³ãƒ•ã‚§ãƒ«ãƒ
                { id: 'py_inferno', name: 'ã‚¤ãƒ³ãƒ•ã‚§ãƒ«ãƒ', icon: 'ğŸŒ‹', mp: 12, cd: 2.0, branch: 2, desc: 'Inferno', prereq: null, effect: 'ground_slam', baseMult: [1.5, 1.8, 2.2, 2.8, 3.5], range: 80, slow: [0.5, 0.45, 0.4, 0.35, 0.3] },
                { id: 'py_firestorm', name: 'ãƒ•ã‚¡ã‚¤ã‚¢ã‚¹ãƒˆãƒ¼ãƒ ', icon: 'ğŸ”¥', mp: 16, cd: 3.0, branch: 2, desc: 'Fire storm', prereq: 'py_inferno', effect: 'arrow_rain', baseMult: [1.5, 2.0, 2.5, 3.0, 4.0], range: 90 },
                { id: 'py_blaze', name: 'ãƒ–ãƒ¬ã‚¤ã‚º', icon: 'ğŸ’¥', mp: 20, cd: 3.5, branch: 2, desc: 'Blaze', prereq: 'py_firestorm', effect: 'chain_lightning', bounces: [2, 3, 4, 5, 6], baseMult: [1.5, 2.0, 2.5, 3.2, 4.0] },
                { id: 'py_lavawalk', name: 'ãƒ©ãƒ´ã‚¡ã‚¦ã‚©ãƒ¼ã‚¯', icon: 'ğŸŸ ', mp: 25, cd: 5.0, branch: 2, desc: 'Lava walk', prereq: 'py_blaze', effect: 'consecrate', baseMult: [0.7, 0.9, 1.2, 1.5, 2.0], range: 70, duration: [3, 4, 5, 7, 9] },
                { id: 'py_pyromania', name: 'ãƒ‘ã‚¤ãƒ­ãƒãƒ‹ã‚¢', icon: 'ğŸ”¥', mp: 30, cd: 6.0, branch: 2, desc: 'Pyromania', prereq: 'py_lavawalk', effect: 'meteor', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], range: 100 },
                { id: 'py_combustion2', name: 'ã‚³ãƒ³ãƒãƒƒã‚·ãƒ§ãƒ³II', icon: 'ğŸ’¥', mp: 38, cd: 7.0, branch: 2, desc: 'Combustion 2', prereq: 'py_pyromania', effect: 'meteor', baseMult: [3.0, 4.0, 5.0, 6.5, 8.0], range: 110 },
                { id: 'py_hellfire', name: 'ãƒ˜ãƒ«ãƒ•ã‚¡ã‚¤ã‚¢', icon: 'ğŸ”¥', mp: 48, cd: 8.0, branch: 2, desc: 'Hellfire', prereq: 'py_combustion2', effect: 'arrow_rain', baseMult: [3.0, 4.0, 5.0, 6.5, 8.5], range: 140 },
                { id: 'py_armageddon2', name: 'ãƒ•ã‚¡ã‚¤ãƒŠãƒ«ãƒ•ãƒ¬ã‚¢', icon: 'ğŸŒ ', mp: 60, cd: 12.0, branch: 2, desc: 'Final flare', prereq: 'py_hellfire', effect: 'meteor', baseMult: [6.0, 8.0, 10.0, 12.0, 16.0], range: 170 }
            ]
        },
        cryomancer: {
            name: 'ã‚¢ã‚¤ã‚¹ã‚½ãƒ¼ã‚µãƒ¬ã‚¹',
            icon: 'â„',
            engName: 'Cryomancer',
            tier: 1,
            baseClass: 'sorcerer',
            sprite: 'cryomancer',
            baseStr: 5,
            baseDex: 12,
            baseVit: 14,
            baseInt: 28,
            branches: ['ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒšãƒ«', 'ãƒ•ãƒ­ã‚¹ãƒˆãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹', 'ã‚¢ã‚¤ã‚¹ãƒã‚¹ã‚¿ãƒªãƒ¼'],
            promotions: [],
            skills: [
                // Branch 0: ã‚³ãƒ¼ãƒ«ãƒ‰ã‚¹ãƒšãƒ«
                { id: 'cy_icebolt', name: 'ã‚¢ã‚¤ã‚¹ãƒœãƒ«ãƒˆ', icon: 'ğŸ”·', mp: 6, cd: 0.5, branch: 0, desc: 'Ice bolt', prereq: null, effect: 'projectile_fire', baseMult: [1.4, 1.7, 2.0, 2.4, 3.0], speed: 380 },
                { id: 'cy_iceblast', name: 'ã‚¢ã‚¤ã‚¹ãƒ–ãƒ©ã‚¹ãƒˆ', icon: 'ğŸ’', mp: 12, cd: 0.8, branch: 0, desc: 'Ice blast', prereq: 'cy_icebolt', effect: 'projectile_fire', baseMult: [1.8, 2.2, 2.6, 3.2, 4.0], speed: 400 },
                { id: 'cy_frostbolt', name: 'ãƒ•ãƒ­ã‚¹ãƒˆãƒœãƒ«ãƒˆ', icon: 'ğŸ”µ', mp: 16, cd: 1.5, branch: 0, desc: 'Frost bolt', prereq: 'cy_iceblast', effect: 'projectile_fire', baseMult: [2.2, 2.8, 3.5, 4.2, 5.2], speed: 360 },
                { id: 'cy_glacialspike', name: 'ã‚°ãƒ¬ã‚¤ã‚·ãƒ£ãƒ«ã‚¹ãƒ‘ã‚¤ã‚¯', icon: 'â„', mp: 22, cd: 3.0, branch: 0, desc: 'Glacial spike', prereq: 'cy_frostbolt', effect: 'frost_nova', baseMult: [1.5, 2.0, 2.5, 3.2, 4.2], freeze: [2, 3, 3, 4, 5] },
                { id: 'cy_blizzard', name: 'ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰', icon: 'ğŸŒ¨', mp: 38, cd: 6.0, branch: 0, desc: 'Blizzard', prereq: 'cy_glacialspike', effect: 'arrow_rain', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], range: 130 },
                { id: 'cy_iceorb', name: 'ã‚¢ã‚¤ã‚¹ã‚ªãƒ¼ãƒ–', icon: 'ğŸŒ', mp: 42, cd: 7.0, branch: 0, desc: 'Ice orb', prereq: 'cy_blizzard', effect: 'frozen_orb', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], speed: 180, shardCount: [5, 6, 8, 10, 12] },
                { id: 'cy_absolutezero', name: 'ã‚¢ãƒ–ã‚½ãƒªãƒ¥ãƒ¼ãƒˆã‚¼ãƒ­', icon: 'â„', mp: 50, cd: 8.0, branch: 0, desc: 'Absolute zero', prereq: 'cy_iceorb', effect: 'frost_nova', baseMult: [3.0, 4.0, 5.0, 6.5, 8.5], freeze: [3, 4, 5, 6, 8] },
                { id: 'cy_permafrost', name: 'ãƒ‘ãƒ¼ãƒãƒ•ãƒ­ã‚¹ãƒˆ', icon: 'ğŸ§Š', mp: 60, cd: 10.0, branch: 0, desc: 'Permafrost', prereq: 'cy_absolutezero', effect: 'arrow_rain', baseMult: [4.0, 5.0, 6.5, 8.0, 10.5], range: 150 },
                // Branch 1: ãƒ•ãƒ­ã‚¹ãƒˆãƒ‡ã‚£ãƒ•ã‚§ãƒ³ã‚¹
                { id: 'cy_frozenarmor', name: 'ãƒ•ãƒ­ãƒ¼ã‚ºãƒ³ã‚¢ãƒ¼ãƒãƒ¼', icon: 'ğŸ›¡', mp: 12, cd: 8.0, branch: 1, desc: 'Frozen armor', prereq: null, effect: 'buff_defense', duration: [5, 7, 9, 12, 15], reduction: [0.3, 0.4, 0.5, 0.55, 0.65] },
                { id: 'cy_chillingarmor', name: 'ãƒãƒªãƒ³ã‚°ã‚¢ãƒ¼ãƒãƒ¼', icon: 'ğŸ§Š', mp: 16, cd: 8.0, branch: 1, desc: 'Chilling armor', prereq: 'cy_frozenarmor', effect: 'buff_defense', duration: [6, 8, 10, 13, 16], reduction: [0.35, 0.45, 0.55, 0.6, 0.7] },
                { id: 'cy_shiverarmor', name: 'ã‚·ãƒ´ã‚¡ãƒ¼ã‚¢ãƒ¼ãƒãƒ¼', icon: 'ğŸª', mp: 20, cd: 8.0, branch: 1, desc: 'Shiver armor', prereq: 'cy_chillingarmor', effect: 'buff_counter', duration: [5, 7, 9, 11, 14], reflect: [0.3, 0.4, 0.5, 0.6, 0.8] },
                { id: 'cy_frostwall', name: 'ãƒ•ãƒ­ã‚¹ãƒˆã‚¦ã‚©ãƒ¼ãƒ«', icon: 'ğŸ§±', mp: 25, cd: 6.0, branch: 1, desc: 'Frost wall', prereq: 'cy_shiverarmor', effect: 'stun_aoe', duration: [1.5, 2.0, 2.5, 3.0, 4.0], range: 100 },
                { id: 'cy_glacialshield', name: 'ã‚°ãƒ¬ã‚¤ã‚·ãƒ£ãƒ«ã‚·ãƒ¼ãƒ«ãƒ‰', icon: 'ğŸ’ ', mp: 28, cd: 10.0, branch: 1, desc: 'Glacial shield', prereq: 'cy_frostwall', effect: 'mana_shield', duration: [5, 7, 9, 12, 15], absorb: [0.4, 0.5, 0.6, 0.7, 0.8] },
                { id: 'cy_energyshield', name: 'ã‚¨ãƒŠã‚¸ãƒ¼ã‚·ãƒ¼ãƒ«ãƒ‰', icon: 'ğŸ”·', mp: 35, cd: 12.0, branch: 1, desc: 'Energy shield', prereq: 'cy_glacialshield', effect: 'mana_shield', duration: [6, 8, 10, 14, 18], absorb: [0.5, 0.6, 0.7, 0.75, 0.85] },
                { id: 'cy_icebarrier', name: 'ã‚¢ã‚¤ã‚¹ãƒãƒªã‚¢', icon: 'ğŸ”', mp: 40, cd: 12.0, branch: 1, desc: 'Ice barrier', prereq: 'cy_energyshield', effect: 'buff_defense', duration: [8, 10, 12, 16, 20], reduction: [0.5, 0.6, 0.65, 0.7, 0.8] },
                { id: 'cy_arcticsurge', name: 'ã‚¢ãƒ¼ã‚¯ãƒ†ã‚£ãƒƒã‚¯ã‚µãƒ¼ã‚¸', icon: 'ğŸŒŠ', mp: 55, cd: 15.0, branch: 1, desc: 'Arctic surge', prereq: 'cy_icebarrier', effect: 'buff_aura', duration: [8, 10, 14, 18, 22], regen: [4, 6, 8, 12, 16], reduction: [0.2, 0.3, 0.35, 0.4, 0.5] },
                // Branch 2: ã‚¢ã‚¤ã‚¹ãƒã‚¹ã‚¿ãƒªãƒ¼
                { id: 'cy_frostnova', name: 'ãƒ•ãƒ­ã‚¹ãƒˆãƒãƒ´ã‚¡', icon: 'ğŸ’ ', mp: 14, cd: 3.0, branch: 2, desc: 'Frost nova', prereq: null, effect: 'frost_nova', baseMult: [1.0, 1.3, 1.6, 2.0, 2.5], freeze: [1, 2, 2, 3, 4] },
                { id: 'cy_iceshards', name: 'ã‚¢ã‚¤ã‚¹ã‚·ãƒ£ãƒ¼ãƒ‰', icon: 'ğŸ”¹', mp: 16, cd: 2.0, branch: 2, desc: 'Ice shards', prereq: 'cy_frostnova', effect: 'multi_shot', arrows: [3, 3, 4, 5, 6], baseMult: [1.0, 1.3, 1.6, 2.0, 2.5] },
                { id: 'cy_freezingpulse', name: 'ãƒ•ãƒªãƒ¼ã‚¸ãƒ³ã‚°ãƒ‘ãƒ«ã‚¹', icon: 'â„', mp: 20, cd: 3.5, branch: 2, desc: 'Freezing pulse', prereq: 'cy_iceshards', effect: 'frost_nova', baseMult: [1.5, 2.0, 2.5, 3.0, 4.0], freeze: [2, 2, 3, 4, 5] },
                { id: 'cy_coldmastery', name: 'ã‚³ãƒ¼ãƒ«ãƒ‰ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'ğŸ¥¶', mp: 22, cd: 8.0, branch: 2, desc: 'Cold mastery', prereq: 'cy_freezingpulse', effect: 'debuff_defense', duration: [4, 6, 8, 10, 13], reduction: [0.3, 0.4, 0.5, 0.6, 0.7], range: 140 },
                { id: 'cy_glacialstorm', name: 'ã‚°ãƒ¬ã‚¤ã‚·ãƒ£ãƒ«ã‚¹ãƒˆãƒ¼ãƒ ', icon: 'ğŸŒ¨', mp: 30, cd: 6.0, branch: 2, desc: 'Glacial storm', prereq: 'cy_coldmastery', effect: 'arrow_rain', baseMult: [2.0, 2.5, 3.2, 4.0, 5.5], range: 120 },
                { id: 'cy_wintersfury', name: 'ã‚¦ã‚¤ãƒ³ã‚¿ãƒ¼ã‚ºãƒ•ãƒ¥ãƒ¼ãƒªãƒ¼', icon: 'â„', mp: 38, cd: 7.0, branch: 2, desc: 'Winters fury', prereq: 'cy_glacialstorm', effect: 'frost_nova', baseMult: [2.5, 3.2, 4.0, 5.0, 6.5], freeze: [3, 4, 5, 6, 7] },
                { id: 'cy_frozenorb', name: 'ãƒ•ãƒ­ãƒ¼ã‚ºãƒ³ã‚ªãƒ¼ãƒ–', icon: 'ğŸŒ', mp: 48, cd: 8.0, branch: 2, desc: 'Frozen orb', prereq: 'cy_wintersfury', effect: 'frozen_orb', baseMult: [3.0, 4.0, 5.0, 6.5, 8.5], speed: 200, shardCount: [6, 8, 10, 12, 14] },
                { id: 'cy_blizzardmastery', name: 'ãƒ–ãƒªã‚¶ãƒ¼ãƒ‰ãƒã‚¹ã‚¿ãƒªãƒ¼', icon: 'ğŸŒ€', mp: 60, cd: 12.0, branch: 2, desc: 'Blizzard mastery', prereq: 'cy_frozenorb', effect: 'arrow_rain', baseMult: [4.5, 5.5, 7.0, 9.0, 12.0], range: 160 }
            ]
        }
    };

    // ========== CLASS CHANGE SYSTEM ==========
    const CLASS_PROMOTIONS = {
        warrior: [
            { key: 'paladin', name: 'è–é¨å£«', icon: 'â›¨', desc: 'è–ãªã‚‹åŠ›ã§å‘³æ–¹ã‚’å®ˆã‚Šæ•µã‚’æµ„åŒ–ã™ã‚‹é¨å£«ã€‚é˜²å¾¡ã¨å›å¾©ã«å„ªã‚Œã‚‹ã€‚' },
            { key: 'berserker', name: 'ç‹‚æˆ¦å£«', icon: 'ğŸª“', desc: 'æ€’ã‚Šã®åŠ›ã§åœ§å€’çš„ãªç«åŠ›ã‚’å©ãå‡ºã™æˆ¦å£«ã€‚æ”»æ’ƒã«å…¨æŒ¯ã‚Šã€‚' }
        ],
        rogue: [
            { key: 'assassin', name: 'æš—æ®ºè€…', icon: 'ğŸ—¡', desc: 'å½±ã«æ½œã¿æ€¥æ‰€ã‚’çªãæš—æ®ºã®ãƒ—ãƒ­ã€‚å˜ä½“ç«åŠ›ã¨å›é¿ã«ç‰¹åŒ–ã€‚' },
            { key: 'ranger', name: 'ç‹©äºº', icon: 'ğŸ¹', desc: 'é è·é›¢ã‹ã‚‰ã®ç²¾å¯†å°„æ’ƒã¨ç½ ã§æˆ¦å ´ã‚’æ”¯é…ã™ã‚‹ã€‚' }
        ],
        sorcerer: [
            { key: 'pyromancer', name: 'ç‚è¡“å¸«', icon: 'ğŸ”¥', desc: 'ç‚ã¨çˆ†ç™ºã®é­”æ³•ã§æ®²æ»…ã™ã‚‹ã€‚åœ§å€’çš„ãªç¯„å›²ç«åŠ›ã€‚' },
            { key: 'cryomancer', name: 'æ°·è¡“å¸«', icon: 'â„', desc: 'å‡çµã¨æ°·ã®é˜²å£ã§æˆ¦å ´ã‚’åˆ¶å¾¡ã™ã‚‹ã€‚CCç‰¹åŒ–å‹ã€‚' }
        ]
    };

    const PROMOTION_LEVEL = 10;
    let promotionPending = false;

    function checkPromotion() {
        if (player.level >= PROMOTION_LEVEL && !promotionPending) {
            const classDef = CLASS_DEFS[G.playerClass];
            if (classDef.tier === 0 && classDef.promotions && classDef.promotions.length > 0) {
                promotionPending = true;
                setPaused(true);
                showPromotionUI();
            }
        }
    }

    function showPromotionUI() {
        const promos = CLASS_PROMOTIONS[G.playerClass];
        if (!promos) return;
        const overlay = DOM.promotionOverlay;
        const content = DOM.promotionContent;
        let html = '<div style="text-align:center;margin-bottom:15px"><span style="color:#ffd700;font-size:22px;font-weight:bold;text-shadow:0 0 10px #ffd700">ã‚¯ãƒ©ã‚¹ãƒã‚§ãƒ³ã‚¸</span><br><span style="color:#aaa;font-size:12px">ãƒ¬ãƒ™ãƒ«10åˆ°é”ï¼ä¸Šä½ã‚¯ãƒ©ã‚¹ã‚’é¸æŠã—ã¦ãã ã•ã„</span></div>';
        for (const p of promos) {
            const cd = CLASS_DEFS[p.key];
            html += `<div class="promo-card" onclick="doPromotion('${p.key}')">
                <div style="font-size:28px;margin-bottom:5px">${p.icon}</div>
                <div style="color:#ffd700;font-size:16px;font-weight:bold">${p.name}</div>
                <div style="color:#aaa;font-size:10px;margin-bottom:6px">${cd.engName}</div>
                <div style="color:#ccc;font-size:11px;margin-bottom:8px">${p.desc}</div>
                <div style="color:#888;font-size:10px">STR:${cd.baseStr} DEX:${cd.baseDex} VIT:${cd.baseVit} INT:${cd.baseInt}</div>
                <div style="color:#66aaff;font-size:10px;margin-top:4px">ã‚¹ã‚­ãƒ«ãƒ–ãƒ©ãƒ³ãƒ: ${cd.branches.join(' / ')}</div>
            </div>`;
        }
        content.innerHTML = html;
        overlay.style.display = 'flex';
        DOM.pauseOverlay.style.display = 'none';
    }

    window.doPromotion = function(newClass) {
        const newDef = CLASS_DEFS[newClass];
        if (!newDef) return;
        G.playerClass = newClass;
        player.classKey = newClass;
        player.className = newDef.name;
        // Apply stat bonuses (keep allocated stats, update base)
        const oldDef = CLASS_DEFS[newDef.baseClass];
        player.str += newDef.baseStr - oldDef.baseStr;
        player.dex += newDef.baseDex - oldDef.baseDex;
        player.vit += newDef.baseVit - oldDef.baseVit;
        player.int += newDef.baseInt - oldDef.baseInt;
        // Keep old skill levels, add new skills with level 0
        for (const sk of newDef.skills) {
            if (!(sk.id in player.skillLevels)) {
                player.skillLevels[sk.id] = 0;
            }
        }
        // Unlock first skill in each branch
        player.skillLevels[newDef.skills[0].id] = Math.max(1, player.skillLevels[newDef.skills[0].id] || 0);
        player.skillLevels[newDef.skills[3].id] = Math.max(1, player.skillLevels[newDef.skills[3].id] || 0);
        player.skillLevels[newDef.skills[6].id] = Math.max(1, player.skillLevels[newDef.skills[6].id] || 0);
        // Give bonus skill points
        player.skillPoints = (player.skillPoints || 0) + 3;
        // Rebuild skill bar from new class
        rebuildSkillBar();
        player.recalcStats();
        player.hp = player.maxHP;
        player.mp = player.maxMP;
        promotionPending = false;
        setPaused(false);
        DOM.promotionOverlay.style.display = 'none';
        addLog(`${newDef.name}ã«ã‚¯ãƒ©ã‚¹ãƒã‚§ãƒ³ã‚¸ï¼`, '#ffd700');
        sfxLevelUp();
        emitParticles(player.x, player.y, '#ffd700', 30, 100, 1.0, 5, -40);
    };

    // ========== SKILL BAR MANAGEMENT ==========
    function rebuildSkillBar() {
        // ã‚¹ã‚­ãƒ«ã‚¹ãƒ­ãƒƒãƒˆã¯ç©ºã®ã¾ã¾ - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè‡ªåˆ†ã§è¨­å®šã™ã‚‹
        player.skills = {};
    }

    function getAllAvailableSkills() {
        const classDef = CLASS_DEFS[G.playerClass];
        const result = [...classDef.skills];
        // Also include base class skills if promoted
        if (classDef.baseClass && CLASS_DEFS[classDef.baseClass]) {
            for (const sk of CLASS_DEFS[classDef.baseClass].skills) {
                if (!result.find(s => s.id === sk.id)) {
                    result.push(sk);
                }
            }
        }
        return result;
    }

    let skillSelectOpen = false;
    let skillSelectSlot = 0;
    let skillSwapFrom = 0;
    let skillEditMode = 'assign'; // 'assign' | 'swap'
    let treeSwapFromSlot = 0;

    function showSkillSelectUI() {
        skillSelectOpen = true;
        const overlay = DOM.skillSelectOverlay;
        const content = DOM.skillSelectContent;
        const allSkills = getAllAvailableSkills();
        const swapLabel = skillSwapFrom ? `å…¥ã‚Œæ›¿ãˆ: ã‚¹ãƒ­ãƒƒãƒˆ${skillSwapFrom} â†’ ç›¸æ‰‹ã‚’é¸æŠ` : 'å…¥ã‚Œæ›¿ãˆ: å…ˆã«ã‚¹ãƒ­ãƒƒãƒˆã‚’é¸ã¶';
        const modeLabel = skillEditMode === 'swap' ? 'å…¥ã‚Œæ›¿ãˆãƒ¢ãƒ¼ãƒ‰' : 'è¨­å®šãƒ¢ãƒ¼ãƒ‰';
        let html = '<div style="text-align:center;margin-bottom:12px"><span style="color:#ffd700;font-size:18px;font-weight:bold">ã‚¹ã‚­ãƒ«ã‚»ãƒƒãƒˆç·¨é›†</span><br><span style="color:#aaa;font-size:11px">ã‚¯ãƒªãƒƒã‚¯ or 1~6 ã§ã‚¹ãƒ­ãƒƒãƒˆé¸æŠ / A:è¨­å®š / W:å…¥æ›¿ / X:å¤–ã™ / R:é–‰ã˜ã‚‹</span>';
        html += `<div style="margin-top:6px">
            <button class="toggle-btn ${skillEditMode === 'assign' ? '' : 'off'}" onclick="setSkillEditMode('assign')">è¨­å®š</button>
            <button class="toggle-btn ${skillEditMode === 'swap' ? '' : 'off'}" onclick="setSkillEditMode('swap')">å…¥ã‚Œæ›¿ãˆ</button>
            <button class="toggle-btn" style="background:#884444;margin-left:6px" onclick="removeSkillSlot()">å¤–ã™</button>
            <span style="color:#66ccff;font-size:10px;margin-left:6px">${modeLabel}${skillEditMode === 'swap' ? ' / ' + swapLabel : ''}</span>
        </div></div>`;

        // Current slots (icons)
        html += '<div style="display:flex;gap:6px;justify-content:center;margin-bottom:6px">';
        for (let i = 1; i <= 6; i++) {
            const sk = player.skills[i];
            const sel = skillSelectSlot === i;
            const swapFrom = skillSwapFrom === i;
            html += `<div class="skill-slot-pick ${sel ? 'selected' : ''} ${swapFrom ? 'swap-from' : ''}" onclick="pickSlot(${i})" draggable="true"
                ondragstart="onSkillSlotDragStart(event,${i})" ondragover="onSkillSlotDragOver(event)" ondrop="onSkillSlotDrop(event,${i})">
                <div class="emoji-font" style="font-size:20px">${sk ? sk.icon : 'â–¡'}</div>
                <div style="font-size:8px;color:#aaa">${i}</div>
            </div>`;
        }
        html += '</div>';
        html += `<div style="text-align:center;margin-bottom:8px;color:#aaa;font-size:11px">é¸æŠã‚¹ãƒ­ãƒƒãƒˆ: ${skillSelectSlot || '-'}</div>`;

        // Slot controls (explicit buttons)
        html += '<div style="display:grid;grid-template-columns:1fr;gap:4px;margin-bottom:8px">';
        for (let i = 1; i <= 6; i++) {
            const sk = player.skills[i];
            const name = sk ? sk.name : 'ç©º';
            const swapBtn = skillSwapFrom && skillSwapFrom !== i
                ? `<button class="toggle-btn" onclick="forceSwapSlots(${i})">ã“ã“ã«å…¥æ›¿</button>`
                : `<button class="toggle-btn" onclick="beginSwap(${i})">å…¥æ›¿é–‹å§‹</button>`;
            html += `<div style="display:flex;align-items:center;justify-content:space-between;gap:6px">
                <div style="font-size:11px;color:#bbb">ã‚¹ãƒ­ãƒƒãƒˆ${i}: ${name}</div>
                <div style="display:flex;gap:4px">
                    <button class="toggle-btn" onclick="pickSlot(${i})">é¸æŠ</button>
                    <button class="toggle-btn" style="background:#884444" onclick="removeSkillSlot(${i})">å¤–ã™</button>
                    ${swapBtn}
                </div>
            </div>`;
        }
        html += '</div>';

        // Available skills grid
        if (skillSelectSlot > 0) {
            html += `<div style="color:#ffd700;font-size:12px;margin-bottom:8px;text-align:center">ã‚¹ãƒ­ãƒƒãƒˆ${skillSelectSlot}ã«è¨­å®šã™ã‚‹ã‚¹ã‚­ãƒ«:</div>`;
            html += '<div style="display:flex;flex-wrap:wrap;gap:6px;justify-content:center">';
            for (const sk of allSkills) {
                const lvl = player.skillLevels[sk.id] || 0;
                const locked = lvl < 1;
                html += `<div class="skill-pick-item ${locked ? 'locked' : ''}" onclick="${locked ? '' : `assignSkill('${sk.id}')`}" onmouseenter="showSkillTooltip(event,'${sk.id}')" onmouseleave="hideTooltip()">
                    <div class="emoji-font" style="font-size:18px">${sk.icon}</div>
                    <div style="font-size:9px;color:${locked ? '#666' : '#ffd700'}">${sk.name}</div>
                    <div style="font-size:8px;color:${locked ? '#444' : '#88f'}">Lv.${lvl} MP:${sk.mp}</div>
                </div>`;
            }
            html += '</div>';
        }

        html += '<div style="text-align:center;margin-top:12px"><button class="close-btn" onclick="closeSkillSelect()">é–‰ã˜ã‚‹ (R)</button></div>';
        content.innerHTML = html;
        overlay.style.display = 'flex';
    }

    function swapSkillSlots(a, b) {
        // ã‚ˆã‚Šç¢ºå®Ÿãªå…¥ã‚Œæ›¿ãˆï¼ˆdeepã‚³ãƒ”ãƒ¼ï¼‰
        const tmpA = player.skills[a] ? { ...player.skills[a] } : null;
        const tmpB = player.skills[b] ? { ...player.skills[b] } : null;
        if (tmpB) {
            player.skills[a] = { ...tmpB };
        } else {
            delete player.skills[a];
        }
        if (tmpA) {
            player.skills[b] = { ...tmpA };
        } else {
            delete player.skills[b];
        }
    }
    function selectOrSwapSkillSlot(slot) {
        const shiftSwap = !!(keysDown['shift'] || keysDown['ShiftLeft'] || keysDown['ShiftRight']);
        if (skillEditMode === 'assign' && !shiftSwap) {
            skillSelectSlot = slot;
            skillSwapFrom = 0;
            showSkillSelectUI();
            return;
        }
        if (!skillSwapFrom) {
            skillSwapFrom = slot;
            skillSelectSlot = slot;
            showSkillSelectUI();
            return;
        }
        if (skillSwapFrom === slot) {
            skillSwapFrom = 0;
            skillSelectSlot = slot;
            showSkillSelectUI();
            return;
        }
        swapSkillSlots(skillSwapFrom, slot);
        skillSwapFrom = 0;
        skillSelectSlot = slot;
        showSkillSelectUI();
    }
    window.pickSlot = function(slot) {
        selectOrSwapSkillSlot(slot);
    };

    window.assignSkill = function(skillId) {
        if (skillSelectSlot < 1 || skillSelectSlot > 6) {
            addLog('å…ˆã«ã‚¹ãƒ­ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„', '#ffaa44');
            return;
        }
        const allSkills = getAllAvailableSkills();
        const sk = allSkills.find(s => s.id === skillId);
        if (!sk) return;
        if ((player.skillLevels[sk.id] || 0) < 1) return;
        player.skills[skillSelectSlot] = {
            id: sk.id, name: sk.name, icon: sk.icon,
            mp: sk.mp, cooldown: 0, maxCD: sk.cd, desc: sk.desc
        };
        showSkillSelectUI();
    };

    window.removeSkillSlot = function(slot) {
        const s = slot || skillSelectSlot;
        if (!s || s < 1 || s > 6) {
            addLog('å…ˆã«ã‚¹ãƒ­ãƒƒãƒˆã‚’é¸æŠã—ã¦ãã ã•ã„', '#ffaa44');
            return;
        }
        if (player.skills[s]) {
            const skillName = player.skills[s].name || 'ã‚¹ã‚­ãƒ«';
            delete player.skills[s];
            addLog(`ã‚¹ãƒ­ãƒƒãƒˆ${s}ã‹ã‚‰${skillName}ã‚’å‰Šé™¤`, '#ff8844');
            showSkillSelectUI();
        } else {
            addLog(`ã‚¹ãƒ­ãƒƒãƒˆ${s}ã¯ç©ºã§ã™`, '#888');
        }
    };
    window.removeSkillById = function(skillId) {
        let removed = false;
        for (let i = 1; i <= 6; i++) {
            if (player.skills[i] && player.skills[i].id === skillId) {
                delete player.skills[i];
                removed = true;
            }
        }
        if (removed) addLog('ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‹ã‚‰å¤–ã—ã¾ã—ãŸ', '#ff8844');
        else addLog('ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã«ã‚ã‚Šã¾ã›ã‚“', '#888');
    };
    function findSlotBySkillId(skillId) {
        for (let i = 1; i <= 6; i++) {
            if (player.skills[i] && player.skills[i].id === skillId) return i;
        }
        return 0;
    }
    window.beginTreeSwap = function(skillId) {
        const slot = findSlotBySkillId(skillId);
        if (!slot) {
            addLog('ã“ã®ã‚¹ã‚­ãƒ«ã¯ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã«ã‚ã‚Šã¾ã›ã‚“', '#ffaa44');
            return;
        }
        treeSwapFromSlot = slot;
        updateSkillTreeUI();
    };
    window.cancelTreeSwap = function() {
        treeSwapFromSlot = 0;
        treeSwapFromSkillId = '';
        updateSkillTreeUI();
    };
    window.treeSwapTo = function(targetSlot) {
        if (!treeSwapFromSlot || treeSwapFromSlot === targetSlot) return;
        swapSkillSlots(treeSwapFromSlot, targetSlot);
        treeSwapFromSlot = 0;
        updateSkillTreeUI();
        addLog('ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆã‚’å…¥ã‚Œæ›¿ãˆã¾ã—ãŸ', '#66ff66');
    };
    window.treeSwapWithSkill = undefined;

    window.closeSkillSelect = function() {
        skillSelectOpen = false;
        skillSwapFrom = 0;
        skillEditMode = 'assign';
        DOM.skillSelectOverlay.style.display = 'none';
    };
    function openSkillEdit() {
        console.log('[openSkillEdit] Called! G.dead:', G.dead, 'G.started:', G.started);
        if (!G.started) {
            console.log('[openSkillEdit] BLOCKED: Game not started');
            return;
        }
        console.log('[openSkillEdit] Opening skill UI...');
        skillSelectSlot = 1;
        skillSwapFrom = 0;
        skillEditMode = 'assign';
        showSkillSelectUI();
    }
    window.setSkillEditMode = function(mode) {
        skillEditMode = mode === 'swap' ? 'swap' : 'assign';
        skillSwapFrom = 0;
        showSkillSelectUI();
    };
    window.beginSwap = function(slot) {
        skillEditMode = 'swap';
        skillSwapFrom = slot;
        skillSelectSlot = slot;
        showSkillSelectUI();
    };
    window.forceSwapSlots = function(targetSlot) {
        if (!skillSwapFrom || skillSwapFrom === targetSlot) return;
        swapSkillSlots(skillSwapFrom, targetSlot);
        skillSwapFrom = 0;
        skillSelectSlot = targetSlot;
        showSkillSelectUI();
    };
    window.quickAssignSkill = function(skillId) {
        // ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ã‹ã‚‰ç›´æ¥ã‚¹ãƒ­ãƒƒãƒˆã«å‰²ã‚Šå½“ã¦
        const allSkills = getAllAvailableSkills();
        const sk = allSkills.find(s => s.id === skillId);
        if (!sk || (player.skillLevels[sk.id] || 0) < 1) return;

        // ç©ºã„ã¦ã„ã‚‹ã‚¹ãƒ­ãƒƒãƒˆã‚’æ¢ã™
        let emptySlot = 0;
        for (let i = 1; i <= 6; i++) {
            if (!player.skills[i] || !player.skills[i].id) {
                emptySlot = i;
                break;
            }
        }

        if (emptySlot > 0) {
            // ç©ºãã‚¹ãƒ­ãƒƒãƒˆã«è‡ªå‹•å‰²ã‚Šå½“ã¦
            player.skills[emptySlot] = {
                id: sk.id, name: sk.name, icon: sk.icon,
                mp: sk.mp, cooldown: 0, maxCD: sk.cd, desc: sk.desc
            };
            addLog(`${sk.name} ã‚’ã‚¹ãƒ­ãƒƒãƒˆ${emptySlot}ã«è¨­å®šï¼`, '#66ff66');
        } else {
            // ç©ºããŒãªã„å ´åˆã¯ã‚¹ãƒ­ãƒƒãƒˆé¸æŠç”»é¢ã‚’é–‹ã
            addLog('ã‚¹ãƒ­ãƒƒãƒˆãŒæº€æ¯ã§ã™ã€‚å…¥ã‚Œæ›¿ãˆã¦ãã ã•ã„', '#ffaa44');
            skillSelectSlot = 1;
            skillSwapFrom = 0;
            skillEditMode = 'assign';
            showSkillSelectUI();
        }
    };
    window.onSkillSlotDragStart = function(e, slot) {
        if (!e || !e.dataTransfer) return;
        e.dataTransfer.setData('text/plain', String(slot));
        e.dataTransfer.effectAllowed = 'move';
    };
    window.onSkillSlotDragOver = function(e) {
        e.preventDefault();
        if (e.dataTransfer) e.dataTransfer.dropEffect = 'move';
    };
    window.onSkillSlotDrop = function(e, slot) {
        e.preventDefault();
        if (!e || !e.dataTransfer) return;
        const from = parseInt(e.dataTransfer.getData('text/plain'), 10);
        if (!from || from === slot) return;
        swapSkillSlots(from, slot);
        skillSwapFrom = 0;
        skillSelectSlot = slot;
        showSkillSelectUI();
    };

    function renderTitleSaveMenu() {
        if (!DOM.titleSaveContent) return;
        let html = '';
        for (let i = 1; i <= SAVE_SLOT_COUNT; i++) {
            const meta = getSaveMeta(i);
            const active = G.saveSlot === i;
            const info = meta
                ? `Lv.${meta.level} / B${meta.floor}F / ${meta.className}`
                : 'ç©º';
            const time = meta && meta.timestamp
                ? new Date(meta.timestamp).toLocaleString('ja-JP')
                : '';
            html += `<div class="title-save-row">
                <div>
                    <div style="color:#ddb27a;font-size:12px">ã‚¹ãƒ­ãƒƒãƒˆ${i}${active ? ' â˜…' : ''}</div>
                    <div class="title-save-info">${info}${time ? ' / ' + time : ''}</div>
                </div>
                <div class="title-save-actions">
                    <button class="toggle-btn ${active ? '' : 'off'}" onclick="setSaveSlot(${i})">é¸æŠ</button>
                    ${meta ? `<button class="toggle-btn" onclick="loadGame(${i})">ãƒ­ãƒ¼ãƒ‰</button>` : ''}
                    <button class="toggle-btn" onclick="startNewGame(${i})">æ–°è¦</button>
                </div>
            </div>`;
        }
        DOM.titleSaveContent.innerHTML = html;
    }

    window.startNewGame = function(slot) {
        setSaveSlot(slot);
        if (hasSaveData(slot)) {
            const ok = confirm(`ã‚¹ãƒ­ãƒƒãƒˆ${slot}ã«ã¯ã‚»ãƒ¼ãƒ–ãŒã‚ã‚Šã¾ã™ã€‚æ–°è¦é–‹å§‹ã—ã¾ã™ã‹ï¼Ÿ`);
            if (!ok) return;
        }
        showClassSelect();
    };


    // ========== COLLISION HELPER ==========
    // Check if a circle at (px, py) with radius r can stand on walkable tiles
    function canWalk(px, py, r) {
        // Check the 4 cardinal edge points + center
        const points = [
            [px, py],
            [px - r, py], [px + r, py],
            [px, py - r], [px, py + r]
        ];
        for (const [x, y] of points) {
            const tx = Math.floor(x / TILE), ty = Math.floor(y / TILE);
            if (!dungeon.walkable(tx, ty)) return false;
        }
        return true;
    }

    // ========== GROUND ITEMS ==========
    const groundItems = [];
    class GroundItem {
        constructor(x, y, item) {
            this.x = x; this.y = y;
            this.item = item;
            this.bobT = randf(0, Math.PI * 2);
        }
    }
    function dropItem(x, y, item) {
        groundItems.push(new GroundItem(x + randf(-15, 15), y + randf(-15, 15), item));
    }

    // ========== PLAYER ==========
    const player = {
        x: 0, y: 0,
        targetX: 0, targetY: 0,
        radius: 14,
        speed: 160,
        vx: 0, vy: 0, // ç¾åœ¨ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆæ…£æ€§ç”¨ï¼‰
        acceleration: 2500, // åŠ é€Ÿåº¦ï¼ˆãƒã‚¯ã‚¹ãƒ©ç”¨ã«é«˜é€Ÿï¼‰
        deceleration: 3000, // æ¸›é€Ÿåº¦ï¼ˆã‚­ãƒ“ã‚­ãƒ“æ„Ÿï¼‰
        moving: false,
        attacking: false,
        attackTarget: null,
        attackCooldown: 0,
        attackAnimT: 0,
        whirlwindT: 0,

        // Stats
        level: 1,
        xp: 0,
        xpToNext: 100,
        statPoints: 0,
        str: 10, dex: 10, vit: 10, int: 10,

        hp: 100, maxHP: 100,
        mp: 50, maxMP: 50,
        defense: 2,
        critChance: 5,

        // Equipment
        equipment: { weapon: null, offhand: null, head: null, body: null, ring: null, amulet: null, feet: null },
        inventory: [], // max 24
        maxInv: 24,

        // Skills
        selectedSkill: 1,
        freezeT: 0, // freeze nova effect timer
        shieldT: 0, // magic shield timer
        meteorT: 0, // meteor delay
        berserkT: 0,
        dodgeT: 0,
        dodgeChance: 0,
        manaShieldT: 0,
        manaShieldAbsorb: 0,
        shieldReduction: 0.5,
        counterT: 0, counterReflect: 0,
        speedBuffT: 0, speedBuffBonus: 0,
        poisonBuffT: 0, poisonDps: 0,
        atkSpdBuffT: 0, atkSpdBonus: 0,
        lifestealBuffT: 0, lifestealBuffPct: 0,
        undyingT: 0,
        stealthT: 0,
        critBuffT: 0, critBuffBonus: 0,
        auraT: 0, auraRegen: 0, auraReduction: 0,
        attackTimer: 0,
        battleOrdersT: 0, battleOrdersHP: 0, battleOrdersMP: 0,
        skillPoints: 0,
        skillLevels: {},
        classKey: 'warrior',
        className: 'æˆ¦å£«',
        skills: {
            // åˆæœŸã¯ç©º - ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè‡ªåˆ†ã§è¨­å®šã™ã‚‹
        },

        getAttackDmg() {
            let base = this.str * 0.8 + 5;
            const w = this.equipment.weapon;
            if (w && w.baseDmg) base += rand(w.baseDmg[0], w.baseDmg[1]);
            // Affix bonuses
            let dmgPct = 0;
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === 'dmgPct') dmgPct += a.value;
                }
            }
            let finalDmg = Math.round(base * (1 + dmgPct / 100));
            if (this.berserkT > 0) finalDmg = Math.round(finalDmg * 2);
            return finalDmg;
        },

        getDefense() {
            let def = this.defense;
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                if (slot.baseDef) def += slot.baseDef;
                for (const a of slot.affixes) {
                    if (a.stat === 'def') def += a.value;
                }
            }
            return def;
        },

        getTotalStat(stat) {
            let val = this[stat];
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === stat) val += a.value;
                }
            }
            return val;
        },

        getCritChance() {
            let c = this.critChance + this.dex * 0.3;
            if (this.stealthT > 0) c = 100;
            if (this.critBuffT > 0) c += (this.critBuffBonus || 0);
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === 'critChance') c += a.value;
                }
            }
            return c;
        },

        getLifesteal() {
            let ls = 0;
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === 'lifesteal') ls += a.value;
                }
            }
            return ls;
        },

        recalcStats() {
            let bonusHP = 0, bonusMP = 0, bonusSpd = 0;
            for (const slot of Object.values(this.equipment)) {
                if (!slot) continue;
                for (const a of slot.affixes) {
                    if (a.stat === 'hp') bonusHP += a.value;
                    if (a.stat === 'mp') bonusMP += a.value;
                    if (a.stat === 'vit') bonusHP += a.value * 5;
                    if (a.stat === 'int') bonusMP += a.value * 3;
                    if (a.stat === 'moveSpd') bonusSpd += a.value;
                }
            }
            this.maxHP = 80 + this.vit * 5 + this.level * 10 + bonusHP;
            this.maxMP = 30 + this.int * 3 + this.level * 5 + bonusMP;
            this.speed = 160 * (1 + bonusSpd / 100) * (1 + (this.speedBuffBonus || 0));
            this.hp = Math.min(this.hp, this.maxHP);
            this.mp = Math.min(this.mp, this.maxMP);
        },

        addXP(amount) {
            this.xp += amount;
            while (this.xp >= this.xpToNext) {
                this.xp -= this.xpToNext;
                this.level++;
                this.statPoints += 5;
                this.skillPoints = (this.skillPoints || 0) + 1;
                this.xpToNext = Math.round(100 * Math.pow(1.3, this.level - 1));
                this.recalcStats();
                this.hp = this.maxHP;
                this.mp = this.maxMP;
                sfxLevelUp();
                showLevelUp();
                addLog(`ãƒ¬ãƒ™ãƒ« ${this.level} ã«ä¸ŠãŒã£ãŸï¼`, '#ffd700');
                checkPromotion();
            }
        },

        takeDamage(raw) {
            const def = this.getDefense();
            let dmg = Math.max(1, Math.round(raw * (100 / (100 + def))));
            // Dodge check
            if (this.dodgeT > 0 && Math.random() * 100 < (this.dodgeChance || 0)) {
                addFloatingText(this.x, this.y - 20, 'DODGE!', '#aaffaa');
                emitParticles(this.x, this.y, '#aaffaa', 5, 40, 0.2, 2, -30);
                return;
            }
            // Berserk increases damage taken
            if (this.berserkT > 0) dmg = Math.round(dmg * 1.3);
            // Magic Shield reduces damage by 50%
            if (this.shieldT > 0) {
                dmg = Math.max(1, Math.round(dmg * 0.5));
                emitParticles(this.x, this.y, '#8888ff', 4, 40, 0.2, 2, -30);
            }
            // Mana Shield - absorb damage with MP
            if (this.manaShieldT > 0 && this.mp > 0) {
                const absorbed = Math.round(dmg * (this.manaShieldAbsorb || 0.5));
                const mpCost = absorbed;
                if (this.mp >= mpCost) {
                    this.mp -= mpCost;
                    dmg -= absorbed;
                    emitParticles(this.x, this.y, '#4488ff', 4, 40, 0.2, 2, -30);
                }
            }
            this.hp -= dmg;
            addFloatingText(this.x, this.y - 20, dmg, '#ff4444');
            emitParticles(this.x, this.y, '#ff0000', 8, 80, 0.4, 3);
            emitParticles(this.x, this.y, '#880000', 4, 40, 0.3, 2, 100);
            G.shakeT = 0.2; G.shakeAmt = 10; // Diabloé¢¨ï¼š2å€
            G.dmgFlashT = 0.35; // Screen blood flash
            // Counter-attack
            if (this.counterT > 0 && this.counterReflect > 0) {
                const reflectDmg = Math.round(raw * this.counterReflect);
                // Find nearest monster
                let nearest = null, nearD = 100;
                for (const m of monsters) {
                    if (!m.alive) continue;
                    const d = dist(this.x, this.y, m.x, m.y);
                    if (d < nearD) { nearD = d; nearest = m; }
                }
                if (nearest) {
                    monsterTakeDmg(nearest, reflectDmg, false);
                    addFloatingText(nearest.x, nearest.y - 20, 'åæ’ƒ!' + reflectDmg, '#ffcc44');
                    emitParticles(nearest.x, nearest.y, '#ffcc44', 6, 40, 0.3, 2, 0);
                }
            }
            sfxPlayerHit();
            if (this.hp <= 0) {
                if (this.undyingT > 0) {
                    this.hp = 1;
                    this.undyingT = 0;
                    addFloatingText(this.x, this.y - 30, 'ä¸æ­»èº«ï¼', '#ffd700');
                    emitParticles(this.x, this.y, '#ffd700', 20, 80, 0.6, 4, -40);
                } else {
                    this.hp = 0;
                    G.dead = true;
                sfxDeath();
                    DOM.deathScreen.style.display = 'flex';
                }
            }
        },

        pickupNearby() {
            for (let i = groundItems.length - 1; i >= 0; i--) {
                const gi = groundItems[i];
                if (dist(this.x, this.y, gi.x, gi.y) < 50) {
                    if (gi.item.typeKey === 'potion') {
                        this.hp = Math.min(this.maxHP, this.hp + 50);
                        addFloatingText(this.x, this.y - 20, '+50 HP', '#00ff00');
                        emitParticles(this.x, this.y, '#00ff00', 8, 40, 0.5, 2, -50);
                        sfxHeal();
                        addLog('å›å¾©è–¬ã‚’ä½¿ã£ãŸ (+50 HP)', '#00ff00');
                    } else if (this.inventory.length < this.maxInv) {
                        this.inventory.push(gi.item);
                        sfxPickup();
                        if (gi.item.rarityKey === 'legendary' || gi.item.rarityKey === 'unique') sfxLegendary();
                        addLog(`${gi.item.name} ã‚’æ‹¾ã£ãŸ`, gi.item.rarity.color);
                    } else {
                        addLog('ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãŒä¸€æ¯ã§ã™ï¼', '#ff4444');
                        return;
                    }
                    groundItems.splice(i, 1);
                }
            }
        },

        equipItem(invIdx) {
            const item = this.inventory[invIdx];
            if (!item || !item.typeInfo.slot) return;
            const slot = item.typeInfo.slot;
            const prev = this.equipment[slot];
            this.equipment[slot] = item;
            this.inventory.splice(invIdx, 1);
            if (prev) this.inventory.push(prev);
            this.recalcStats();
            addLog(`${item.name} ã‚’è£…å‚™ã—ãŸ`, item.rarity.color);
        },

        unequipSlot(slot) {
            if (!this.equipment[slot]) return;
            if (this.inventory.length >= this.maxInv) { addLog('ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒªãŒä¸€æ¯ï¼', '#ff4444'); return; }
            const item = this.equipment[slot];
            this.inventory.push(item);
            this.equipment[slot] = null;
            this.recalcStats();
            addLog(`${item.name} ã‚’å¤–ã—ãŸ`, '#aaa');
        },

        useSkill(mx, my) {
            const sk = this.skills[this.selectedSkill];
            if (!sk || sk.cooldown > 0 || this.mp < sk.mp) return;
            const allAvail = getAllAvailableSkills();
            const skDef = allAvail.find(s => s.id === sk.id);
            if (!skDef) return;
            const lvl = this.skillLevels[sk.id] || 0;
            if (lvl < 1) { addLog('ã‚¹ã‚­ãƒ«æœªç¿’å¾—ï¼(Tã§ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ã‚’é–‹ã)', '#ff4444'); return; }
            const li = lvl - 1; // 0-indexed level

            this.mp -= sk.mp;
            sk.cooldown = sk.maxCD;

            const wx = mx + G.camX, wy = my + G.camY;
            const dmg = this.getAttackDmg();

            switch (skDef.effect) {
                case 'melee_burst': {
                    // Power Strike / strong single hit
                    const mult = skDef.baseMult[li];
                    sfxHit();
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            const isCrit = Math.random() * 100 < this.getCritChance();
                            const d = dmg * mult * (isCrit ? 2 : 1);
                            monsterTakeDmg(m, d, isCrit);
                            break; // Single target
                        }
                    }
                    this.attackAnimT = 0.3;
                    emitParticles(this.x, this.y, '#ffaa44', 10, 80, 0.4, 4, 0, 'physical', lvl);
                    break;
                }
                case 'whirlwind': {
                    this.whirlwindT = 0.6;
                    sfxWhirlwind();
                    const mult = skDef.baseMult[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            const isCrit = Math.random() * 100 < this.getCritChance();
                            monsterTakeDmg(m, dmg * mult * (isCrit ? 2 : 1), isCrit);
                        }
                    }
                    emitParticles(this.x, this.y, '#88aaff', 20, 100, 0.5, 4, 0, 'physical', lvl);
                    break;
                }
                case 'buff_berserk': {
                    this.berserkT = skDef.duration[li];
                    playSound(200, 'sawtooth', 0.3, 0.1);
                    emitParticles(this.x, this.y, '#ff4400', 20, 80, 0.6, 4, -30, 'fire', lvl);
                    addLog(`ç‹‚æˆ¦å£«ãƒ¢ãƒ¼ãƒ‰ï¼(${skDef.duration[li]}ç§’)`, '#ff4400');
                    break;
                }
                case 'stun_aoe': {
                    const dur = skDef.duration[li];
                    playSound(150, 'square', 0.2, 0.1);
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            m.frozenT = dur;
                            m.spd = 0;
                        }
                    }
                    emitParticles(this.x, this.y, '#ffdd88', 15, 130, 0.4, 3, 0, 'physical', lvl);
                    addLog('é›„å«ã³ï¼æ•µãŒæ€¯ã‚“ã ï¼', '#ffdd88');
                    break;
                }
                case 'buff_defense': {
                    this.shieldT = skDef.duration[li];
                    this.shieldReduction = skDef.reduction[li];
                    sfxShield();
                    emitParticles(this.x, this.y, '#aaaaff', 12, 50, 0.5, 3, -40, 'arcane', lvl);
                    addLog(`é‰„å£ç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#aaaaff');
                    break;
                }
                case 'charge': {
                    // Rush toward clicked position, damage first enemy hit
                    const angle = Math.atan2(wy - this.y, wx - this.x);
                    const chargeDist = Math.min(dist(this.x, this.y, wx, wy), skDef.range);
                    const nx = this.x + Math.cos(angle) * chargeDist;
                    const ny = this.y + Math.sin(angle) * chargeDist;
                    if (canWalk(nx, ny, 10)) { this.x = nx; this.y = ny; }
                    sfxHit();
                    const mult = skDef.baseMult[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < 60) {
                            monsterTakeDmg(m, dmg * mult, false);
                        }
                    }
                    emitParticles(this.x, this.y, '#ffcc44', 15, 100, 0.4, 3, 0, 'physical', lvl);
                    G.shakeT = 0.15; G.shakeAmt = 8; // Diabloé¢¨ï¼š2å€
                    break;
                }
                case 'projectile_fire': {
                    sfxFireball();
                    const mult = skDef.baseMult[li];
                    const spd = skDef.speed || 350;
                    // Determine attribute from skill ID
                    let attr = null;
                    if (skDef.id && (skDef.id.includes('fire') || skDef.id.includes('immolation'))) attr = 'fire';
                    else if (skDef.id && (skDef.id.includes('cold') || skDef.id.includes('ice') || skDef.id.includes('frost'))) attr = 'ice';
                    else if (skDef.id && skDef.id.includes('lightning')) attr = 'lightning';
                    else attr = 'arcane'; // Default to arcane for other projectiles
                    projectiles.push(new Projectile(this.x, this.y, wx, wy, dmg * mult, '#ff4400', spd, 8, attr));
                    emitParticles(this.x, this.y, '#ff6600', 6, 50, 0.3, 3, 0, attr, lvl);
                    break;
                }
                case 'multi_shot': {
                    sfxFireball();
                    const numArrows = skDef.arrows[li];
                    const mult = skDef.baseMult[li];
                    const baseAngle = Math.atan2(wy - this.y, wx - this.x);
                    const spread = 0.4;
                    // Determine attribute from skill ID
                    let attr = null;
                    if (skDef.id && (skDef.id.includes('fire') || skDef.id.includes('immolation'))) attr = 'fire';
                    else if (skDef.id && (skDef.id.includes('cold') || skDef.id.includes('ice') || skDef.id.includes('frost'))) attr = 'ice';
                    else if (skDef.id && skDef.id.includes('lightning')) attr = 'lightning';
                    else attr = 'physical'; // Default to physical for arrows
                    for (let i = 0; i < numArrows; i++) {
                        const a = baseAngle - spread / 2 + spread * i / Math.max(1, numArrows - 1);
                        const tx = this.x + Math.cos(a) * 400;
                        const ty = this.y + Math.sin(a) * 400;
                        projectiles.push(new Projectile(this.x, this.y, tx, ty, dmg * mult, '#ffaa00', 380, 5, attr));
                    }
                    emitParticles(this.x, this.y, '#ffaa00', 8, 60, 0.3, 3, 0, attr, lvl);
                    break;
                }
                case 'arrow_rain': {
                    sfxMeteorCast();
                    this.meteorT = 0.6;
                    G.meteorX = wx; G.meteorY = wy;
                    G.meteorDmg = dmg * skDef.baseMult[li];
                    G.meteorColor = '#ffaa44';
                    for (let a = 0; a < Math.PI * 2; a += 0.4) {
                        emitParticles(wx + Math.cos(a) * skDef.range, wy + Math.sin(a) * skDef.range, '#ffaa44', 2, 20, 0.6, 2, 0, 'physical', lvl);
                    }
                    addLog('çŸ¢ã®é›¨ï¼', '#ffaa44');
                    break;
                }
                case 'place_trap': {
                    playSound(400, 'triangle', 0.1, 0.06);
                    const trap = { x: this.x, y: this.y, dmg: dmg * skDef.baseMult[li], life: 10, r: 50, triggered: false };
                    if (!G.traps) G.traps = [];
                    G.traps.push(trap);
                    emitParticles(this.x, this.y, '#ff6600', 5, 30, 0.3, 2, 0, 'nature', lvl);
                    addLog('ãƒˆãƒ©ãƒƒãƒ—ã‚’è¨­ç½®ï¼', '#ff8844');
                    break;
                }
                case 'buff_dodge': {
                    this.dodgeT = skDef.duration[li];
                    this.dodgeChance = skDef.chance[li];
                    playSound(600, 'sine', 0.15, 0.06);
                    emitParticles(this.x, this.y, '#aaffaa', 10, 50, 0.4, 2, -30, 'arcane', lvl);
                    addLog(`å›é¿ãƒ¢ãƒ¼ãƒ‰ï¼(${skDef.duration[li]}ç§’)`, '#aaffaa');
                    break;
                }
                case 'shadow_strike': {
                    // Teleport to nearest enemy and strike
                    let closest = null, closestD = 300;
                    for (const m of monsters) {
                        if (!m.alive) continue;
                        const d = dist(this.x, this.y, m.x, m.y);
                        if (d < closestD) { closestD = d; closest = m; }
                    }
                    if (closest) {
                        const angle = Math.atan2(this.y - closest.y, this.x - closest.x);
                        this.x = closest.x + Math.cos(angle) * 30;
                        this.y = closest.y + Math.sin(angle) * 30;
                        monsterTakeDmg(closest, dmg * skDef.baseMult[li], true);
                        sfxHit();
                        emitParticles(closest.x, closest.y, '#aa44ff', 15, 80, 0.4, 3, 0, 'arcane', lvl);
                    }
                    break;
                }
                case 'chain_lightning': {
                    playSweep(1000, 200, 0.2, 'sawtooth', 0.08);
                    playNoise(0.1, 0.05, 3000);
                    const mult = skDef.baseMult[li];
                    const maxBounces = skDef.bounces[li];
                    let lastX = this.x, lastY = this.y;
                    const hit = new Set();
                    for (let b = 0; b <= maxBounces; b++) {
                        let best = null, bestD = 200;
                        for (const m of monsters) {
                            if (!m.alive || hit.has(m)) continue;
                            const d = dist(lastX, lastY, m.x, m.y);
                            if (d < bestD) { bestD = d; best = m; }
                        }
                        if (!best) break;
                        hit.add(best);
                        // Draw lightning line as particles
                        const steps = 5;
                        for (let s = 0; s < steps; s++) {
                            const t = s / steps;
                            emitParticles(
                                lerp(lastX, best.x, t) + randf(-8, 8),
                                lerp(lastY, best.y, t) + randf(-8, 8),
                                '#88ccff', 1, 20, 0.3, 2, 0, 'lightning', lvl
                            );
                        }
                        monsterTakeDmg(best, dmg * mult * (b === 0 ? 1 : 0.7), false);
                        lastX = best.x; lastY = best.y;
                    }
                    break;
                }
                case 'meteor': {
                    sfxMeteorCast();
                    this.meteorT = 0.8;
                    G.meteorX = wx; G.meteorY = wy;
                    G.meteorDmg = dmg * skDef.baseMult[li];
                    G.meteorColor = '#ff4400';
                    for (let a = 0; a < Math.PI * 2; a += 0.3) {
                        emitParticles(wx + Math.cos(a) * skDef.range, wy + Math.sin(a) * skDef.range, '#ff6600', 2, 20, 0.8, 2, 0, 'fire', lvl);
                    }
                    addLog('ãƒ¡ãƒ†ã‚ªè© å”±ä¸­...', '#ff8800');
                    break;
                }
                case 'frost_nova': {
                    sfxFrostNova();
                    this.freezeT = 0.5;
                    const mult = skDef.baseMult[li];
                    const freezeDur = skDef.freeze[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < 130) {
                            monsterTakeDmg(m, dmg * mult, false);
                            m.frozenT = freezeDur;
                            m.spd = MONSTER_DEFS[m.type].spd * 0.2;
                        }
                    }
                    emitParticles(this.x, this.y, '#88ddff', 30, 130, 0.9, 4, 0, 'ice', lvl); // å¯¿å‘½1.5å€
                    emitParticles(this.x, this.y, '#ffffff', 15, 80, 0.6, 2, -30, 'ice', lvl); // å¯¿å‘½1.5å€
                    addLog('ãƒ•ãƒ­ã‚¹ãƒˆãƒãƒ´ã‚¡ï¼', '#88ddff');
                    break;
                }
                case 'teleport': {
                    const maxRange = skDef.range[li];
                    const d = dist(this.x, this.y, wx, wy);
                    const tdist = Math.min(d, maxRange);
                    const angle = Math.atan2(wy - this.y, wx - this.x);
                    const nx = this.x + Math.cos(angle) * tdist;
                    const ny = this.y + Math.sin(angle) * tdist;
                    emitParticles(this.x, this.y, '#aa88ff', 15, 60, 0.3, 3, 0, 'arcane', lvl);
                    if (canWalk(nx, ny, 10)) { this.x = nx; this.y = ny; }
                    playSweep(800, 1600, 0.1, 'sine', 0.06);
                    emitParticles(this.x, this.y, '#aa88ff', 15, 60, 0.3, 3, 0, 'arcane', lvl);
                    break;
                }
                case 'mana_shield': {
                    this.manaShieldT = skDef.duration[li];
                    this.manaShieldAbsorb = skDef.absorb[li];
                    sfxShield();
                    emitParticles(this.x, this.y, '#4488ff', 15, 50, 0.5, 3, -40, 'arcane', lvl);
                    addLog(`ãƒãƒŠã‚·ãƒ¼ãƒ«ãƒ‰ç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#4488ff');
                    break;
                }

                case 'self_heal_pct': {
                    const healAmt = Math.round(player.maxHP * skDef.pct[li]);
                    player.hp = Math.min(player.maxHP, player.hp + healAmt);
                    addFloatingText(player.x, player.y - 20, '+' + healAmt + ' HP', '#00ff00');
                    emitParticles(player.x, player.y, '#00ff00', 12, 50, 0.5, 3, -40, 'holy', lvl);
                    sfxHeal();
                    addLog(`HPå›å¾© (+${healAmt})`, '#00ff00');
                    break;
                }
                case 'ground_slam': {
                    sfxHit();
                    G.shakeT = 0.25; G.shakeAmt = 12; // Diabloé¢¨ï¼š2å€
                    const mult = skDef.baseMult[li];
                    const slowFactor = skDef.slow ? skDef.slow[li] : 0.5;
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            monsterTakeDmg(m, dmg * mult, false);
                            m.spd = MONSTER_DEFS[m.type].spd * slowFactor;
                            m.frozenT = 2;
                        }
                    }
                    emitParticles(this.x, this.y, '#aa8844', 20, skDef.range, 0.5, 4, 0, 'physical', lvl);
                    break;
                }
                case 'buff_counter': {
                    this.counterT = skDef.duration[li];
                    this.counterReflect = skDef.reflect[li];
                    playSound(400, 'triangle', 0.15, 0.08);
                    emitParticles(this.x, this.y, '#ffcc44', 10, 40, 0.4, 3, -30, 'arcane', lvl);
                    addLog(`è¦‹åˆ‡ã‚Šç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#ffcc44');
                    break;
                }
                case 'buff_speed': {
                    this.speedBuffT = skDef.duration[li];
                    this.speedBuffBonus = skDef.bonus[li];
                    playSound(600, 'sine', 0.12, 0.05);
                    emitParticles(this.x, this.y, '#88ffaa', 10, 50, 0.4, 2, -30, 'arcane', lvl);
                    addLog(`ç§»å‹•é€Ÿåº¦UPï¼(${skDef.duration[li]}ç§’)`, '#88ffaa');
                    break;
                }
                case 'buff_poison': {
                    this.poisonBuffT = skDef.duration[li];
                    this.poisonDps = skDef.dps[li];
                    playSound(300, 'sawtooth', 0.1, 0.06);
                    emitParticles(this.x, this.y, '#88ff44', 10, 40, 0.4, 2, -30, 'nature', lvl);
                    addLog(`æ¯’å¡—ã‚Šï¼æ”»æ’ƒã«æ¯’ä»˜ä¸(${skDef.duration[li]}ç§’)`, '#88ff44');
                    break;
                }
                case 'smoke_screen': {
                    const dur = skDef.duration[li];
                    this.dodgeT = dur;
                    this.dodgeChance = skDef.evade[li];
                    playSound(200, 'sine', 0.08, 0.06);
                    emitParticles(this.x, this.y, '#999999', 25, skDef.range, 0.6, 5, -20, 'arcane', lvl);
                    addLog(`ç…™å¹•ï¼å›é¿ç‡UP(${dur}ç§’)`, '#999');
                    break;
                }
                case 'holy_burst': {
                    sfxHit();
                    const mult = skDef.baseMult[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            monsterTakeDmg(m, dmg * mult, false);
                        }
                    }
                    emitParticles(this.x, this.y, '#ffdd88', 25, skDef.range, 0.5, 4, 0, 'holy', lvl);
                    break;
                }
                case 'consecrate': {
                    if (!G.consecrations) G.consecrations = [];
                    G.consecrations.push({
                        x: this.x, y: this.y,
                        dmg: dmg * skDef.baseMult[li],
                        range: skDef.range,
                        life: skDef.duration[li],
                        maxLife: skDef.duration[li],
                        tickCD: 0
                    });
                    playSound(350, 'sine', 0.1, 0.08);
                    emitParticles(this.x, this.y, '#ffcc44', 15, skDef.range * 0.5, 0.5, 3, 0, 'holy', lvl);
                    addLog('è–åŸŸã‚’å±•é–‹ï¼', '#ffcc44');
                    break;
                }
                case 'buff_atkspd': {
                    this.atkSpdBuffT = skDef.duration[li];
                    this.atkSpdBonus = skDef.bonus[li];
                    playSound(500, 'triangle', 0.1, 0.05);
                    emitParticles(this.x, this.y, '#ffaa88', 10, 40, 0.3, 2, -30, 'fire', lvl);
                    addLog(`æ”»æ’ƒé€Ÿåº¦UPï¼(${skDef.duration[li]}ç§’)`, '#ffaa88');
                    break;
                }
                case 'buff_frenzy': {
                    this.berserkT = skDef.duration[li];
                    this.speedBuffT = skDef.duration[li];
                    this.speedBuffBonus = skDef.spdBonus[li];
                    this.atkSpdBuffT = skDef.duration[li];
                    this.atkSpdBonus = skDef.atkBonus[li];
                    playSound(250, 'sawtooth', 0.2, 0.1);
                    emitParticles(this.x, this.y, '#ff6644', 20, 80, 0.6, 4, -30, 'fire', lvl);
                    addLog(`ãƒ•ãƒ¬ãƒ³ã‚¸ãƒ¼ï¼(${skDef.duration[li]}ç§’)`, '#ff6644');
                    break;
                }
                case 'execute': {
                    sfxHit();
                    const mult = skDef.baseMult[li];
                    const thresh = skDef.threshold[li];
                    let hit = false;
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < (skDef.range || 70)) {
                            const hpRatio = m.hp / m.maxHP;
                            const finalMult = hpRatio <= thresh ? mult * 1.5 : mult;
                            monsterTakeDmg(m, dmg * finalMult, hpRatio <= thresh);
                            hit = true;
                            break;
                        }
                    }
                    if (hit) {
                        this.attackAnimT = 0.3;
                        emitParticles(this.x, this.y, '#ff4444', 15, 80, 0.4, 4, 0, 'physical', lvl);
                        G.shakeT = 0.2; G.shakeAmt = 10; // Diabloé¢¨ï¼š2å€
                    }
                    break;
                }
                case 'buff_lifesteal': {
                    this.lifestealBuffT = skDef.duration[li];
                    this.lifestealBuffPct = skDef.pct[li];
                    playSound(350, 'sine', 0.12, 0.06);
                    emitParticles(this.x, this.y, '#ff4466', 10, 40, 0.4, 3, -30, 'arcane', lvl);
                    addLog(`è¡€ã®åˆƒï¼(${skDef.duration[li]}ç§’)`, '#ff4466');
                    break;
                }
                case 'buff_undying': {
                    this.undyingT = skDef.duration[li];
                    playSound(200, 'square', 0.15, 0.1);
                    emitParticles(this.x, this.y, '#ffd700', 20, 60, 0.8, 4, -40, 'holy', lvl);
                    addLog(`ä¸æ­»èº«ç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#ffd700');
                    break;
                }
                case 'buff_stealth': {
                    this.stealthT = skDef.duration[li];
                    playSound(800, 'sine', 0.06, 0.04);
                    emitParticles(this.x, this.y, '#aa88ff', 15, 50, 0.5, 3, -30, 'arcane', lvl);
                    addLog(`æ¶ˆå¤±ï¼æ¬¡ã®æ”»æ’ƒã¯ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç¢ºå®š`, '#aa88ff');
                    break;
                }
                case 'buff_crit': {
                    this.critBuffT = skDef.duration[li];
                    this.critBuffBonus = skDef.bonus[li];
                    playSound(700, 'triangle', 0.1, 0.05);
                    emitParticles(this.x, this.y, '#ffdd44', 10, 40, 0.4, 2, -30, 'arcane', lvl);
                    addLog(`é·¹ã®ç›®ï¼ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡+${skDef.bonus[li]}%(${skDef.duration[li]}ç§’)`, '#ffdd44');
                    break;
                }
                case 'buff_aura': {
                    this.auraT = skDef.duration[li];
                    this.auraRegen = skDef.regen[li];
                    this.auraReduction = skDef.reduction[li];
                    this.shieldT = skDef.duration[li];
                    this.shieldReduction = skDef.reduction[li];
                    sfxShield();
                    emitParticles(this.x, this.y, '#ffdd88', 15, 60, 0.6, 4, -30, 'holy', lvl);
                    addLog(`å®ˆè­·ã®ã‚ªãƒ¼ãƒ©ç™ºå‹•ï¼(${skDef.duration[li]}ç§’)`, '#ffdd88');
                    break;
                }
                case 'mana_drain': {
                    sfxHit();
                    const mult = skDef.baseMult[li];
                    const mpSteal = skDef.mpSteal[li];
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < 80) {
                            monsterTakeDmg(m, dmg * mult, false);
                            this.mp = Math.min(this.maxMP, this.mp + mpSteal);
                            addFloatingText(this.x, this.y - 30, '+' + mpSteal + ' MP', '#8844ff');
                            emitParticles(m.x, m.y, '#8844ff', 6, 40, 0.3, 2, -20, 'arcane', lvl);
                            break;
                        }
                    }
                    break;
                }
                case 'debuff_defense': {
                    const dur = skDef.duration[li];
                    const red = skDef.reduction[li];
                    playSound(250, 'sawtooth', 0.1, 0.06);
                    for (const m of monsters) {
                        if (m.alive && dist(this.x, this.y, m.x, m.y) < skDef.range) {
                            m.cursedT = dur;
                            m.curseDmgMult = 1 + red;
                        }
                    }
                    emitParticles(this.x, this.y, '#8844aa', 15, skDef.range * 0.5, 0.4, 3, 0, 'arcane', lvl);
                    addLog(`å‘ªç¸›ï¼æ•µã®è¢«ãƒ€ãƒ¡å¢—åŠ (${dur}ç§’)`, '#8844aa');
                    break;
                }
                case 'dark_orb': {
                    playSound(300, 'sine', 0.15, 0.08);
                    const mult = skDef.baseMult[li];
                    const spd = skDef.speed || 250;
                    const p = new Projectile(this.x, this.y, wx, wy, dmg * mult, '#8800ff', spd, 10, 'arcane');
                    p.pierce = true;
                    projectiles.push(p);
                    emitParticles(this.x, this.y, '#8800ff', 8, 40, 0.3, 3, 0, 'arcane', lvl);
                    break;
                }

                case 'battle_orders': {
                    const boBonus = skDef.bonus[li];
                    const boDur = skDef.duration[li];
                    const hpBoost = Math.round(player.maxHP * boBonus);
                    const mpBoost = Math.round(player.maxMP * boBonus);
                    player.maxHP += hpBoost;
                    player.maxMP += mpBoost;
                    player.hp = Math.min(player.maxHP, player.hp + hpBoost);
                    player.mp = Math.min(player.maxMP, player.mp + mpBoost);
                    player.battleOrdersT = boDur;
                    player.battleOrdersHP = hpBoost;
                    player.battleOrdersMP = mpBoost;
                    playSound(250, 'triangle', 0.2, 0.1);
                    emitParticles(this.x, this.y, '#ffd700', 20, 80, 0.6, 4, -30, 'arcane', lvl);
                    addLog(`ãƒãƒˆãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼ï¼HP+${hpBoost} MP+${mpBoost} (${boDur}ç§’)`, '#ffd700');
                    break;
                }
                case 'summon_minion': {
                    const sDur = skDef.duration[li];
                    const sHP = skDef.minionHP[li];
                    const sDmg = skDef.minionDmg[li];
                    if (!G.minions) G.minions = [];
                    G.minions = G.minions.filter(m => m.life > 0);
                    if (G.minions.length < 2) {
                        G.minions.push({
                            x: this.x + randf(-30, 30), y: this.y + randf(-30, 30),
                            hp: sHP, maxHP: sHP, dmg: sDmg, life: sDur,
                            attackCD: 0, r: 12
                        });
                    }
                    playSound(500, 'sine', 0.15, 0.08);
                    emitParticles(this.x, this.y, '#88ddff', 15, 60, 0.5, 3, -30, 'arcane', lvl);
                    addLog(`å¬å–šï¼(HP:${sHP} ATK:${sDmg} ${sDur}ç§’)`, '#88ddff');
                    break;
                }
                case 'frozen_orb': {
                    playSound(600, 'sine', 0.12, 0.06);
                    const orbMult = skDef.baseMult[li];
                    const orbSpd = skDef.speed || 200;
                    const shards = skDef.shardCount ? skDef.shardCount[li] : 8;
                    const orbP = new Projectile(this.x, this.y, wx, wy, dmg * orbMult * 0.5, '#88ccff', orbSpd, 12, 'ice');
                    orbP.pierce = true;
                    orbP.frozen_orb = true;
                    orbP.shardDmg = dmg * orbMult * 0.3;
                    orbP.shardCount = shards;
                    orbP.shardTimer = 0;
                    projectiles.push(orbP);
                    emitParticles(this.x, this.y, '#88ddff', 10, 50, 0.3, 3, 0, 'ice', lvl);
                    break;
                }
            }

            // Screen flash and enhanced effects for Level 5 skills
            if (lvl === 5) {
                // Screen flash
                G.flashT = 0.15;
                G.flashColor = skDef.color || '#ffffff';
                G.flashAlpha = 0.3;

                // Enhanced shake
                G.shakeT = Math.max(G.shakeT || 0, 0.3);
                G.shakeAmt = Math.max(G.shakeAmt || 0, 16); // Diabloé¢¨ï¼š2å€

                // Trail particles
                if (skDef.effect) {
                    // Determine attribute from effect type
                    let attr = 'arcane'; // default
                    if (['melee_burst', 'whirlwind', 'stun_aoe', 'charge', 'arrow_rain', 'ground_slam', 'execute'].includes(skDef.effect)) attr = 'physical';
                    else if (['projectile_fire', 'meteor', 'buff_berserk', 'buff_frenzy', 'buff_atkspd'].includes(skDef.effect)) attr = 'fire';
                    else if (['frost_nova', 'frozen_orb'].includes(skDef.effect)) attr = 'ice';
                    else if (['chain_lightning'].includes(skDef.effect)) attr = 'lightning';
                    else if (['holy_burst', 'consecrate', 'self_heal_pct', 'buff_aura', 'buff_undying'].includes(skDef.effect)) attr = 'holy';
                    else if (['place_trap', 'buff_poison'].includes(skDef.effect)) attr = 'nature';

                    emitTrailParticles(this.x, this.y, skDef.color || '#ffffff', attr, lvl);
                }
            }
        },

        update(dt) {
            // Regen
            this.mp = Math.min(this.maxMP, this.mp + (1 + this.int * 0.05) * dt);
            // Battle Orders timer
            if (this.battleOrdersT > 0) {
                this.battleOrdersT -= dt;
                if (this.battleOrdersT <= 0) {
                    this.maxHP -= this.battleOrdersHP;
                    this.maxMP -= this.battleOrdersMP;
                    this.hp = Math.min(this.maxHP, this.hp);
                    this.mp = Math.min(this.maxMP, this.mp);
                    this.battleOrdersHP = 0;
                    this.battleOrdersMP = 0;
                    addLog('ãƒãƒˆãƒ«ã‚ªãƒ¼ãƒ€ãƒ¼ã®åŠ¹æœãŒåˆ‡ã‚ŒãŸ', '#888');
                }
            }
            this.hp = Math.min(this.maxHP, this.hp + (0.5 + this.vit * 0.02) * dt);

            // Skill cooldowns
            for (const sk of Object.values(this.skills)) {
                if (sk.cooldown > 0) sk.cooldown = Math.max(0, sk.cooldown - dt);
            }

            // Whirlwind anim
            if (this.whirlwindT > 0) this.whirlwindT -= dt;

            // Frost Nova timer
            if (this.freezeT > 0) this.freezeT -= dt;

            // Magic Shield timer
            if (this.shieldT > 0) this.shieldT -= dt;

            // Berserk timer
            if (this.berserkT > 0) this.berserkT -= dt;
            // Dodge timer
            if (this.dodgeT > 0) this.dodgeT -= dt;
            // Mana Shield timer
            if (this.manaShieldT > 0) this.manaShieldT -= dt;

            // Counter timer
            if (this.counterT > 0) this.counterT -= dt;
            // Speed buff timer
            if (this.speedBuffT > 0) {
                this.speedBuffT -= dt;
                if (this.speedBuffT <= 0) this.speedBuffBonus = 0;
            }
            // Poison buff timer
            if (this.poisonBuffT > 0) this.poisonBuffT -= dt;
            // Attack speed buff timer
            if (this.atkSpdBuffT > 0) this.atkSpdBuffT -= dt;
            // Lifesteal buff timer
            if (this.lifestealBuffT > 0) this.lifestealBuffT -= dt;
            // Undying timer
            if (this.undyingT > 0) this.undyingT -= dt;
            // Stealth timer
            if (this.stealthT > 0) this.stealthT -= dt;
            // Crit buff timer
            if (this.critBuffT > 0) this.critBuffT -= dt;
            // Aura timer
            if (this.auraT > 0) {
                this.auraT -= dt;
                this.hp = Math.min(this.maxHP, this.hp + (this.auraRegen || 0) * dt);
            }
            // Consecrations
            if (G.consecrations) {
                for (let ci = G.consecrations.length - 1; ci >= 0; ci--) {
                    const con = G.consecrations[ci];
                    con.life -= dt;
                    con.tickCD -= dt;
                    if (con.tickCD <= 0) {
                        con.tickCD = 0.5;
                        for (const m of monsters) {
                            if (m.alive && dist(con.x, con.y, m.x, m.y) < con.range) {
                                monsterTakeDmg(m, con.dmg * 0.2, false);
                            }
                        }
                    }
                    if (con.life <= 0) G.consecrations.splice(ci, 1);
                }
            }
            // Meteor timer - explode when ready
            if (this.meteorT > 0) {
                this.meteorT -= dt;
                // Warning particles
                if (G.meteorX) {
                    emitParticles(G.meteorX + randf(-50,50), G.meteorY + randf(-50,50), '#ff4400', 1, 10, 0.3, 2, -20);
                }
                if (this.meteorT <= 0 && G.meteorX) {
                    // BOOM
                    const mx = G.meteorX, my = G.meteorY;
                    sfxMeteorImpact();
                    G.shakeT = 0.5; G.shakeAmt = 16; // Diabloé¢¨ï¼š2å€
                    emitParticles(mx, my, '#ff4400', 40, 150, 1.2, 5, 50); // å¯¿å‘½1.5å€
                    emitParticles(mx, my, '#ffaa00', 25, 100, 0.9, 4, 30); // å¯¿å‘½1.5å€
                    emitParticles(mx, my, '#ffffff', 10, 60, 0.45, 2, 0); // å¯¿å‘½1.5å€
                    for (const m of monsters) {
                        if (m.alive && dist(mx, my, m.x, m.y) < 100) {
                            const isCrit = Math.random() * 100 < this.getCritChance();
                            const d = isCrit ? G.meteorDmg * 2 : G.meteorDmg;
                            monsterTakeDmg(m, d, isCrit);
                        }
                    }
                    addLog('ãƒ¡ãƒ†ã‚ªç€å¼¾ï¼', '#ff4400');
                    G.meteorX = null; G.meteorY = null;
                }
            }

            // Attack cooldown
            if (this.attackCooldown > 0) this.attackCooldown -= dt;
            if (this.attackAnimT > 0) this.attackAnimT -= dt;

            // Attack target
            if (this.attacking && this.attackTarget && this.attackTarget.alive) {
                const d = dist(this.x, this.y, this.attackTarget.x, this.attackTarget.y);
                if (d < 50) {
                    if (this.attackCooldown <= 0) {
                        const dmg = this.getAttackDmg();
                        const isCrit = Math.random() * 100 < this.getCritChance();
                        const finalDmg = isCrit ? dmg * 2 : dmg;
                        monsterTakeDmg(this.attackTarget, finalDmg, isCrit);
                        this.attackCooldown = 0.5;
                        this.attackAnimT = 0.2;
                        sfxHit();

                        // Lifesteal
                        const ls = this.getLifesteal();
                        if (ls > 0) {
                            const heal = Math.round(finalDmg * ls / 100);
                            this.hp = Math.min(this.maxHP, this.hp + heal);
                        }
                    }
                    this.moving = false;
                } else {
                    this.targetX = this.attackTarget.x;
                    this.targetY = this.attackTarget.y;
                    this.moving = true;
                }
            }

            // Arrow key movement with inertia
            let kbMoveX = 0, kbMoveY = 0;
            if (keysDown['arrowup']) kbMoveY = -1;
            if (keysDown['arrowdown']) kbMoveY = 1;
            if (keysDown['arrowleft']) kbMoveX = -1;
            if (keysDown['arrowright']) kbMoveX = 1;

            // ç›®æ¨™é€Ÿåº¦ã‚’è¨ˆç®—
            let targetVx = 0, targetVy = 0;
            if (kbMoveX !== 0 || kbMoveY !== 0) {
                // Normalize diagonal
                const kbLen = Math.hypot(kbMoveX, kbMoveY) || 1;
                targetVx = (kbMoveX / kbLen) * this.speed;
                targetVy = (kbMoveY / kbLen) * this.speed;
            }

            // æ…£æ€§ã‚·ã‚¹ãƒ†ãƒ ï¼šç¾åœ¨ã®é€Ÿåº¦ã‚’ç›®æ¨™é€Ÿåº¦ã«å‘ã‘ã¦åŠ é€Ÿ/æ¸›é€Ÿ
            const inputMag = Math.hypot(targetVx, targetVy);
            if (inputMag > 0) {
                // åŠ é€Ÿ
                const t = Math.min(this.acceleration * dt / this.speed, 1);
                this.vx = lerp(this.vx, targetVx, t);
                this.vy = lerp(this.vy, targetVy, t);
            } else {
                // æ¸›é€Ÿï¼ˆæ‘©æ“¦ï¼‰
                const currentSpeed = Math.hypot(this.vx, this.vy);
                if (currentSpeed > 0.1) {
                    const decelAmount = this.deceleration * dt;
                    const friction = Math.max(0, currentSpeed - decelAmount) / currentSpeed;
                    this.vx *= friction;
                    this.vy *= friction;
                } else {
                    this.vx = 0;
                    this.vy = 0;
                }
            }

            // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã«åŸºã¥ã„ã¦ä½ç½®ã‚’æ›´æ–°
            const actualSpeed = Math.hypot(this.vx, this.vy);
            if (actualSpeed > 0.1) {
                const nx = this.x + this.vx * dt;
                const ny = this.y + this.vy * dt;
                const cr = 10;
                const canBoth = canWalk(nx, ny, cr);
                const canX = canWalk(this.x + this.vx * dt, this.y, cr);
                const canY = canWalk(this.x, this.y + this.vy * dt, cr);
                if (canBoth) {
                    this.x = nx;
                    this.y = ny;
                } else if (canX) {
                    this.x += this.vx * dt;
                    this.vy *= 0.5; // å£ã«å½“ãŸã£ãŸã‚‰åå¯¾æ–¹å‘ã®é€Ÿåº¦ã‚’æ¸›è¡°
                } else if (canY) {
                    this.y += this.vy * dt;
                    this.vx *= 0.5; // å£ã«å½“ãŸã£ãŸã‚‰åå¯¾æ–¹å‘ã®é€Ÿåº¦ã‚’æ¸›è¡°
                } else {
                    // å®Œå…¨ã«è¡Œãè©°ã¾ã‚Š
                    this.vx *= 0.3;
                    this.vy *= 0.3;
                }
                this.moving = false; // Cancel click-move
                this.attacking = false;
                sfxFootstep();
            }

            // Movement with proper circle collision
            if (this.moving) {
                sfxFootstep();
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                const d = Math.hypot(dx, dy);
                if (d > 3) {
                    const mx = dx / d, my = dy / d;
                    const step = this.speed * dt;
                    const nx = this.x + mx * step;
                    const ny = this.y + my * step;

                    // Check circle collision: test 4 edge points of the circle
                    const cr = 10; // collision radius
                    const canMoveX = canWalk(this.x + mx * step, this.y, cr);
                    const canMoveY = canWalk(this.x, this.y + my * step, cr);
                    const canMoveBoth = canWalk(nx, ny, cr);

                    if (canMoveBoth) {
                        this.x = nx; this.y = ny;
                    } else if (canMoveX) {
                        this.x += mx * step;
                    } else if (canMoveY) {
                        this.y += my * step;
                    }
                    // else: stuck, don't move
                } else {
                    this.moving = false;
                }
            }
        },

        draw(cx, cy) {
            const sx = this.x - cx, sy = this.y - cy;

            // Magic Shield aura
            if (this.shieldT > 0) {
                const pulse = 0.6 + Math.sin(G.time * 6) * 0.15;
                ctx.strokeStyle = `rgba(120,120,255,${pulse})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, 22, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = `rgba(80,80,255,${pulse * 0.15})`;
                ctx.beginPath();
                ctx.arc(sx, sy, 21, 0, Math.PI * 2);
                ctx.fill();
            }

            // Frost Nova ring effect
            if (this.freezeT > 0) {
                const r = 130 * (1 - this.freezeT / 0.5);
                ctx.strokeStyle = `rgba(100,220,255,${this.freezeT})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(sx, sy, r, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Whirlwind effect
            if (this.whirlwindT > 0) {
                ctx.save();
                ctx.translate(sx, sy);
                ctx.rotate(G.time * 15);
                for (let i = 0; i < 4; i++) {
                    const a = this.whirlwindT / 0.6;
                    ctx.strokeStyle = `rgba(100,150,255,${a * 0.5})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 35 + i * 12, i * 1.5, i * 1.5 + 2.5);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(sx, sy + 16, 14, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Walking animation phase
            const walkPhase = this.moving ? Math.sin(G.time * 10) * 2 : 0;

            // Render character based on class
            if (this.classKey === 'warrior' || this.classKey === 'paladin' || this.classKey === 'berserker') this._drawGenericSprite(sx, sy, walkPhase, CLASS_DEFS[this.classKey].sprite);
            else if (this.classKey === 'rogue' || this.classKey === 'assassin' || this.classKey === 'ranger') this._drawGenericSprite(sx, sy, walkPhase, CLASS_DEFS[this.classKey].sprite);
            else if (this.classKey === 'sorcerer' || this.classKey === 'pyromancer' || this.classKey === 'cryomancer') this._drawGenericSprite(sx, sy, walkPhase, CLASS_DEFS[this.classKey].sprite);

            // HP/MP bars over head
            const hpFrac = this.hp / this.maxHP;
            const mpFrac = this.mp / this.maxMP;
            const barW = 30;
            ctx.fillStyle = '#1a0000';
            ctx.fillRect(sx - barW/2, sy + 20, barW, 3);
            ctx.fillStyle = hpFrac > 0.3 ? '#cc2222' : '#ff4444';
            ctx.fillRect(sx - barW/2, sy + 20, barW * hpFrac, 3);
            ctx.fillStyle = '#00001a';
            ctx.fillRect(sx - barW/2, sy + 24, barW, 2);
            ctx.fillStyle = '#4444cc';
            ctx.fillRect(sx - barW/2, sy + 24, barW * mpFrac, 2);
            // Level badge
            ctx.font = '9px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#daa520';
            ctx.fillText('Lv' + this.level, sx, sy - TILE/2 - 4);

            // Berserk aura (only sorcerer shows mana shield glow)
            if (this.manaShieldT > 0) {
                const manaGlow = 0.5 + Math.sin(G.time * 8) * 0.2;
                ctx.fillStyle = `rgba(100, 100, 255, ${manaGlow * 0.2})`;
                ctx.beginPath();
                ctx.arc(sx, sy, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        },
        _drawGenericSprite(sx, sy, walkPhase, spriteKey) {
            const bounce = this.moving ? Math.sin(walkPhase * 10) * 2 : 0;
            const flipX = this.targetX < this.x - 2;
            const atkTilt = this.attacking ? Math.sin(this.attackTimer * Math.PI * 6) * 0.15 : 0;
            ctx.save();
            ctx.translate(sx, sy + bounce);
            if (atkTilt) ctx.rotate(atkTilt);
            if (!drawSpr(spriteKey, -TILE/2, -TILE/2, TILE, TILE, flipX)) {
                // Fallback: try class-specific legacy method
                ctx.fillStyle = '#888'; ctx.fillRect(-TILE/4, -TILE/4, TILE/2, TILE/2);
            }
            ctx.restore();
            // Aura effects for promoted classes
            const classDef = CLASS_DEFS[this.classKey];
            if (classDef && classDef.tier > 0) {
                const colors = {paladin:'#ffd700',berserker:'#ff4400',assassin:'#8800ff',ranger:'#44ff44',pyromancer:'#ff6600',cryomancer:'#44ccff'};
                const c = colors[this.classKey] || '#ffffff';
                ctx.globalAlpha = 0.08 + Math.sin(G.time * 3) * 0.04;
                ctx.fillStyle = c;
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.5, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
            if (this.attacking) {
                ctx.globalAlpha = 0.25 * Math.abs(Math.sin(this.attackTimer * Math.PI * 4));
                ctx.fillStyle = '#ffaa44';
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        },
        _drawWarrior(sx, sy, walkPhase) {
            const bounce = this.moving ? Math.sin(walkPhase * 10) * 2 : 0;
            const flipX = this.targetX < this.x - 2;
            const atkTilt = this.attacking ? Math.sin(this.attackTimer * Math.PI * 6) * 0.15 : 0;
            ctx.save();
            ctx.translate(sx, sy + bounce);
            if (atkTilt) ctx.rotate(atkTilt);
            if (!drawSpr('knight', -TILE/2, -TILE/2, TILE, TILE, flipX)) {
                ctx.fillStyle = '#888'; ctx.fillRect(-TILE/4, -TILE/4, TILE/2, TILE/2);
            }
            ctx.restore();
            if (this.attacking) {
                ctx.globalAlpha = 0.25 * Math.abs(Math.sin(this.attackTimer * Math.PI * 4));
                ctx.fillStyle = '#ffaa44';
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        },
        _drawRogue(sx, sy, walkPhase) {
            const bounce = this.moving ? Math.sin(walkPhase * 10) * 2 : 0;
            const flipX = this.targetX < this.x - 2;
            const atkTilt = this.attacking ? Math.sin(this.attackTimer * Math.PI * 6) * 0.1 : 0;
            ctx.save();
            ctx.translate(sx, sy + bounce);
            if (atkTilt) ctx.rotate(atkTilt);
            if (!drawSpr('rogueChar', -TILE/2, -TILE/2, TILE, TILE, flipX)) {
                ctx.fillStyle = '#6a6'; ctx.fillRect(-TILE/4, -TILE/4, TILE/2, TILE/2);
            }
            ctx.restore();
            if (this.attacking) {
                ctx.globalAlpha = 0.2 * Math.abs(Math.sin(this.attackTimer * Math.PI * 4));
                ctx.fillStyle = '#88ff88';
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.5, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        },
        _drawSorcerer(sx, sy, walkPhase) {
            const bounce = this.moving ? Math.sin(walkPhase * 10) * 1.5 : 0;
            const flipX = this.targetX < this.x - 2;
            const magicGlow = 0.08 + Math.sin(G.time * 3) * 0.04;
            ctx.save();
            ctx.translate(sx, sy + bounce);
            if (!drawSpr('wizardM', -TILE/2, -TILE/2, TILE, TILE, flipX)) {
                ctx.fillStyle = '#66a'; ctx.fillRect(-TILE/4, -TILE/4, TILE/2, TILE/2);
            }
            ctx.restore();
            ctx.globalAlpha = magicGlow;
            ctx.fillStyle = '#6644ff';
            ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.5, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1;
            if (this.attacking) {
                ctx.globalAlpha = 0.3 * Math.abs(Math.sin(this.attackTimer * Math.PI * 4));
                ctx.fillStyle = '#4488ff';
                ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.6, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

    };

    // ========== MONSTERS ==========
    const MONSTER_DEFS = {
        skeleton: { name: 'ã‚¹ã‚±ãƒ«ãƒˆãƒ³', r: 12, hp: 40, dmg: 8, spd: 60, xp: 25, color: '#9a8a6a', loot: 0.4, icon: 'ğŸ’€' },
        zombie:   { name: 'ã‚¾ãƒ³ãƒ“', r: 14, hp: 70, dmg: 12, spd: 40, xp: 35, color: '#3a4a25', loot: 0.45, icon: 'ğŸ§Ÿ' },
        imp:      { name: 'ã‚¤ãƒ³ãƒ—', r: 10, hp: 30, dmg: 15, spd: 100, xp: 45, color: '#8a2a2a', loot: 0.5, icon: 'ğŸ‘¹' },
        ghost:    { name: 'ã‚´ãƒ¼ã‚¹ãƒˆ', r: 11, hp: 25, dmg: 10, spd: 110, xp: 55, color: '#555588', loot: 0.55, icon: 'ğŸ‘»' },
        demonlord:{ name: 'ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ­ãƒ¼ãƒ‰', r: 22, hp: 300, dmg: 30, spd: 70, xp: 300, color: '#8a1515', loot: 1.0, icon: 'ğŸ‘¿' }
    };

    const monsters = [];
    class Monster {
        constructor(x, y, type, floor) {
            this.x = x; this.y = y;
            this.type = type;
            const d = MONSTER_DEFS[type];
            this.def = d;
            const s = 1 + (floor - 1) * 0.3;
            this.maxHP = Math.round(d.hp * s);
            this.hp = this.maxHP;
            this.dmg = Math.round(d.dmg * s);
            this.spd = d.spd;
            this.r = d.r;
            this.alive = true;
            this.deathT = 0;
            this.atkCD = 0;
            this.phase = type === 'ghost';
            this.phaseAlpha = 1;
            this.hitFlash = 0;
            this.aggroRange = type === 'demonlord' ? 400 : 250;
            this.frozenT = 0;
            this.origSpd = d.spd;
            this.aggroed = false;
        }

        update(dt) {
            if (!this.alive) { this.deathT -= dt; return; }
            this.atkCD = Math.max(0, this.atkCD - dt);
            this.hitFlash = Math.max(0, this.hitFlash - dt);

            // Frozen state
            if (this.frozenT > 0) {
                this.frozenT -= dt;
                if (this.frozenT <= 0) {
                    this.spd = this.origSpd; // restore speed
                }
            }

            if (this.phase) {
                this.phaseAlpha = 0.3 + Math.sin(G.time * 3) * 0.3;
            }

            const d = dist(this.x, this.y, player.x, player.y);
            if (d < this.aggroRange && this.frozenT <= 0) {
                // Growl on first aggro
                if (!this.aggroed) { this.aggroed = true; sfxMonsterGrowl(); }
                const dx = player.x - this.x, dy = player.y - this.y;
                const len = Math.hypot(dx, dy) || 1;
                const step = this.spd * dt;
                const mx = dx / len, my = dy / len;
                const nx = this.x + mx * step;
                const ny = this.y + my * step;
                const cr = Math.max(this.r - 4, 4);

                if (this.phase) {
                    this.x = nx; this.y = ny;
                } else {
                    const canBoth = canWalk(nx, ny, cr);
                    const canX = canWalk(this.x + mx * step, this.y, cr);
                    const canY = canWalk(this.x, this.y + my * step, cr);
                    if (canBoth) { this.x = nx; this.y = ny; }
                    else if (canX) { this.x += mx * step; }
                    else if (canY) { this.y += my * step; }
                }

                if (d < this.r + player.radius + 10 && this.atkCD <= 0) {
                    player.takeDamage(this.dmg);
                    this.atkCD = 1.0;
                }
            }
        }

        _darken(hex, factor) {
            const r = parseInt(hex.slice(1,3),16);
            const g = parseInt(hex.slice(3,5),16);
            const b = parseInt(hex.slice(5,7),16);
            return `rgb(${Math.round(r*factor)},${Math.round(g*factor)},${Math.round(b*factor)})`;
        }

        draw(cx, cy) {
            const sx = this.x - cx, sy = this.y - cy;
            if (sx < -50 || sx > W + 50 || sy < -50 || sy > H + 50) return;

            if (!this.alive) {
                ctx.globalAlpha = clamp(this.deathT / 0.5, 0, 1);
            }
            if (this.phase) ctx.globalAlpha = this.phaseAlpha;

            ctx.save();

            // Shadow ellipse under all monsters
            ctx.fillStyle = 'rgba(0,0,0,0.25)';
            ctx.beginPath();
            ctx.ellipse(sx, sy + this.r + 3, this.r * 0.7, 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Apply hit flash to drawing
            let alphaFlash = 1;
            if (this.hitFlash > 0) {
                alphaFlash = 0.5 + 0.5 * (this.hitFlash / 0.1);
            }

            // Type-specific detailed rendering
            if (this.type === 'skeleton') this._drawSkeleton(sx, sy, alphaFlash);
            else if (this.type === 'zombie') this._drawZombie(sx, sy, alphaFlash);
            else if (this.type === 'imp') this._drawImp(sx, sy, alphaFlash);
            else if (this.type === 'ghost') this._drawGhost(sx, sy, alphaFlash);
            else if (this.type === 'demonlord') this._drawDemonLord(sx, sy, alphaFlash);

            ctx.restore();
            ctx.globalAlpha = 1;

            // Frozen indicator overlay
            if (this.frozenT > 0) {
                ctx.strokeStyle = '#88ddff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(sx, sy, this.r + 4, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = 'rgba(100,200,255,0.15)';
                ctx.beginPath();
                ctx.arc(sx, sy, this.r + 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // HP bar
            if (this.alive && this.hp < this.maxHP) {
                const bw = this.r * 2.5;
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(sx - bw/2, sy - this.r - 10, bw, 4);
                ctx.fillStyle = this.hp / this.maxHP > 0.3 ? '#00aa00' : '#dd3300';
                ctx.fillRect(sx - bw/2, sy - this.r - 10, bw * (this.hp / this.maxHP), 4);
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 0.5;
                ctx.strokeRect(sx - bw/2, sy - this.r - 10, bw, 4);
            }

            // Name plate
            if (this.alive) {
                ctx.fillStyle = '#aaaaaa';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.def.name, sx, sy + this.r + 12);
            }

            // Boss aura
            if (this.type === 'demonlord' && this.alive) {
                ctx.strokeStyle = `rgba(200,50,50,${0.25 + Math.sin(G.time * 3.5) * 0.1})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(sx, sy, this.r + 10, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Boss name override
            if (this.type === 'demonlord' && this.alive) {
                ctx.fillStyle = '#cc5555';
                ctx.font = 'bold 10px monospace';
                ctx.textAlign = 'center';
                ctx.fillText(this.def.name, sx, sy - this.r - 14);
            }
        }

    _drawSkeleton(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        drawSpr('skeleton', sx - TILE/2, sy - TILE/2, TILE, TILE, flipX);
        if (alphaFlash > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = alphaFlash * 0.5;
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE, TILE);
            ctx.restore();
        }
    }

    _drawZombie(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        drawSpr('zombie', sx - TILE/2, sy - TILE/2, TILE, TILE, flipX);
        if (alphaFlash > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = alphaFlash * 0.5;
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE, TILE);
            ctx.restore();
        }
    }

    _drawImp(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        drawSpr('imp', sx - TILE/2, sy - TILE/2, TILE, TILE, flipX);
        if (alphaFlash > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = alphaFlash * 0.5;
            ctx.fillStyle = '#ff4444';
            ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE, TILE);
            ctx.restore();
        }
    }

    _drawGhost(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        ctx.globalAlpha = 0.55 + Math.sin(G.time * 3) * 0.15;
        drawSpr('banshee', sx - TILE/2, sy - TILE/2, TILE, TILE, flipX);
        ctx.globalAlpha = 1;
        if (alphaFlash > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = alphaFlash * 0.4;
            ctx.fillStyle = '#88bbff';
            ctx.fillRect(sx - TILE/2, sy - TILE/2, TILE, TILE);
            ctx.restore();
        }
    }

    _drawDemonLord(sx, sy, alphaFlash) {
        const flipX = player.x < this.x;
        const bossScale = 1.35;
        const bw = TILE * bossScale, bh = TILE * bossScale;
        drawSpr('deathKnight', sx - bw/2, sy - bh/2, bw, bh, flipX);
        ctx.globalAlpha = 0.12 + Math.sin(G.time * 4) * 0.05;
        ctx.fillStyle = '#ff4400';
        ctx.beginPath(); ctx.arc(sx, sy, TILE * 0.75, 0, Math.PI * 2); ctx.fill();
        ctx.globalAlpha = 1;
        if (alphaFlash > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            ctx.globalAlpha = alphaFlash * 0.6;
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(sx - bw/2, sy - bh/2, bw, bh);
            ctx.restore();
        }
    }
    }

    function monsterTakeDmg(m, dmg, isCrit) {
        m.hp -= dmg;
        m.hitFlash = 0.1;
        addFloatingText(m.x, m.y - m.r - 10, Math.round(dmg), isCrit ? '#ffff00' : '#ff6666', isCrit);
        emitParticles(m.x, m.y, '#cc0000', isCrit ? 10 : 5, 70, 0.4, 3);
        if (m.hp <= 0) {
            m.alive = false;
            m.deathT = 0.5;
            sfxMonsterDeath();
            addBloodPool(m.x, m.y, m.r * 2 + 5);
            emitParticles(m.x, m.y, '#660000', 8, 50, 0.6, 2, 80);
            player.addXP(m.def.xp * (1 + (G.floor - 1) * 0.1));
            // Drop loot
            if (Math.random() < m.def.loot) {
                const count = m.type === 'demonlord' ? rand(3, 5) : 1;
                for (let i = 0; i < count; i++) dropItem(m.x, m.y, generateItem(G.floor));
            }
            if (Math.random() < 0.3) dropItem(m.x, m.y, generatePotion());
            addLog(`${m.def.name} ã‚’å€’ã—ãŸ! (+${m.def.xp} XP)`, '#ffaa00');
        }
    }

    // ========== PROJECTILES ==========
    const projectiles = [];
    class Projectile {
        constructor(x, y, tx, ty, dmg, color, spd, r, attribute) {
            this.x = x; this.y = y;
            this.dmg = dmg; this.color = color; this.r = r;
            this.attribute = attribute; // Store attribute for aura rendering
            const d = Math.hypot(tx - x, ty - y) || 1;
            this.vx = (tx - x) / d * spd;
            this.vy = (ty - y) / d * spd;
            this.life = 3;
            this.trail = [];
        }
        update(dt) {
            this.trail.push({ x: this.x, y: this.y });
            if (this.trail.length > 8) this.trail.shift();
            this.x += this.vx * dt;
            this.y += this.vy * dt;
            this.life -= dt;
            emitParticles(this.x, this.y, this.color, 1, 20, 0.2, 2, 0);
        }
        draw(cx, cy) {
            // Trail
            for (let i = 0; i < this.trail.length; i++) {
                const a = (i / this.trail.length) * 0.5;
                ctx.globalAlpha = a;
                ctx.fillStyle = this.color;
                const s = this.r * (i / this.trail.length);
                ctx.beginPath();
                ctx.arc(this.trail[i].x - cx, this.trail[i].y - cy, s, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Glow
            const grd = ctx.createRadialGradient(this.x - cx, this.y - cy, 0, this.x - cx, this.y - cy, this.r * 3);
            grd.addColorStop(0, this.color + 'aa');
            grd.addColorStop(1, this.color + '00');
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(this.x - cx, this.y - cy, this.r * 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x - cx, this.y - cy, this.r * 0.6, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x - cx, this.y - cy, this.r, 0, Math.PI * 2);
            ctx.fill();

            // Add glowing aura ring for attributed projectiles
            if (this.attribute && ATTRIBUTE_BEHAVIORS[this.attribute]) {
                const auraColor = ATTRIBUTE_BEHAVIORS[this.attribute].glowColor;
                const auraSize = this.r * (1.5 + Math.sin(G.time * 8) * 0.3);
                ctx.globalAlpha = 0.25;
                ctx.strokeStyle = auraColor;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x - cx, this.y - cy, auraSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }
    }

    // ========== DUNGEON INIT ==========
    let dungeon;
    let tileTexturesReady = false;
    function initFloor(opts) {
        // opts: { useSeed: bool, skipEntities: bool }
        opts = opts || {};
        generateTileTextures(); tileTexturesReady = true;

        // Use seeded RNG for dungeon generation so save/load produces same layout
        if (opts.useSeed && G.dungeonSeed) {
            seedRng(G.dungeonSeed);
        } else {
            // Generate new seed for this floor
            G.dungeonSeed = (Math.random() * 0x7FFFFFFF) | 0;
            seedRng(G.dungeonSeed);
        }

        dungeon = new Dungeon(G.floor);

        // Clear visual-only arrays always
        projectiles.length = 0;
        particles.length = 0;
        bloodPools.length = 0;
        ambientParticles.length = 0;

        if (!opts.skipEntities) {
            // Normal flow: set player at start room, spawn fresh monsters/items
            const r0 = dungeon.rooms[0];
            player.x = r0.cx * TILE + TILE/2;
            player.y = r0.cy * TILE + TILE/2;
            player.targetX = player.x;
            player.targetY = player.y;
            player.moving = false;
            player.attacking = false;
            monsters.length = 0;
            groundItems.length = 0;

            // Spawn monsters (also seeded for consistency)
            const count = 15 + G.floor * 8; // ãƒ¯ãƒ©ãƒ¯ãƒ©æ„ŸUPï¼
            const types = G.floor <= 2 ? ['skeleton', 'zombie'] :
                          G.floor <= 4 ? ['skeleton', 'zombie', 'imp'] :
                          G.floor <= 6 ? ['zombie', 'imp', 'ghost'] :
                          ['imp', 'ghost'];

            for (let i = 0; i < count; i++) {
                const room = dungeon.rooms[rand(1, dungeon.rooms.length - 1)];
                const mx = room.x * TILE + rand(TILE, (room.w - 1) * TILE);
                const my = room.y * TILE + rand(TILE, (room.h - 1) * TILE);
                monsters.push(new Monster(mx, my, types[rand(0, types.length - 1)], G.floor));
            }

            // Boss on every 5th floor
            if (G.floor % 5 === 0) {
                const bossRoom = dungeon.rooms[dungeon.rooms.length - 2] || dungeon.rooms[dungeon.rooms.length - 1];
                monsters.push(new Monster(bossRoom.cx * TILE + TILE/2, bossRoom.cy * TILE + TILE/2, 'demonlord', G.floor));
                addLog(`âš  ãƒ‡ãƒ¼ãƒ¢ãƒ³ãƒ­ãƒ¼ãƒ‰ãŒç¾ã‚ŒãŸï¼`, '#ff0000');
            }

            addLog(`åœ°ä¸‹${G.floor}éšã«é™ã‚ŠãŸ`, '#aaaaff');
        }

        // Switch back to normal RNG after dungeon generation
        unseedRng();
    }

    // ========== LEVEL UP NOTICE ==========
    let levelUpTimer = 0;
    function showLevelUp() {
        levelUpTimer = 2;
        DOM.levelUpNotice.style.display = 'block';
    }

    // ========== UI UPDATES ==========
    function updateStatsPanel() {
        const el = DOM.statsContent;
        if (!isPanelVisible(DOM.statsPanel)) return;
        const btn = (stat) => player.statPoints > 0 ? `<button class="stat-btn" onclick="allocStat('${stat}')">+</button>` : '';
        const hpPct = Math.round(player.hp / player.maxHP * 100);
        const mpPct = Math.round(player.mp / player.maxMP * 100);
        const xpPct = Math.round(player.xp / player.xpToNext * 100);
        const shieldOn = player.shieldT > 0 ? '<span style="color:#88f"> [ã‚·ãƒ¼ãƒ«ãƒ‰ä¸­]</span>' : '';
        const killCount = G.totalKills || 0;

        el.innerHTML = `
            <div style="text-align:center;margin-bottom:8px">
                <span style="color:#ffd700;font-size:18px;font-weight:bold">Lv.${player.level}</span>
                <span style="color:#888;font-size:11px;margin-left:8px">å‹‡è€…</span>
            </div>
            <div style="background:#1a1020;border:1px solid #333;padding:6px;margin-bottom:8px;border-radius:3px">
                <div style="display:flex;justify-content:space-between;margin-bottom:4px">
                    <span style="color:#ff6666">HP ${Math.round(player.hp)}/${player.maxHP}</span>
                    <span style="color:#ff6666;font-size:10px">${hpPct}%</span>
                </div>
                <div style="background:#300;height:8px;border-radius:4px;overflow:hidden;margin-bottom:6px">
                    <div style="background:linear-gradient(90deg,#cc0000,#ff4444);height:100%;width:${hpPct}%;border-radius:4px;transition:width 0.3s"></div>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px">
                    <span style="color:#6688ff">MP ${Math.round(player.mp)}/${player.maxMP}</span>
                    <span style="color:#6688ff;font-size:10px">${mpPct}%</span>
                </div>
                <div style="background:#003;height:8px;border-radius:4px;overflow:hidden;margin-bottom:6px">
                    <div style="background:linear-gradient(90deg,#0044cc,#4488ff);height:100%;width:${mpPct}%;border-radius:4px;transition:width 0.3s"></div>
                </div>
                <div style="display:flex;justify-content:space-between;margin-bottom:4px">
                    <span style="color:#aa66ff">XP ${player.xp}/${player.xpToNext}</span>
                    <span style="color:#aa66ff;font-size:10px">${xpPct}%</span>
                </div>
                <div style="background:#201030;height:6px;border-radius:3px;overflow:hidden">
                    <div style="background:linear-gradient(90deg,#6622cc,#aa66ff);height:100%;width:${xpPct}%;border-radius:3px;transition:width 0.3s"></div>
                </div>
            </div>
            <div style="color:#ffcc44;font-size:11px;margin-bottom:4px">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚¤ãƒ³ãƒˆ: <span style="color:#ff8;font-weight:bold">${player.statPoints}</span></div>
            <hr style="border-color:#333;margin:6px 0">
            <div class="stat-row"><span class="stat-label">âš” ç­‹åŠ› (STR)</span><span class="stat-value">${player.getTotalStat('str')} ${btn('str')}</span></div>
            <div style="font-size:9px;color:#666;margin:-2px 0 4px 18px">ç‰©ç†ãƒ€ãƒ¡ãƒ¼ã‚¸å¢—åŠ </div>
            <div class="stat-row"><span class="stat-label">ğŸ¹ æ•æ· (DEX)</span><span class="stat-value">${player.getTotalStat('dex')} ${btn('dex')}</span></div>
            <div style="font-size:9px;color:#666;margin:-2px 0 4px 18px">ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡å¢—åŠ </div>
            <div class="stat-row"><span class="stat-label">â¤ ä½“åŠ› (VIT)</span><span class="stat-value">${player.getTotalStat('vit')} ${btn('vit')}</span></div>
            <div style="font-size:9px;color:#666;margin:-2px 0 4px 18px">æœ€å¤§HP +5/pt</div>
            <div class="stat-row"><span class="stat-label">âœ¨ çŸ¥åŠ› (INT)</span><span class="stat-value">${player.getTotalStat('int')} ${btn('int')}</span></div>
            <div style="font-size:9px;color:#666;margin:-2px 0 4px 18px">æœ€å¤§MP +3/ptã€å›å¾©é‡å¢—åŠ </div>
            <hr style="border-color:#333;margin:6px 0">
            <div style="color:#ccc;font-size:11px;margin-bottom:4px">âš” æˆ¦é—˜ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</div>
            <div class="stat-row"><span class="stat-label">æ”»æ’ƒåŠ›</span><span class="stat-value" style="color:#ff8866">${player.getAttackDmg()}</span></div>
            <div class="stat-row"><span class="stat-label">é˜²å¾¡åŠ›</span><span class="stat-value" style="color:#88aaff">${player.getDefense()}${shieldOn}</span></div>
            <div class="stat-row"><span class="stat-label">ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡</span><span class="stat-value" style="color:#ffcc44">${player.getCritChance().toFixed(1)}%</span></div>
            <div class="stat-row"><span class="stat-label">ãƒ©ã‚¤ãƒ•ã‚¹ãƒ†ã‚£ãƒ¼ãƒ«</span><span class="stat-value" style="color:#44ff88">${player.getLifesteal()}%</span></div>
            <div class="stat-row"><span class="stat-label">ç§»å‹•é€Ÿåº¦</span><span class="stat-value">${Math.round(player.speed)}</span></div>
            <hr style="border-color:#333;margin:6px 0">
            <div style="color:#ccc;font-size:11px;margin-bottom:4px">ğŸ—º æ¢ç´¢æƒ…å ±</div>
            <div class="stat-row"><span class="stat-label">ç¾åœ¨éšå±¤</span><span class="stat-value" style="color:#aa88ff">B${G.floor}F</span></div>
            <div class="stat-row"><span class="stat-label">æ®‹ã‚Šæ•µæ•°</span><span class="stat-value" style="color:#ff6666">${monsters.filter(m=>m.alive).length}</span></div>
            <div class="stat-row"><span class="stat-label">æ‰€æŒã‚¢ã‚¤ãƒ†ãƒ </span><span class="stat-value">${player.inventory.length}/${player.maxInv}</span></div>
        `;
    }

    function renderHelpUI() {
        // Update skill slot display (1-6 keys)
        const slotsEl = document.getElementById('helpSkillSlots');
        if (slotsEl && player.skills) {
            let slotsHtml = '';
            for (let i = 1; i <= 6; i++) {
                const sk = player.skills[i];
                if (sk && sk.id) {
                    const lvl = player.skillLevels[sk.id] || 0;
                    slotsHtml += `<div style="margin:2px 0"><span style="color:#ffd700">${i}</span> â”€ ${sk.icon} ${sk.name} Lv.${lvl} (${sk.mp}MP) â”€ ${sk.desc || ''}</div>`;
                } else {
                    slotsHtml += `<div style="color:#666;margin:2px 0"><span style="color:#ffd700">${i}</span> â”€ æœªè¨­å®š (Rã‚­ãƒ¼ã§ã‚¹ã‚­ãƒ«ç·¨é›†)</div>`;
                }
            }
            slotsEl.innerHTML = slotsHtml || '<div style="color:#888">ã‚¹ã‚­ãƒ«ã‚¹ãƒ­ãƒƒãƒˆæƒ…å ±ãŒã‚ã‚Šã¾ã›ã‚“</div>';
        }

        const el = document.getElementById('helpDynamic');
        if (!el) return;

        let html = '';

        // Add unspent skill points banner
        if (player.skillPoints > 0) {
            html += `<div style="background:#aa5522;border:2px solid #ffd700;padding:8px;margin:10px 0;text-align:center;border-radius:4px">
                âš¡ æœªä½¿ç”¨ã®ã‚¹ã‚­ãƒ«ãƒã‚¤ãƒ³ãƒˆãŒ${player.skillPoints}å€‹ã‚ã‚Šã¾ã™ï¼Tã‚­ãƒ¼ã§ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ã‚’é–‹ã„ã¦ã‚¹ã‚­ãƒ«ã‚’ç¿’å¾—ã—ã‚ˆã†
            </div>`;
        }

        html += `<div style="color:#daa520;font-weight:bold;margin:14px 0 4px">ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã¾ã¨ã‚</div>`;
        html += `<div style="font-size:12px;color:#999">ãƒ»æ•µã‚’å€’ã—ã¦çµŒé¨“å€¤ã‚’ç²å¾—ã€ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—ã§èƒ½åŠ›/ã‚¹ã‚­ãƒ«å¼·åŒ–</div>`;
        html += `<div style="font-size:12px;color:#999">ãƒ»ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼(T)ã§ç¿’å¾—ã€ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆç·¨é›†(R)ã§å‰²ã‚Šå½“ã¦</div>`;
        html += `<div style="font-size:12px;color:#999">ãƒ»éšæ®µã¯æ•µã‚’å…¨æ»…ã§ä½¿ç”¨å¯èƒ½ã€è¿‘ã¥ã„ã¦Eã§é™ã‚Šã‚‹</div>`;
        html += `<div style="font-size:12px;color:#999">ãƒ»è£…å‚™ã¯ã‚¤ãƒ³ãƒ™ãƒ³ãƒˆãƒª(I)ã§è£…ç€/è§£é™¤</div>`;

        if (!G.playerClass || !CLASS_DEFS[G.playerClass]) {
            html += `<div style="color:#daa520;font-weight:bold;margin:12px 0 4px">ã‚¹ã‚­ãƒ«ä¸€è¦§</div>`;
            html += `<div style="font-size:12px;color:#888">ã‚¯ãƒ©ã‚¹é¸æŠå¾Œã«è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚</div>`;
            el.innerHTML = html;
            return;
        }

        // ã‚¯ãƒ©ã‚¹æ˜‡æ ¼æƒ…å ±
        const classDef = CLASS_DEFS[G.playerClass];
        html += `<div style="color:#daa520;font-weight:bold;margin:14px 0 4px;border-top:1px solid #5a4a3a;padding-top:12px">ã‚¯ãƒ©ã‚¹é€²åŒ–ã‚·ã‚¹ãƒ†ãƒ </div>`;
        html += `<div style="font-size:12px;color:#ccc;margin-bottom:8px">ç¾åœ¨ã®ã‚¯ãƒ©ã‚¹: <span style="color:#ffd700">${classDef.icon} ${classDef.name}</span></div>`;

        if (classDef.tier === 1) {
            // æ—¢ã«æ˜‡æ ¼æ¸ˆã¿
            html += `<div style="font-size:11px;color:#88ff88;margin:4px 0">âœ“ ä¸Šä½ã‚¯ãƒ©ã‚¹ã«æ˜‡æ ¼æ¸ˆã¿</div>`;
            if (classDef.baseClass) {
                const base = CLASS_DEFS[classDef.baseClass];
                html += `<div style="font-size:11px;color:#aaa">${base.icon} ${base.name} â†’ ${classDef.icon} ${classDef.name}</div>`;
            }
        } else if (player.level >= PROMOTION_LEVEL) {
            // æ˜‡æ ¼å¯èƒ½
            html += `<div style="font-size:11px;color:#ffaa44;margin:4px 0">âš¡ ãƒ¬ãƒ™ãƒ«${PROMOTION_LEVEL}åˆ°é”ï¼æ˜‡æ ¼å¯èƒ½ã§ã™</div>`;
            const promos = CLASS_PROMOTIONS[G.playerClass] || [];
            if (promos.length > 0) {
                html += `<div style="font-size:11px;color:#daa520;margin:6px 0 2px">æ˜‡æ ¼å…ˆ:</div>`;
                for (const p of promos) {
                    const pDef = CLASS_DEFS[p.key];
                    if (pDef) {
                        html += `<div style="font-size:12px;color:#ffd700;margin:6px 0 2px 12px;font-weight:bold">${pDef.icon} ${pDef.name}</div>`;
                        // ã‚¹ã‚­ãƒ«ãƒ–ãƒ©ãƒ³ãƒã‚’è¡¨ç¤º
                        if (pDef.branches && pDef.branches.length > 0 && pDef.skills && pDef.skills.length > 0) {
                            html += `<div style="font-size:10px;color:#aaa;margin:2px 0 2px 24px">ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼:</div>`;
                            for (let i = 0; i < pDef.branches.length; i++) {
                                const branchName = pDef.branches[i];
                                const branchSkills = pDef.skills.filter(sk => sk.branch === i);
                                if (branchSkills.length > 0) {
                                    html += `<div style="font-size:10px;color:#daa520;font-weight:bold;margin:4px 0 2px 24px">${branchName}</div>`;
                                    for (const sk of branchSkills) {
                                        html += `<div style="font-size:9px;color:#999;margin:1px 0 1px 36px">ãƒ»${sk.icon} ${sk.name} (${sk.mp}MP)</div>`;
                                    }
                                }
                            }
                        }
                    }
                }
                html += `<div style="font-size:10px;color:#888;margin:6px 0">â€»ãƒ¬ãƒ™ãƒ«ã‚¢ãƒƒãƒ—æ™‚ã«é¸æŠç”»é¢ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>`;
            }
        } else {
            // ã¾ã æ˜‡æ ¼ä¸å¯
            const promos = CLASS_PROMOTIONS[G.playerClass] || [];
            if (promos.length > 0) {
                const needed = PROMOTION_LEVEL - player.level;
                html += `<div style="font-size:11px;color:#888;margin:4px 0">ãƒ¬ãƒ™ãƒ«${PROMOTION_LEVEL}ã§ä¸Šä½ã‚¯ãƒ©ã‚¹ã«æ˜‡æ ¼å¯èƒ½ (ã‚ã¨${needed}ãƒ¬ãƒ™ãƒ«)</div>`;
                html += `<div style="font-size:11px;color:#daa520;margin:6px 0 2px">æ˜‡æ ¼å…ˆ:</div>`;
                for (const p of promos) {
                    const pDef = CLASS_DEFS[p.key];
                    if (pDef) {
                        html += `<div style="font-size:12px;color:#ccb38a;margin:6px 0 2px 12px;font-weight:bold">${pDef.icon} ${pDef.name}</div>`;
                        // ã‚¹ã‚­ãƒ«ãƒ–ãƒ©ãƒ³ãƒã‚’è¡¨ç¤º
                        if (pDef.branches && pDef.branches.length > 0 && pDef.skills && pDef.skills.length > 0) {
                            html += `<div style="font-size:10px;color:#888;margin:2px 0 2px 24px">ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼:</div>`;
                            for (let i = 0; i < pDef.branches.length; i++) {
                                const branchName = pDef.branches[i];
                                const branchSkills = pDef.skills.filter(sk => sk.branch === i);
                                if (branchSkills.length > 0) {
                                    html += `<div style="font-size:10px;color:#ccb38a;font-weight:bold;margin:4px 0 2px 24px">${branchName}</div>`;
                                    for (const sk of branchSkills) {
                                        html += `<div style="font-size:9px;color:#888;margin:1px 0 1px 36px">ãƒ»${sk.icon} ${sk.name} (${sk.mp}MP)</div>`;
                                    }
                                }
                            }
                        }
                    }
                }
            } else {
                html += `<div style="font-size:11px;color:#888;margin:4px 0">ã“ã®ã‚¯ãƒ©ã‚¹ã¯æœ€çµ‚å½¢æ…‹ã§ã™</div>`;
            }
        }

        const baseDef = classDef.baseClass ? CLASS_DEFS[classDef.baseClass] : null;
        const list = [];
        const seen = new Set();

        for (const sk of classDef.skills) {
            list.push({ sk, classLabel: classDef.name, branchLabel: classDef.branches[sk.branch] || '' });
            seen.add(sk.id);
        }
        if (baseDef) {
            for (const sk of baseDef.skills) {
                if (seen.has(sk.id)) continue;
                list.push({ sk, classLabel: baseDef.name, branchLabel: baseDef.branches[sk.branch] || '' });
                seen.add(sk.id);
            }
        }

        html += `<div style="color:#daa520;font-weight:bold;margin:12px 0 6px">ã‚¹ã‚­ãƒ«ä¸€è¦§</div>`;

        let currentClass = '';
        let currentBranch = '';
        for (const row of list) {
            if (row.classLabel !== currentClass) {
                currentClass = row.classLabel;
                currentBranch = '';
                html += `<div style="color:#ccb38a;font-size:12px;margin:6px 0 2px">${currentClass}</div>`;
            }
            if (row.branchLabel && row.branchLabel !== currentBranch) {
                currentBranch = row.branchLabel;
                html += `<div style="color:#888;font-size:11px;margin:4px 0 2px">${currentBranch}</div>`;
            }
            const skillLvl = player.skillLevels[row.sk.id] || 0;
            let badge = '';
            if (skillLvl > 0) {
                badge = `<span style="font-size:8px;background:#228822;color:#88ff88;padding:2px 5px;border-radius:3px;font-weight:bold;margin-left:6px">ç¿’å¾—æ¸ˆ L${skillLvl}</span>`;
            } else {
                badge = `<span style="font-size:8px;background:#aa6622;color:#ffd700;padding:2px 5px;border-radius:3px;font-weight:bold;margin-left:6px">è§£æ”¾æ¸ˆ</span>`;
            }
            html += `<div style="display:flex;justify-content:space-between;gap:8px;font-size:11px;color:#ddd">
                <div>${row.sk.icon} ${row.sk.name}${badge}</div>
                <div style="color:#88a">${row.sk.mp}MP / ${row.sk.cd}s</div>
            </div>`;
            html += `<div style="font-size:10px;color:#777;margin:2px 0 6px 16px">${effectDesc(row.sk)}</div>`;
        }

        // Detailed Skill Information Section (learned skills only)
        html += `<div style="color:#daa520;font-weight:bold;margin:16px 0 8px;border-top:2px solid #666;padding-top:8px">ç¿’å¾—æ¸ˆã¿ã‚¹ã‚­ãƒ«è©³ç´°</div>`;
        html += `<div style="color:#888;font-size:10px;margin-bottom:8px">â€»ãƒ¬ãƒ™ãƒ«1ä»¥ä¸Šã®ã‚¹ã‚­ãƒ«ã®ã¿è¡¨ç¤º</div>`;

        // Get all learned skills (level 1+)
        const learnedSkills = list.filter(row => (player.skillLevels[row.sk.id] || 0) > 0);

        if (learnedSkills.length === 0) {
            html += `<div style="color:#666;font-size:11px;text-align:center;margin:12px 0">ã¾ã ã‚¹ã‚­ãƒ«ã‚’ç¿’å¾—ã—ã¦ã„ã¾ã›ã‚“ (Tã‚­ãƒ¼ã§ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼ã‚’é–‹ã)</div>`;
        } else {
            for (const row of learnedSkills) {
                const sk = row.sk;
                const skillLvl = player.skillLevels[sk.id] || 0;
                const allAvail = getAllAvailableSkills();
                const skDef = allAvail.find(s => s.id === sk.id);

                // Skill card container
                html += `<div style="background:#1a1a2e;border:1px solid #444;border-radius:4px;padding:8px;margin:6px 0">`;

                // Skill header
                html += `<div style="display:flex;align-items:center;justify-content:space-between">`;
                html += `<div style="display:flex;align-items:center;gap:8px">`;
                html += `<span style="font-size:20px">${sk.icon}</span>`;
                html += `<span style="color:#ffd700;font-size:13px;font-weight:bold">${sk.name}</span>`;
                html += `<span style="color:#88ff88;font-size:10px">Lv.${skillLvl}/5</span>`;
                html += `</div>`;
                html += `<span style="color:#888;font-size:9px">${row.branchLabel}</span>`;
                html += `</div>`;

                // Stats row
                html += `<div style="margin:6px 0;font-size:10px;color:#aaa">`;
                html += `<span style="color:#4488ff">MP: ${sk.mp}</span> | `;
                html += `<span style="color:#ff88aa">CD: ${sk.cd}s</span>`;

                // Add level-specific stats
                if (skDef) {
                    const li = skillLvl - 1; // 0-indexed
                    if (skDef.baseMult && skDef.baseMult[li]) {
                        html += ` | <span style="color:#ffaa44">å€ç‡: x${skDef.baseMult[li]}</span>`;
                    }
                    if (skDef.range) {
                        html += ` | <span style="color:#88ff88">å°„ç¨‹: ${skDef.range}</span>`;
                    }
                    if (skDef.duration && skDef.duration[li]) {
                        html += ` | <span style="color:#ffdd88">æŒç¶š: ${skDef.duration[li]}s</span>`;
                    }
                }
                html += `</div>`;

                // Description
                html += `<div style="font-size:10px;color:#ccc;margin-top:4px">${effectDesc(sk)}</div>`;

                // Level progression bar
                html += `<div style="margin-top:6px;display:flex;gap:2px">`;
                for (let i = 1; i <= 5; i++) {
                    const active = i <= skillLvl;
                    const barColor = active ? '#ffd700' : '#333';
                    const barHeight = active ? '6px' : '4px';
                    html += `<div style="flex:1;height:${barHeight};background:${barColor};border-radius:2px"></div>`;
                }
                html += `</div>`;

                html += `</div>`; // Close skill card
            }
        }

        el.innerHTML = html;
    }

    window.allocStat = function(stat) {
        if (player.statPoints <= 0) return;
        player[stat]++;
        player.statPoints--;
        player.recalcStats();
        updateStatsPanel();
    };

    function updateInventoryPanel() {
        const el = DOM.inventoryContent;
        if (!isPanelVisible(DOM.inventoryPanel)) return;

        let html = '<div style="color:#aaa;font-size:11px;margin-bottom:6px">è£…å‚™ã‚¹ãƒ­ãƒƒãƒˆ (ã‚¯ãƒªãƒƒã‚¯ã§å¤–ã™)</div>';
        html += '<div class="equip-slots">';
        const slotNames = { weapon: 'æ­¦å™¨', offhand: 'ç›¾', head: 'é ­', body: 'èƒ´', ring: 'æŒ‡', amulet: 'é¦–', feet: 'è¶³' };
        for (const [slot, label] of Object.entries(slotNames)) {
            const item = player.equipment[slot];
            const filled = item ? 'filled' : '';
            const style = item ? `border-color:${item.rarity.color}` : '';
            html += `<div class="equip-slot ${filled}" style="${style}" onclick="unequipSlot('${slot}')"
                onmouseenter="showEquipTooltip(event,'${slot}')" onmouseleave="hideTooltip()">
                ${item ? item.icon : ''}
                <div class="slot-label">${label}</div>
            </div>`;
        }
        html += '</div>';

        html += `<div style="color:#aaa;font-size:11px;margin:8px 0 4px">æ‰€æŒå“ ${player.inventory.length}/${player.maxInv} (ã‚¯ãƒªãƒƒã‚¯ã§è£…å‚™/ãƒ€ãƒ–ãƒ«ã‚¯ãƒªãƒƒã‚¯ã§æ¨ã¦ã‚‹)</div>`;
        html += '<div class="inv-grid">';
        for (let i = 0; i < player.maxInv; i++) {
            const item = player.inventory[i];
            if (item) {
                html += `<div class="inv-cell" style="border-color:${item.rarity.color}40"
                    onclick="equipInvItem(${i})" ondblclick="dropInvItem(${i})"
                    onmouseenter="showInvTooltip(event,${i})" onmouseleave="hideTooltip()">
                    ${item.icon}
                </div>`;
            } else {
                html += '<div class="inv-cell"></div>';
            }
        }
        html += '</div>';
        el.innerHTML = html;
    }

    window.unequipSlot = function(slot) { player.unequipSlot(slot); updateInventoryPanel(); };
    window.equipInvItem = function(i) { player.equipItem(i); updateInventoryPanel(); };
    window.dropInvItem = function(i) {
        const item = player.inventory[i];
        if (item) {
            dropItem(player.x, player.y, item);
            player.inventory.splice(i, 1);
            addLog(`${item.name} ã‚’æ¨ã¦ãŸ`, '#888');
            updateInventoryPanel();
        }
    };

    function buildTooltipHTML(item) {
        if (!item) return '';
        let html = `<div class="tt-name" style="color:${item.rarity.color}">${item.name}</div>`;
        html += `<div class="tt-type">${item.typeInfo.name} â€” ${item.rarity.name}</div>`;
        if (item.baseDmg) html += `<div style="color:#fff;margin:4px 0">ãƒ€ãƒ¡ãƒ¼ã‚¸: ${item.baseDmg[0]}-${item.baseDmg[1]}</div>`;
        if (item.baseDef) html += `<div style="color:#fff;margin:4px 0">é˜²å¾¡: +${item.baseDef}</div>`;
        for (const a of item.affixes) html += `<div class="tt-affix">${a.text}</div>`;
        if (item.typeInfo.slot) html += `<div class="tt-equip">ã‚¯ãƒªãƒƒã‚¯ã§è£…å‚™</div>`;
        return html;
    }

    function effectDesc(sk) {
        if (!sk) return '';
        const range = (arr) => Array.isArray(arr) ? `${arr[0]}-${arr[arr.length - 1]}` : '';
        const mult = (arr) => Array.isArray(arr) ? `x${arr[0]}ã€œx${arr[arr.length - 1]}` : '';
        const dur = (arr) => Array.isArray(arr) ? `${arr[0]}ã€œ${arr[arr.length - 1]}ç§’` : '';
        const pct = (arr) => Array.isArray(arr) ? `${Math.round(arr[0] * 100)}ã€œ${Math.round(arr[arr.length - 1] * 100)}%` : '';
        switch (sk.effect) {
            case 'melee_burst': return `è¿‘æ¥å˜ä½“ã«å¼·æ‰“ã€‚å€ç‡ ${mult(sk.baseMult)} / å°„ç¨‹ ${sk.range || '-'}ã€‚`;
            case 'whirlwind': return `è¿‘æ¥ç¯„å›²æ”»æ’ƒã€‚å€ç‡ ${mult(sk.baseMult)} / åŠå¾„ ${sk.range || '-'}ã€‚`;
            case 'stun_aoe': return `ç¯„å›²ã‚¹ã‚¿ãƒ³ã€‚æŒç¶š ${dur(sk.duration)} / åŠå¾„ ${sk.range || '-'}ã€‚`;
            case 'buff_frenzy': return `æ”»æ’ƒé€Ÿåº¦/ç§»å‹•é€Ÿåº¦ã‚’å¼·åŒ–ã€‚æŒç¶š ${dur(sk.duration)}ã€‚`;
            case 'execute': return `HPãŒä½ã„æ•µã«å¼·çƒˆãªä¸€æ’ƒã€‚å€ç‡ ${mult(sk.baseMult)} / ã—ãã„å€¤ ${pct(sk.threshold)}ã€‚`;
            case 'debuff_defense': return `é˜²å¾¡ä½ä¸‹ã€‚æŒç¶š ${dur(sk.duration)} / ä½ä¸‹ ${pct(sk.reduction)} / åŠå¾„ ${sk.range || '-'}ã€‚`;
            case 'buff_defense': return `è¢«ãƒ€ãƒ¡è»½æ¸›ã€‚æŒç¶š ${dur(sk.duration)} / è»½æ¸› ${pct(sk.reduction)}ã€‚`;
            case 'buff_crit': return `ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ä¸Šæ˜‡ã€‚æŒç¶š ${dur(sk.duration)} / +${range(sk.bonus)}%ã€‚`;
            case 'battle_orders': return `æœ€å¤§HP/MPã‚’å¼·åŒ–ã€‚æŒç¶š ${dur(sk.duration)} / +${pct(sk.bonus)}ã€‚`;
            case 'charge': return `æŒ‡å®šä½ç½®ã¸çªé€²ã—ã¦æ”»æ’ƒã€‚å€ç‡ ${mult(sk.baseMult)} / è·é›¢ ${sk.range || '-'}ã€‚`;
            case 'ground_slam': return `åœ°é¢è¡æ’ƒã§ç¯„å›²æ”»æ’ƒã€‚å€ç‡ ${mult(sk.baseMult)} / æ¸›é€Ÿ ${pct(sk.slow)}ã€‚`;
            case 'buff_berserk': return `æ”»æ’ƒåŠ›å¼·åŒ–çŠ¶æ…‹ã€‚æŒç¶š ${dur(sk.duration)}ã€‚`;
            case 'buff_speed': return `ç§»å‹•é€Ÿåº¦ä¸Šæ˜‡ã€‚æŒç¶š ${dur(sk.duration)} / +${pct(sk.bonus)}ã€‚`;
            case 'buff_atkspd': return `æ”»æ’ƒé€Ÿåº¦ä¸Šæ˜‡ã€‚æŒç¶š ${dur(sk.duration)} / +${pct(sk.bonus)}ã€‚`;
            case 'buff_poison': return `æ¯’ä»˜ä¸ã€‚æŒç¶š ${dur(sk.duration)} / æ¯’DPS ${range(sk.dps)}ã€‚`;
            case 'chain_lightning': return `é€£é–ç¨²å¦»ã€‚å€ç‡ ${mult(sk.baseMult)} / é€£é– ${range(sk.bounces)}å›ã€‚`;
            case 'consecrate': return `ç¯„å›²æŒç¶šãƒ€ãƒ¡ãƒ¼ã‚¸ã€‚å€ç‡ ${mult(sk.baseMult)} / åŠå¾„ ${sk.range || '-'} / æŒç¶š ${dur(sk.duration)}ã€‚`;
            case 'multi_shot': return `è¤‡æ•°å¼¾ã‚’ç™ºå°„ã€‚å€ç‡ ${mult(sk.baseMult)} / æœ¬æ•° ${range(sk.arrows)}ã€‚`;
            case 'projectile_fire': return `å¼¾ã‚’ç™ºå°„ã€‚å€ç‡ ${mult(sk.baseMult)} / é€Ÿåº¦ ${sk.speed || '-'}ã€‚`;
            case 'arrow_rain': return `çŸ¢ã®é›¨ã€‚å€ç‡ ${mult(sk.baseMult)} / åŠå¾„ ${sk.range || '-'}ã€‚`;
            case 'frost_nova': return `å†·æ°—çˆ†ç™ºã§å‡çµã€‚å€ç‡ ${mult(sk.baseMult)} / å‡çµ ${range(sk.freeze)}ç§’ã€‚`;
            case 'summon_minion': return `ãƒŸãƒ‹ã‚ªãƒ³å¬å–šã€‚æŒç¶š ${dur(sk.duration)} / HP ${range(sk.minionHP)} / ATK ${range(sk.minionDmg)}ã€‚`;
            case 'buff_dodge': return `å›é¿ç‡ä¸Šæ˜‡ã€‚æŒç¶š ${dur(sk.duration)} / ${range(sk.chance)}%ã€‚`;
            case 'teleport': return `çŸ­è·é›¢ãƒ†ãƒ¬ãƒãƒ¼ãƒˆã€‚è·é›¢ ${range(sk.range)}ã€‚`;
            case 'mana_shield': return `è¢«ãƒ€ãƒ¡ã‚’MPã§å¸åã€‚æŒç¶š ${dur(sk.duration)} / å¸å ${pct(sk.absorb)}ã€‚`;
            case 'buff_counter': return `è¢«å¼¾æ™‚ã«åå°„ã€‚æŒç¶š ${dur(sk.duration)} / åå°„ ${pct(sk.reflect)}ã€‚`;
            case 'buff_aura': return `å›å¾©ã‚ªãƒ¼ãƒ©ã€‚æŒç¶š ${dur(sk.duration)} / å›å¾© ${range(sk.regen)} / è¢«ãƒ€ãƒ¡è»½æ¸› ${pct(sk.reduction)}ã€‚`;
            case 'frozen_orb': return `æ°·ã®ã‚ªãƒ¼ãƒ–ãŒç ´ç‰‡ã‚’æ’’ãã€‚å€ç‡ ${mult(sk.baseMult)} / ç ´ç‰‡ ${range(sk.shardCount)}ã€‚`;
            case 'meteor': return `éš•çŸ³è½ä¸‹ã€‚å€ç‡ ${mult(sk.baseMult)} / åŠå¾„ ${sk.range || '-'}ã€‚`;
            case 'holy_burst': return `è–å±æ€§ã®ç¯„å›²æ”»æ’ƒã€‚å€ç‡ ${mult(sk.baseMult)} / åŠå¾„ ${sk.range || '-'}ã€‚`;
            case 'place_trap': return `ç½ ã‚’è¨­ç½®ã€‚æŒç¶š ${dur(sk.duration)} / ãƒ€ãƒ¡ãƒ¼ã‚¸ ${mult(sk.baseMult)}ã€‚`;
            case 'self_heal_pct': return `è‡ªåˆ†ã®HPå›å¾©ã€‚å›å¾©é‡ ${range(sk.healPct)}%ã€‚`;
            case 'shadow_strike': return `å½±ã‹ã‚‰æ€¥è¥²ã€‚å€ç‡ ${mult(sk.baseMult)} / å°„ç¨‹ ${sk.range || '-'}ã€‚`;
            case 'smoke_screen': return `ç…™å¹•ã§ç„¡æ•µ/å›é¿å¼·åŒ–ã€‚æŒç¶š ${dur(sk.duration)}ã€‚`;
            default: return sk.desc || '';
        }
    }

    function buildSkillTooltipHTML(sk, slot) {
        if (!sk) return '';
        const name = `${sk.icon || ''} ${sk.name || ''}`.trim();
        const mp = sk.mp != null ? `MP: ${sk.mp}` : '';
        const cd = sk.cd != null ? `CD: ${sk.cd}s` : (sk.maxCD != null ? `CD: ${sk.maxCD}s` : '');
        const key = slot ? `ã‚­ãƒ¼: ${slot}` : '';
        const meta = [key, mp, cd].filter(Boolean).join(' | ');
        return `<div class="tt-name" style="color:#ffd700">${name}</div>
            ${meta ? `<div class="tt-type">${meta}</div>` : ''}
            <div style="color:#ccc;margin-top:4px;font-size:11px">${effectDesc(sk)}</div>`;
    }

    window.showInvTooltip = function(e, i) {
        const item = player.inventory[i];
        if (!item) return;
        const tt = DOM.tooltip;
        tt.innerHTML = buildTooltipHTML(item);
        tt.style.display = 'block';
        tt.style.left = (e.clientX + 15) + 'px';
        tt.style.top = (e.clientY - 10) + 'px';
    };
    window.showEquipTooltip = function(e, slot) {
        const item = player.equipment[slot];
        if (!item) return;
        const tt = DOM.tooltip;
        tt.innerHTML = buildTooltipHTML(item);
        tt.style.display = 'block';
        tt.style.left = (e.clientX + 15) + 'px';
        tt.style.top = (e.clientY - 10) + 'px';
    };
    window.showSkillTooltip = function(e, skillId) {
        const allAvail = getAllAvailableSkills();
        const sk = allAvail.find(s => s.id === skillId);
        if (!sk) return;
        const tt = DOM.tooltip;
        tt.innerHTML = buildSkillTooltipHTML(sk);
        tt.style.display = 'block';
        tt.style.left = (e.clientX + 15) + 'px';
        tt.style.top = (e.clientY - 10) + 'px';
    };
    window.hideTooltip = function() { DOM.tooltip.style.display = 'none'; };

    function updateSkillTreeUI() {
        const el = DOM.skillTreeContent;
        if (!G.playerClass) return;
        const classDef = CLASS_DEFS[G.playerClass];
        const baseClassDef = classDef.baseClass ? CLASS_DEFS[classDef.baseClass] : null;
        let html = `<div style="text-align:center;margin-bottom:10px">
            <span style="font-size:20px">${classDef.icon}</span>
            <span style="color:#ffd700;font-size:16px;font-weight:bold;margin-left:8px">${classDef.name}</span>
            <span style="color:#888;font-size:12px;margin-left:8px">(${classDef.engName})</span>
            ${classDef.tier > 0 ? '<span style="color:#ff8800;font-size:10px;margin-left:6px">â˜…ä¸Šä½ã‚¯ãƒ©ã‚¹</span>' : ''}
            <div style="color:#ffcc44;font-size:12px;margin-top:6px">ã‚¹ã‚­ãƒ«ãƒã‚¤ãƒ³ãƒˆ: <span style="color:#ff8;font-weight:bold">${player.skillPoints}</span></div>
        </div>`;
        html += `<div style="text-align:center;margin-bottom:8px">
            <span style="color:#aaa;font-size:11px">ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆæ“ä½œ:</span>
            <button class="toggle-btn" onclick="setSkillEditMode('assign')">ç·¨é›†ç”»é¢ (R)</button>
            ${treeSwapFromSlot ? `<button class="toggle-btn" style="margin-left:6px" onclick="cancelTreeSwap()">å…¥æ›¿ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
            <span style="color:#66ccff;font-size:11px;margin-left:6px">å…¥æ›¿ä¸­ (å…ƒã‚¹ãƒ­ãƒƒãƒˆ: ${treeSwapFromSlot})</span>` : ''}
        </div>`;
        if (treeSwapFromSlot) {
            html += `<div style="text-align:center;margin-bottom:10px">
                <span style="color:#888;font-size:11px">å…¥æ›¿å…ˆ (ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆå´):</span>
                ${[1,2,3,4,5,6].map(n => {
                    const sk = player.skills[n];
                    const label = sk ? `${n}:${sk.icon || ''} ${sk.name || ''}` : `${n}:ç©º`;
                    return `<button class="toggle-btn" style="margin-left:4px" onclick="treeSwapTo(${n})">${label}</button>`;
                }).join('')}
            </div>`;
        }

        function renderBranches(cDef, label) {
            let h = '';
            if (label) h += `<div style="color:#aa88ff;font-size:12px;text-align:center;margin:8px 0 4px;border-top:1px solid #333;padding-top:6px">${label}</div>`;
            for (let b = 0; b < cDef.branches.length; b++) {
                const branchSkills = cDef.skills.filter(s => s.branch === b);
                h += '<div class="skill-branch"><div class="skill-branch-title">' + cDef.branches[b] + '</div><div>';
                for (const sk of branchSkills) {
                    const lvl = player.skillLevels[sk.id] || 0;
                    const maxLvl = 5;
                    const allAvail = getAllAvailableSkills();
                    const canLearn = lvl < maxLvl && player.skillPoints > 0 &&
                        (!sk.prereq || (player.skillLevels[sk.prereq] || 0) >= 1);
                    const stateClass = lvl >= maxLvl ? 'maxed' : lvl > 0 ? 'unlocked' : canLearn ? '' : 'locked';
                    const lvlStars = 'â˜…'.repeat(lvl) + 'â˜†'.repeat(maxLvl - lvl);
                    const btnHtml = canLearn ? '<button class="sn-btn" onclick="learnSkill(\'' + sk.id + '\')">ç¿’å¾— (+1)</button>' : '';
                    const assignBtn = lvl > 0 ? '<button class="sn-btn" style="background:#4a6a4a;margin-left:4px" onclick="quickAssignSkill(\'' + sk.id + '\')">ã‚¹ãƒ­ãƒƒãƒˆã«è¨­å®š</button>' : '';
                    const shortcutBtns = lvl > 0
                        ? `<div style="margin-top:4px;display:flex;gap:4px;flex-wrap:wrap">
                            <button class="sn-btn" onclick="removeSkillById('${sk.id}')">å¤–ã™</button>
                            <button class="sn-btn" onclick="beginTreeSwap('${sk.id}')">å…¥æ›¿</button>
                           </div>`
                        : '';
                    const prereqName = sk.prereq ? allAvail.find(s=>s.id===sk.prereq)?.name || '' : '';
                    h += '<div class="skill-node ' + stateClass + '" onmouseenter="showSkillTooltip(event,\'' + sk.id + '\')" onmouseleave="hideTooltip()">' +
                        '<div class="sn-icon emoji-font">' + sk.icon + '</div>' +
                        '<div class="sn-name">' + sk.name + '</div>' +
                        '<div class="sn-level">' + lvlStars + ' (Lv.' + lvl + '/' + maxLvl + ')</div>' +
                        '<div class="sn-desc">' + effectDesc(sk) + '</div>' +
                        '<div style="color:#4488ff;font-size:9px;margin-top:2px">MP:' + sk.mp + ' CD:' + sk.cd + 's</div>' +
                        (sk.prereq ? '<div style="color:#885;font-size:9px">å¿…è¦: ' + prereqName + '</div>' : '') +
                        '<div style="margin-top:4px">' + btnHtml + assignBtn + '</div>' +
                        shortcutBtns +
                        '</div>';
                }
                h += '</div></div>';
            }
            return h;
        }

        html += renderBranches(classDef, null);
        if (baseClassDef) {
            html += renderBranches(baseClassDef, '--- ' + baseClassDef.name + 'ã‚¹ã‚­ãƒ« ---');
        }
        el.innerHTML = html;
    }

    window.learnSkill = function(skillId) {
        if (player.skillPoints <= 0) return;
        const allAvail = getAllAvailableSkills();
        const sk = allAvail.find(s => s.id === skillId);
        if (!sk) return;
        const lvl = player.skillLevels[skillId] || 0;
        if (lvl >= 5) return;
        if (sk.prereq && (player.skillLevels[sk.prereq] || 0) < 1) return;
        player.skillLevels[skillId] = lvl + 1;
        player.skillPoints--;
        // Update skill slot cooldown data
        for (let si = 1; si <= 6; si++) {
            if (player.skills[si] && player.skills[si].id === skillId) {
                player.skills[si].maxCD = sk.cd * (1 - (player.skillLevels[skillId] - 1) * 0.1);
            }
        }
        updateSkillTreeUI();
        addLog(`${sk.name} ã‚’Lv.${player.skillLevels[skillId]}ã«å¼·åŒ–ï¼`, '#ffd700');
    };

    function renderSettingsUI() {
        const rows = [
            { key: 'sound', label: 'ã‚µã‚¦ãƒ³ãƒ‰', value: SETTINGS.sound },
            { key: 'screenShake', label: 'ç”»é¢æºã‚Œ', value: SETTINGS.screenShake },
            { key: 'reducedParticles', label: 'ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å‰Šæ¸›', value: SETTINGS.reducedParticles },
            { key: 'filmGrain', label: 'ãƒ•ã‚£ãƒ«ãƒ ã‚°ãƒ¬ã‚¤ãƒ³', value: SETTINGS.filmGrain },
            { key: 'showFPS', label: 'FPS è¡¨ç¤º', value: SETTINGS.showFPS }
        ];
        let html = '<div style="color:#ccb38a;font-size:11px;margin-bottom:8px">ã‚²ãƒ¼ãƒ ã®æ¼”å‡ºã‚„è² è·ã‚’èª¿æ•´ã§ãã¾ã™ã€‚</div>';
        for (const r of rows) {
            const on = r.value ? 'ON' : 'OFF';
            const cls = r.value ? '' : 'off';
            html += `<div class="setting-row">
                <div class="setting-label">${r.label}</div>
                <button class="toggle-btn ${cls}" onclick="toggleSetting('${r.key}')">${on}</button>
            </div>`;
        }
        html += `<div class="setting-row">
            <div class="setting-label">è‡ªå‹•æ‹¾ã„</div>
            <button class="toggle-btn ${G.autoPickup ? '' : 'off'}" onclick="toggleAutoPickup()">${G.autoPickup ? 'ON' : 'OFF'}</button>
        </div>`;
        html += `<div class="setting-row">
            <div class="setting-label">æ‹¾ã„ãƒ•ã‚£ãƒ«ã‚¿</div>
            <button class="toggle-btn" onclick="cyclePickupFilter()">${getPickupFilterLabel()}</button>
        </div>`;
        html += `<div style="color:#ccb38a;font-size:11px;margin:10px 0 4px">ã‚»ãƒ¼ãƒ–ã‚¹ãƒ­ãƒƒãƒˆ</div>`;
        for (let i = 1; i <= SAVE_SLOT_COUNT; i++) {
            const meta = getSaveMeta(i);
            const active = G.saveSlot === i;
            const info = meta
                ? `Lv.${meta.level} / B${meta.floor}F / ${meta.className}`
                : 'ç©º';
            const time = meta && meta.timestamp
                ? new Date(meta.timestamp).toLocaleString('ja-JP')
                : '';
            html += `<div class="setting-row">
                <div class="setting-label">ã‚¹ãƒ­ãƒƒãƒˆ${i}${active ? ' â˜…' : ''}<div style="font-size:10px;color:#888">${info}${time ? ' / ' + time : ''}</div></div>
                <div class="setting-actions">
                    <button class="toggle-btn ${active ? '' : 'off'}" onclick="setSaveSlot(${i})">é¸æŠ</button>
                    <button class="toggle-btn" onclick="saveGame(${i})">ã‚»ãƒ¼ãƒ–</button>
                    <button class="toggle-btn" onclick="loadGame(${i})">ãƒ­ãƒ¼ãƒ‰</button>
                </div>
            </div>`;
        }
        DOM.settingsContent.innerHTML = html;
    }

    window.toggleSetting = function(key) {
        if (!(key in SETTINGS)) return;
        if (key === 'sound') {
            setSoundEnabled(!SETTINGS.sound);
        } else {
            SETTINGS[key] = !SETTINGS[key];
            saveSettings();
        }
        renderSettingsUI();
    };
    window.toggleAutoPickup = function() {
        G.autoPickup = !G.autoPickup;
        addLog(G.autoPickup ? 'è‡ªå‹•æ‹¾ã„: ON' : 'è‡ªå‹•æ‹¾ã„: OFF', '#ffdd44');
        renderSettingsUI();
    };
    function getPickupFilterLabel() {
        const names = ['ãƒãƒ¼ãƒãƒ«ä»¥ä¸Š','ãƒã‚¸ãƒƒã‚¯ä»¥ä¸Š','ãƒ¬ã‚¢ä»¥ä¸Š','ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼ä»¥ä¸Š'];
        const rarities = ['normal','magic','rare','legendary'];
        const idx = rarities.indexOf(G.autoPickupRarity);
        return names[idx] || names[0];
    }
    window.cyclePickupFilter = function() {
        const rarities = ['normal','magic','rare','legendary'];
        const idx = rarities.indexOf(G.autoPickupRarity);
        const next = (idx + 1) % rarities.length;
        G.autoPickupRarity = rarities[next];
        addLog('è‡ªå‹•æ‹¾ã„ãƒ•ã‚£ãƒ«ã‚¿: ' + getPickupFilterLabel(), '#ffdd44');
        renderSettingsUI();
    };

    function isPanelVisible(panel) {
        return getComputedStyle(panel).display !== 'none';
    }
    function setPanelVisible(panel, visible) {
        panel.style.display = visible ? 'block' : 'none';
    }
    function togglePanel(panel) {
        const visible = isPanelVisible(panel);
        panel.style.display = visible ? 'none' : 'block';
        return !visible;
    }

    function setPaused(paused) {
        G.paused = paused;
        DOM.pauseOverlay.style.display = paused ? 'flex' : 'none';
        if (paused) DOM.tooltip.style.display = 'none';
        if (paused) {
            for (const k of Object.keys(keysDown)) keysDown[k] = false;
        }
    }

    // ========== INPUT ==========
    let mouse = { x: 0, y: 0 };
    let keysDown = {};
    function getSkillBarSlotAt(mx, my) {
        const skillW = 48, skillH = 48, skillGap = 5;
        const numSkills = 6;
        const skillTotalW = numSkills * skillW + (numSkills - 1) * skillGap;
        const skillStartX = W / 2 - skillTotalW / 2;
        const skillY = H - 62;
        if (my < skillY || my > skillY + skillH) return 0;
        if (mx < skillStartX || mx > skillStartX + skillTotalW) return 0;
        const idx = Math.floor((mx - skillStartX) / (skillW + skillGap)) + 1;
        const slotX = skillStartX + (idx - 1) * (skillW + skillGap);
        if (mx > slotX + skillW) return 0; // gap
        return idx >= 1 && idx <= numSkills ? idx : 0;
    }

    canvas.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; }, { passive: true });

    canvas.addEventListener('contextmenu', e => { e.preventDefault(); });

    canvas.addEventListener('mousedown', e => {
        if (G.dead || !G.started || G.paused || isPanelVisible(DOM.settingsPanel) || skillSelectOpen) return;
        e.preventDefault();

        if (e.button === 2) {
            // Right click - use skill
            player.useSkill(mouse.x, mouse.y);
            return;
        }

        if (e.button === 0) {
            const skillSlot = getSkillBarSlotAt(mouse.x, mouse.y);
            if (skillSlot) {
                player.selectedSkill = skillSlot;
                return;
            }
            const wx = mouse.x + G.camX, wy = mouse.y + G.camY;

            // Check if clicking a monster
            let clickedMonster = null;
            for (const m of monsters) {
                if (m.alive && dist(wx, wy, m.x, m.y) < m.r + 10) {
                    clickedMonster = m;
                    break;
                }
            }

            if (clickedMonster) {
                player.attacking = true;
                player.attackTarget = clickedMonster;
                player.moving = true;
                player.targetX = clickedMonster.x;
                player.targetY = clickedMonster.y;
            } else {
                // Check ground items first
                let clickedItem = false;
                for (let i = groundItems.length - 1; i >= 0; i--) {
                    const gi = groundItems[i];
                    if (dist(wx, wy, gi.x, gi.y) < 25) {
                        // Move to item then pick up
                        player.targetX = gi.x;
                        player.targetY = gi.y;
                        player.moving = true;
                        player.attacking = false;
                        player.attackTarget = null;
                        clickedItem = true;
                        break;
                    }
                }
                if (!clickedItem) {
                    player.targetX = wx;
                    player.targetY = wy;
                    player.moving = true;
                    player.attacking = false;
                    player.attackTarget = null;
                }
            }
        }
    });

    window.addEventListener('keydown', e => {
        keysDown[e.key.toLowerCase()] = true;
        if (e.code) keysDown[e.code] = true;
        if (['arrowup','arrowdown','arrowleft','arrowright',' '].includes(e.key.toLowerCase())) e.preventDefault();

        // --- Title screen keyboard navigation ---
        if (!G.started) {
            if (G.titlePhase === 'start') {
                if (e.key === 'Enter' || e.code === 'Space') {
                    e.preventDefault();
                    if (hasSaveData(G.saveSlot)) {
                        initAudio();
                        loadGame(G.saveSlot);
                    } else {
                        showClassSelect();
                    }
                    return;
                }
            } else if (G.titlePhase === 'classSelect') {
                if (e.key === 'ArrowLeft') {
                    G.selectedClassIdx = (G.selectedClassIdx + 2) % 3;
                    updateClassHighlight();
                    return;
                }
                if (e.key === 'ArrowRight') {
                    G.selectedClassIdx = (G.selectedClassIdx + 1) % 3;
                    updateClassHighlight();
                    return;
                }
                if (e.key === 'Enter' || e.code === 'Space') {
                    e.preventDefault();
                    confirmClassSelect();
                    return;
                }
            }
            return; // Don't process game keys when on title
        }

        // --- Death screen keyboard ---
        if (G.dead) {
            if (e.key === 'Enter' || e.code === 'Space') {
                e.preventDefault();
                initAudio();
                G.dead = false;
                setPaused(false);
                G.floor = Math.max(1, G.floor - 1);
                player.hp = player.maxHP;
                player.mp = player.maxMP;
                DOM.deathScreen.style.display = 'none';
                initFloor();
                addLog('å¾©æ´»ã—ãŸ...', '#ffaaaa');
                return; // å¾©æ´»å‡¦ç†å¾Œã¯å³åº§ã«return
            }
            // æ­»äº¡æ™‚ã‚‚Rã‚­ãƒ¼ã§ã‚¹ã‚­ãƒ«ç·¨é›†ã‚’è¨±å¯
            if (e.code === 'KeyR' || e.key === 'r' || e.key === 'R') {
                console.log('[KeyR] Pressed while dead - allowing skill edit');
                e.preventDefault();
                if (skillSelectOpen) closeSkillSelect();
                else openSkillEdit();
                return;
            }
            return; // æ­»äº¡æ™‚ã®ãã®ä»–ã®ã‚­ãƒ¼ã¯ç„¡è¦–
        }

        if (promotionPending) return;

        // Save/Load
        if (e.code === 'F5') { e.preventDefault(); saveGame(); return; }
        if (e.code === 'F8') { e.preventDefault(); loadGame(); return; }

        if (skillSelectOpen) {
            if (e.code === 'Escape' || e.code === 'KeyR') {
                e.preventDefault();
                closeSkillSelect();
                return;
            }
            if (e.code && e.code.startsWith('Digit')) {
                const n = parseInt(e.code.replace('Digit', ''), 10);
                if (n >= 1 && n <= 6) {
                    e.preventDefault();
                    selectOrSwapSkillSlot(n);
                    return;
                }
            }
            if (e.code === 'KeyX') { // remove selected slot
                e.preventDefault();
                removeSkillSlot();
                return;
            }
            if (e.code === 'KeyA') { // assign mode
                e.preventDefault();
                setSkillEditMode('assign');
                return;
            }
            if (e.code === 'KeyW') { // swap mode
                e.preventDefault();
                setSkillEditMode('swap');
                return;
            }
            return;
        }

        // Pause / Settings
        if (e.code === 'Escape') {
            e.preventDefault();
            if (isPanelVisible(DOM.settingsPanel)) {
                setPanelVisible(DOM.settingsPanel, false);
                setPaused(false);
            } else {
                setPaused(!G.paused);
            }
            return;
        }
        if (e.code === 'KeyO') {
            e.preventDefault();
            const opened = togglePanel(DOM.settingsPanel);
            if (opened) {
                renderSettingsUI();
                setPaused(true);
                DOM.pauseOverlay.style.display = 'none';
            } else {
                setPaused(false);
            }
            return;
        }

        if (G.paused) return;

        // --- A key: Attack nearest enemy (use e.code for IME compatibility) ---
        if (e.code === 'KeyA') {
            e.preventDefault();
            let nearest = null, nearestD = 300;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                player.attacking = true;
                player.attackTarget = nearest;
                player.moving = true;
                player.targetX = nearest.x;
                player.targetY = nearest.y;
            }
            return;
        }

        // --- S key: Use selected skill (use e.code for IME compatibility) ---
        if (e.code === 'KeyS') {
            e.preventDefault();
            // Use skill toward nearest enemy, or toward mouse if no enemy nearby
            let tx = mouse.x, ty = mouse.y;
            let nearest = null, nearestD = 400;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                tx = nearest.x - G.camX;
                ty = nearest.y - G.camY;
            }
            player.useSkill(tx, ty);
            return;
        }

        if (e.code === 'KeyC') {
            e.preventDefault();
            const p = DOM.statsPanel;
            togglePanel(p);
            updateStatsPanel();
        }
        if (e.code === 'KeyI') {
            e.preventDefault();
            const p = DOM.inventoryPanel;
            togglePanel(p);
            updateInventoryPanel();
        }
        if (e.code === 'KeyH') {
            e.preventDefault();
            const p = DOM.helpOverlay;
            const opened = togglePanel(p);
            if (opened) renderHelpUI();
        }
        if (e.code === 'KeyG') {
            toggleAutoPickup();
        }
        if (e.code === 'KeyP') {
            cyclePickupFilter();
        }
        if (e.code === 'KeyR' || e.key === 'r' || e.key === 'R') {
            console.log('[KeyR] Pressed! skillSelectOpen:', skillSelectOpen);
            e.preventDefault();
            if (skillSelectOpen) {
                console.log('[KeyR] Closing skill select');
                closeSkillSelect();
            }
            else {
                console.log('[KeyR] Calling openSkillEdit()');
                openSkillEdit();
            }
        }
        if (e.code === 'KeyE') {
            e.preventDefault();
            tryUseStairs(true);
        }
        if (e.code === 'KeyT') {
            e.preventDefault();
            const p = DOM.skillTreePanel;
            const opened = togglePanel(p);
            if (opened) updateSkillTreeUI();
        }
        // Number keys (1-6) select AND activate skills
        if (e.code === 'Digit1' || e.key === '1') {
            player.selectedSkill = 1;
            // Auto-target nearest enemy, or use mouse position
            let tx = mouse.x, ty = mouse.y;
            let nearest = null, nearestD = 400;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                tx = nearest.x - G.camX;
                ty = nearest.y - G.camY;
            }
            player.useSkill(tx, ty);
        }
        if (e.code === 'Digit2' || e.key === '2') {
            player.selectedSkill = 2;
            let tx = mouse.x, ty = mouse.y;
            let nearest = null, nearestD = 400;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                tx = nearest.x - G.camX;
                ty = nearest.y - G.camY;
            }
            player.useSkill(tx, ty);
        }
        if (e.code === 'Digit3' || e.key === '3') {
            player.selectedSkill = 3;
            let tx = mouse.x, ty = mouse.y;
            let nearest = null, nearestD = 400;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                tx = nearest.x - G.camX;
                ty = nearest.y - G.camY;
            }
            player.useSkill(tx, ty);
        }
        if (e.code === 'Digit4' || e.key === '4') {
            player.selectedSkill = 4;
            let tx = mouse.x, ty = mouse.y;
            let nearest = null, nearestD = 400;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                tx = nearest.x - G.camX;
                ty = nearest.y - G.camY;
            }
            player.useSkill(tx, ty);
        }
        if (e.code === 'Digit5' || e.key === '5') {
            player.selectedSkill = 5;
            let tx = mouse.x, ty = mouse.y;
            let nearest = null, nearestD = 400;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                tx = nearest.x - G.camX;
                ty = nearest.y - G.camY;
            }
            player.useSkill(tx, ty);
        }
        if (e.code === 'Digit6' || e.key === '6') {
            player.selectedSkill = 6;
            let tx = mouse.x, ty = mouse.y;
            let nearest = null, nearestD = 400;
            for (const m of monsters) {
                if (!m.alive) continue;
                const d = dist(player.x, player.y, m.x, m.y);
                if (d < nearestD) { nearestD = d; nearest = m; }
            }
            if (nearest) {
                tx = nearest.x - G.camX;
                ty = nearest.y - G.camY;
            }
            player.useSkill(tx, ty);
        }
        if (e.code === 'Space') { e.preventDefault(); player.pickupNearby(); }
    });
    window.addEventListener('keyup', e => {
        keysDown[e.key.toLowerCase()] = false;
        if (e.code) keysDown[e.code] = false;
    });

    // ========== TITLE SCREEN ==========
    const CLASS_KEYS = ['warrior', 'rogue', 'sorcerer'];

    function showClassSelect() {
        initAudio();
        G.titlePhase = 'classSelect';
        G.selectedClassIdx = 0;
        DOM.titleStartText.style.display = 'none';
        if (DOM.titleSaveMenu) DOM.titleSaveMenu.style.display = 'none';
        DOM.classSelect.style.display = 'block';
        updateClassHighlight();
    }

    function updateClassHighlight() {
        const cards = document.querySelectorAll('.class-card');
        cards.forEach((c, i) => {
            if (i === G.selectedClassIdx) {
                c.style.borderColor = '#ffd700';
                c.style.boxShadow = '0 0 20px rgba(218,165,32,0.4)';
                c.style.transform = 'translateY(-5px)';
            } else {
                c.style.borderColor = '#5a4a3a';
                c.style.boxShadow = 'none';
                c.style.transform = 'none';
            }
        });
    }

    function confirmClassSelect() {
        selectClass(CLASS_KEYS[G.selectedClassIdx]);
    }

    // Click handlers still work
    DOM.titleStartText.addEventListener('click', (e) => {
        e.stopPropagation();
        if (hasSaveData(G.saveSlot)) {
            initAudio();
            loadGame(G.saveSlot);
        } else {
            showClassSelect();
        }
    });

    window.selectClass = function(cls) {
        G.playerClass = cls;
        const classDef = CLASS_DEFS[cls];
        player.className = classDef.name;
        player.classKey = cls;
        player.str = classDef.baseStr;
        player.dex = classDef.baseDex;
        player.vit = classDef.baseVit;
        player.int = classDef.baseInt;
        player.skillPoints = 0;
        player.skillLevels = {};
        // Initialize skill levels to 0
        for (const sk of classDef.skills) {
            player.skillLevels[sk.id] = 0;
        }
        // Unlock starting skills (first skill in each branch, level 1)
        player.skillLevels[classDef.skills[0].id] = 1;
        player.skillLevels[classDef.skills[3].id] = 1;
        // Set active skill slots from class skills (pick first 6)
        rebuildSkillBar();
        DOM.titleScreen.style.display = 'none';
        setPaused(false);
        setPanelVisible(DOM.settingsPanel, false);
        G.started = true;
        G.hintTimer = 8;
        player.recalcStats();
        player.hp = player.maxHP;
        player.mp = player.maxMP;
        initFloor();
    };

    DOM.deathScreen.addEventListener('click', () => {
        initAudio();
        G.dead = false;
        setPaused(false);
        G.floor = Math.max(1, G.floor - 1);
        player.hp = player.maxHP;
        player.mp = player.maxMP;
        DOM.deathScreen.style.display = 'none';
        initFloor();
        addLog('å¾©æ´»ã—ãŸ...', '#ffaaaa');
    });
    if (DOM.skillEditBtn) {
        DOM.skillEditBtn.addEventListener('click', () => {
            if (skillSelectOpen) closeSkillSelect();
            else openSkillEdit();
        });
    }

    // ========== DRAWING HELPERS ==========
    function drawLighting() {
        dungeon.reveal(player.x, player.y, 300);
        const px = player.x - G.camX, py = player.y - G.camY;
        // Dynamic torch flicker
        const flicker = Math.sin(G.time * 4.7) * 10 + Math.sin(G.time * 7.3) * 5 + Math.sin(G.time * 13.1) * 3;
        const lightR = 350 + flicker;

        // Main darkness overlay - deeper darkness
        const lg = ctx.createRadialGradient(px, py, lightR * 0.2, px, py, lightR);
        lg.addColorStop(0, 'rgba(0,0,5,0)');
        lg.addColorStop(0.35, 'rgba(0,0,5,0.1)');
        lg.addColorStop(0.6, 'rgba(0,0,5,0.35)');
        lg.addColorStop(0.8, 'rgba(0,0,5,0.65)');
        lg.addColorStop(1, 'rgba(0,0,5,0.88)');
        ctx.fillStyle = lg;
        ctx.fillRect(0, 0, W, H);

        // Warm torch tint - amber/orange Diablo glow
        const warmG = ctx.createRadialGradient(px, py, 0, px, py, lightR * 0.55);
        warmG.addColorStop(0, 'rgba(255,160,60,0.14)');
        warmG.addColorStop(0.3, 'rgba(255,130,40,0.08)');
        warmG.addColorStop(0.7, 'rgba(255,100,20,0.03)');
        warmG.addColorStop(1, 'rgba(255,80,10,0)');
        ctx.fillStyle = warmG;
        ctx.beginPath();
        ctx.arc(px, py, lightR * 0.55, 0, Math.PI * 2);
        ctx.fill();

        // Color grading - warm amber tint (Diablo signature look)
        ctx.globalAlpha = 0.06;
        ctx.fillStyle = '#442200';
        ctx.fillRect(0, 0, W, H);
        ctx.globalAlpha = 1;

        // Screen vignette - heavy, cinematic
        const vigSize = Math.max(W, H) * 0.7;
        const vig = ctx.createRadialGradient(W / 2, H / 2, vigSize * 0.3, W / 2, H / 2, vigSize);
        vig.addColorStop(0, 'rgba(0,0,0,0)');
        vig.addColorStop(0.6, 'rgba(0,0,0,0.2)');
        vig.addColorStop(0.85, 'rgba(0,0,0,0.45)');
        vig.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = vig;
        ctx.fillRect(0, 0, W, H);

        // Damage flash - red vignette when hit
        if (G.dmgFlashT > 0) {
            const flashA = clamp(G.dmgFlashT / 0.35, 0, 1) * 0.4;
            const dmgVig = ctx.createRadialGradient(W/2, H/2, W*0.1, W/2, H/2, W*0.6);
            dmgVig.addColorStop(0, `rgba(120,0,0,0)`);
            dmgVig.addColorStop(0.5, `rgba(150,0,0,${flashA * 0.3})`);
            dmgVig.addColorStop(1, `rgba(180,0,0,${flashA})`);
            ctx.fillStyle = dmgVig;
            ctx.fillRect(0, 0, W, H);
        }
    }

    function drawGroundItems() {
        const TYPE_SPR = {sword:'iSword',axe:'iAxe',staff:'iStaff',shield:'iShield',helmet:'iHelmet',armor:'iArmor',ring:'iRing',amulet:'iAmulet',boots:'iBoots',potion:'iPotion'};
        for (const gi of groundItems) {
            gi.bobT += 0.02;
            const sx = gi.x - G.camX, sy = gi.y - G.camY + Math.sin(gi.bobT) * 3;
            if (sx < -30 || sx > W + 30 || sy < -30 || sy > H + 30) continue;

            // Rarity glow
            const c = gi.item.rarity.color;
            ctx.globalAlpha = 0.25;
            ctx.fillStyle = c;
            ctx.beginPath(); ctx.arc(sx, sy, 13, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1;

            // Sprite icon: find matching type by icon
            let sprKey = null;
            for (const [tKey, tInfo] of Object.entries(ITEM_TYPES)) {
                if (tInfo.icon === gi.item.icon) { sprKey = TYPE_SPR[tKey]; break; }
            }
            if (!sprKey || !drawSpr(sprKey, sx - 14, sy - 14, 28, 28)) {
                ctx.font = `14px ${FONT_UI}`;
                ctx.textAlign = 'center';
                ctx.fillText(gi.item.icon, sx, sy + 5);
            }

            // Label
            ctx.font = `10px ${FONT_UI}`;
            ctx.textAlign = 'center';
            ctx.fillStyle = c;
            ctx.fillText(gi.item.name, sx, sy - 16);
        }
    }

    function drawHUD() {
        // ===== BOTTOM BAR BACKGROUND =====
        const barH = 80;
        const barY = H - barH;
        ctx.fillStyle = 'rgba(8,5,3,0.9)';
        ctx.fillRect(0, barY, W, barH);
        ctx.strokeStyle = '#5a4a3a';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, barY);
        ctx.lineTo(W, barY);
        ctx.stroke();
        // Decorative line
        ctx.strokeStyle = '#3a2a1a';
        ctx.beginPath();
        ctx.moveTo(0, barY + 1);
        ctx.lineTo(W, barY + 1);
        ctx.stroke();

        // Health & Mana Globes
        const globeR = 30;
        const globeY = H - 40;

        // HP Globe (left)
        const hpX = 45;
        ctx.save();
        ctx.beginPath();
        ctx.arc(hpX, globeY, globeR, 0, Math.PI * 2);
        ctx.clip();
        // BG
        ctx.fillStyle = '#330000';
        ctx.fillRect(hpX - globeR, globeY - globeR, globeR * 2, globeR * 2);
        // Fill
        const hpPct = clamp(player.hp / player.maxHP, 0, 1);
        const hpFillH = globeR * 2 * hpPct;
        ctx.fillStyle = '#cc0000';
        ctx.fillRect(hpX - globeR, globeY + globeR - hpFillH, globeR * 2, hpFillH);
        // Sheen
        const hpSheen = ctx.createRadialGradient(hpX - 8, globeY - 8, 0, hpX, globeY, globeR);
        hpSheen.addColorStop(0, 'rgba(255,100,100,0.3)');
        hpSheen.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = hpSheen;
        ctx.fillRect(hpX - globeR, globeY - globeR, globeR * 2, globeR * 2);
        ctx.restore();
        // Border
        ctx.strokeStyle = '#8b6914';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(hpX, globeY, globeR, 0, Math.PI * 2);
        ctx.stroke();
        // Text
        ctx.fillStyle = '#fff';
        ctx.font = `bold 13px ${FONT_UI}`;
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(player.hp)}`, hpX, globeY + 4);
        ctx.font = `9px ${FONT_UI}`;
        ctx.fillStyle = '#faa';
        ctx.fillText('HP', hpX, globeY + 16);

        // MP Globe (right)
        const mpX = W - 50;
        ctx.save();
        ctx.beginPath();
        ctx.arc(mpX, globeY, globeR, 0, Math.PI * 2);
        ctx.clip();
        ctx.fillStyle = '#000033';
        ctx.fillRect(mpX - globeR, globeY - globeR, globeR * 2, globeR * 2);
        const mpPct = clamp(player.mp / player.maxMP, 0, 1);
        const mpFillH = globeR * 2 * mpPct;
        ctx.fillStyle = '#0044cc';
        ctx.fillRect(mpX - globeR, globeY + globeR - mpFillH, globeR * 2, mpFillH);
        const mpSheen = ctx.createRadialGradient(mpX - 8, globeY - 8, 0, mpX, globeY, globeR);
        mpSheen.addColorStop(0, 'rgba(100,100,255,0.3)');
        mpSheen.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = mpSheen;
        ctx.fillRect(mpX - globeR, globeY - globeR, globeR * 2, globeR * 2);
        ctx.restore();
        ctx.strokeStyle = '#4a4a8b';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(mpX, globeY, globeR, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fillStyle = '#fff';
        ctx.font = `bold 13px ${FONT_UI}`;
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(player.mp)}`, mpX, globeY + 4);
        ctx.font = `9px ${FONT_UI}`;
        ctx.fillStyle = '#aaf';
        ctx.fillText('MP', mpX, globeY + 16);

        // Skill bar - 6 slots
        const skillW = 48, skillH = 48, skillGap = 5;
        const numSkills = 6;
        const skillTotalW = numSkills * skillW + (numSkills - 1) * skillGap;
        const skillStartX = W / 2 - skillTotalW / 2;
        const skillY = H - 62;

        // Skill bar background
        ctx.fillStyle = 'rgba(10,8,5,0.85)';
        ctx.fillRect(skillStartX - 8, skillY - 5, skillTotalW + 16, skillH + 18);
        ctx.strokeStyle = '#8b7355';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(skillStartX - 8, skillY - 5, skillTotalW + 16, skillH + 18);

        for (let i = 1; i <= numSkills; i++) {
            const sk = player.skills[i];
            const x = skillStartX + (i - 1) * (skillW + skillGap);
            const sel = player.selectedSkill === i;

            // Background
            ctx.fillStyle = sel ? 'rgba(100,80,30,0.9)' : 'rgba(30,25,20,0.8)';
            ctx.fillRect(x, skillY, skillW, skillH);

            // Border
            ctx.strokeStyle = sel ? '#ffd700' : '#5a4a3a';
            ctx.lineWidth = sel ? 2 : 1;
            ctx.strokeRect(x, skillY, skillW, skillH);

            // Glow for selected
            if (sel) {
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 6;
                ctx.strokeRect(x, skillY, skillW, skillH);
                ctx.shadowBlur = 0;
            }

            // Icon
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = `20px ${FONT_EMOJI}`;
            if (sk && sk.icon) {
                ctx.fillText(sk.icon, x + skillW / 2, skillY + skillH / 2 - 4);
            } else {
                ctx.font = `12px ${FONT_UI}`;
                ctx.fillStyle = '#555';
                ctx.fillText('ç©º', x + skillW / 2, skillY + skillH / 2 - 2);
            }

            // Key number
            ctx.textBaseline = 'alphabetic';
            ctx.font = `bold 9px ${FONT_UI}`;
            ctx.fillStyle = sel ? '#ffd700' : '#777';
            ctx.fillText(i, x + skillW / 2, skillY + 40);

            // MP cost
            ctx.font = `7px ${FONT_UI}`;
            ctx.fillStyle = '#4488ff';
            if (sk && sk.mp != null) {
                ctx.fillText(sk.mp + 'MP', x + skillW / 2, skillY + skillH - 2);
            }

            // Cooldown overlay
            if (sk && sk.cooldown > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.65)';
                const cdPct = sk.cooldown / sk.maxCD;
                ctx.fillRect(x, skillY, skillW, skillH * cdPct);
                ctx.fillStyle = '#fff';
                ctx.font = `bold 13px ${FONT_UI}`;
                ctx.fillText(sk.cooldown.toFixed(1), x + skillW / 2, skillY + 28);
            }
        }

        // XP bar
        const xpW = skillTotalW + 60;
        const xpH = 6;
        const xpX = W / 2 - xpW / 2;
        const xpY = skillY - 12;
        ctx.fillStyle = 'rgba(0,0,0,0.6)';
        ctx.fillRect(xpX, xpY, xpW, xpH);
        ctx.fillStyle = '#8844ff';
        ctx.fillRect(xpX, xpY, xpW * (player.xp / player.xpToNext), xpH);
        ctx.strokeStyle = '#555';
        ctx.lineWidth = 0.5;
        ctx.strokeRect(xpX, xpY, xpW, xpH);
        ctx.fillStyle = '#aaa';
        ctx.font = `9px ${FONT_UI}`;
        ctx.textAlign = 'center';
        ctx.fillText(`Lv.${player.level}  ${player.xp}/${player.xpToNext} XP`, W / 2, xpY - 2);

        // Minimap
        const mmSize = 130;
        const mmX = W - mmSize - 10, mmY = 10;
        const mmScale = mmSize / (MAP_W * TILE);

        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.fillRect(mmX, mmY, mmSize, mmSize);
        ctx.strokeStyle = '#8b7355';
        ctx.lineWidth = 1.5;
        ctx.strokeRect(mmX, mmY, mmSize, mmSize);

        // Rooms - only explored ones
        for (const room of dungeon.rooms) {
            // Check if any tile in this room has been explored
            const explored = dungeon.explored[dungeon.idx(room.cx, room.cy)];
            if (explored) {
                ctx.fillStyle = '#2a2040';
                ctx.fillRect(
                    mmX + room.x * TILE * mmScale,
                    mmY + room.y * TILE * mmScale,
                    room.w * TILE * mmScale,
                    room.h * TILE * mmScale
                );
            }
        }


        // Explored corridor tiles (not just rooms)
        ctx.fillStyle = '#1a1530';
        for (let ty = 0; ty < MAP_H; ty++) {
            for (let tx = 0; tx < MAP_W; tx++) {
                if (dungeon.explored[dungeon.idx(tx, ty)] && dungeon.get(tx, ty) >= 1) {
                    let inRoom = false;
                    for (const room of dungeon.rooms) {
                        if (dungeon.explored[dungeon.idx(room.cx, room.cy)] &&
                            tx >= room.x && tx < room.x + room.w &&
                            ty >= room.y && ty < room.y + room.h) {
                            inRoom = true; break;
                        }
                    }
                    if (!inRoom) {
                        ctx.fillRect(
                            mmX + tx * TILE * mmScale, mmY + ty * TILE * mmScale,
                            Math.max(TILE * mmScale, 1.5), Math.max(TILE * mmScale, 1.5)
                        );
                    }
                }
            }
        }

        // Player on minimap
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(mmX + player.x * mmScale, mmY + player.y * mmScale, 3, 0, Math.PI * 2);
        ctx.fill();

        // Monsters on minimap - ONLY show if near player (within aggro/visibility range)
        const visionRange = 300;
        ctx.fillStyle = '#ff3333';
        for (const m of monsters) {
            if (m.alive && dist(player.x, player.y, m.x, m.y) < visionRange) {
                ctx.fillRect(mmX + m.x * mmScale - 1.5, mmY + m.y * mmScale - 1.5, 3, 3);
            }
        }

        // Stairs on minimap - only if explored
        const stairsExplored = dungeon.explored[dungeon.idx(dungeon.stairsX, dungeon.stairsY)];
        if (stairsExplored) {
            ctx.fillStyle = '#aa88ff';
            ctx.fillRect(mmX + dungeon.stairsX * TILE * mmScale - 2, mmY + dungeon.stairsY * TILE * mmScale - 2, 5, 5);
        }

        // Floor label
        ctx.fillStyle = '#daa520';
        ctx.font = `bold 14px ${FONT_UI}`;
        ctx.textAlign = 'right';
        ctx.fillText(`B${G.floor}F`, mmX - 5, mmY + 16);

        ctx.font = `11px ${FONT_UI}`;
        ctx.fillStyle = '#cc6666';
        ctx.fillText(`æ•µ: ${monsters.filter(m=>m.alive).length}`, mmX - 5, mmY + 32);

        // Auto-pickup indicator
        if (G.autoPickup) {
            ctx.font = `9px ${FONT_UI}`;
            ctx.fillStyle = '#88ff44';
            ctx.textAlign = 'right';
            ctx.fillText('AUTOæ‹¾ã„:ON', mmX - 5, mmY + 46);
        }

        // Stairs hint
        if (monsters.filter(m => m.alive).length === 0) {
            ctx.fillStyle = '#aaaaff';
            ctx.font = `12px ${FONT_UI}`;
            ctx.textAlign = 'center';
            ctx.fillText('éšæ®µã¸é€²ã‚ï¼', W / 2, 30);
        }

        if (SETTINGS.showFPS) {
            ctx.fillStyle = '#c8b18a';
            ctx.font = `10px ${FONT_UI}`;
            ctx.textAlign = 'right';
            ctx.fillText(`FPS ${fps.toFixed(0)}`, mmX - 6, 14);
        }

        // Persistent shortcut display (top-left)
        ctx.globalAlpha = 0.6;
        ctx.font = `10px ${FONT_UI}`;
        ctx.textAlign = 'left';
        const shortcuts = [
            ['çŸ¢å°', 'ç§»å‹•'],
            ['A', 'æ”»æ’ƒ'],
            ['S', 'ã‚¹ã‚­ãƒ«'],
            ['LClick', 'æ”»æ’ƒ'],
            ['RClick', 'ã‚¹ã‚­ãƒ«'],
            ['1-6', 'ã‚¹ã‚­ãƒ«é¸æŠ'],
            ['Space', 'æ‹¾ã†'],
            ['I', 'è£…å‚™'],
            ['C', 'ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹'],
            ['T', 'ã‚¹ã‚­ãƒ«ãƒ„ãƒªãƒ¼'],
            ['H', 'ãƒ˜ãƒ«ãƒ—'],
            ['O', 'è¨­å®š'],
            ['Esc', 'ä¸€æ™‚åœæ­¢'],
            ['G', 'è‡ªå‹•æ‹¾ã„'],
            ['P', 'æ‹¾ã„ãƒ•ã‚£ãƒ«ã‚¿'],
            ['F5', `ã‚»ãƒ¼ãƒ–(S${G.saveSlot})`],
            ['F8', `ãƒ­ãƒ¼ãƒ‰(S${G.saveSlot})`]
        ];
        let scX = 8;
        const scY = 14;
        for (const [key, desc] of shortcuts) {
            ctx.fillStyle = '#000';
            const kw = ctx.measureText(key).width;
            const dw = ctx.measureText(desc).width;
            const totalW = kw + dw + 8;
            ctx.fillStyle = 'rgba(0,0,0,0.45)';
            ctx.fillRect(scX - 2, scY - 10, totalW + 4, 14);
            ctx.fillStyle = '#c8a84e';
            ctx.fillText(key, scX, scY);
            ctx.fillStyle = '#998866';
            ctx.fillText(desc, scX + kw + 4, scY);
            scX += totalW + 8;
        }
        ctx.globalAlpha = 1;
    }

    function drawFloatingTexts() {
        for (const ft of floatingTexts) {
            const sx = ft.x - G.camX, sy = ft.y - G.camY + ft.vy * (ft.maxLife - ft.life);
            const a = clamp(ft.life / ft.maxLife, 0, 1);
            ctx.globalAlpha = a;
            ctx.font = ft.big ? `bold 24px ${FONT_UI}` : `bold 16px ${FONT_UI}`;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#000';
            ctx.fillText(ft.text, sx + 1, sy + 1);
            ctx.fillStyle = ft.color;
            ctx.fillText(ft.text, sx, sy);
            ctx.globalAlpha = 1;
        }
    }

    // ========== SAVE / LOAD SYSTEM ==========
    function saveGame(slot = G.saveSlot) {
        try {
            const saveData = {
                version: 2,
                timestamp: Date.now(),
                floor: G.floor,
                time: G.time,
                playerClass: G.playerClass,
                dungeonSeed: G.dungeonSeed,
                autoPickup: G.autoPickup,
                autoPickupRarity: G.autoPickupRarity,
                player: {
                    x: player.x, y: player.y,
                    level: player.level, xp: player.xp, xpToNext: player.xpToNext,
                    hp: player.hp, maxHP: player.maxHP,
                    mp: player.mp, maxMP: player.maxMP,
                    str: player.str, dex: player.dex, vit: player.vit, int: player.int,
                    statPoints: player.statPoints,
                    skillPoints: player.skillPoints,
                    classKey: player.classKey,
                    className: player.className,
                    skillLevels: { ...player.skillLevels },
                    defense: player.defense,
                    critChance: player.critChance,
                    equipment: {},
                    inventory: []
                }
            };
            for (const [slot, item] of Object.entries(player.equipment)) {
                saveData.player.equipment[slot] = item ? {
                    name: item.name, typeKey: item.typeKey,
                    rarityKey: item.rarityKey, rarity: item.rarity,
                    typeInfo: item.typeInfo,
                    baseStat: item.baseStat, statType: item.statType,
                    affixes: item.affixes || [], desc: item.desc || '',
                    icon: item.icon
                } : null;
            }
            for (const item of player.inventory) {
                saveData.player.inventory.push({
                    name: item.name, typeKey: item.typeKey,
                    rarityKey: item.rarityKey, rarity: item.rarity,
                    typeInfo: item.typeInfo,
                    baseStat: item.baseStat, statType: item.statType,
                    affixes: item.affixes || [], desc: item.desc || '',
                    icon: item.icon
                });
            }
            saveData.player.skills = {};
            for (let i = 1; i <= 6; i++) {
                const sk = player.skills[i];
                if (sk) { // ç©ºã‚¹ãƒ­ãƒƒãƒˆå¯¾å¿œ
                    saveData.player.skills[i] = {
                        id: sk.id, name: sk.name, icon: sk.icon,
                        mp: sk.mp, maxCD: sk.maxCD, desc: sk.desc
                    };
                }
            }
            // Save only alive monsters (dead ones stay dead on load)
            saveData.monsters = monsters.filter(m => m.alive).map(m => ({
                x: m.x, y: m.y, type: m.type,
                hp: m.hp, maxHP: m.maxHP, dmg: m.dmg,
                aggroed: m.aggroed
            }));
            // Save ground items
            saveData.groundItems = groundItems.map(gi => ({
                x: gi.x, y: gi.y,
                item: {
                    name: gi.item.name, typeKey: gi.item.typeKey,
                    rarityKey: gi.item.rarityKey, rarity: gi.item.rarity,
                    typeInfo: gi.item.typeInfo,
                    baseStat: gi.item.baseStat, statType: gi.item.statType,
                    affixes: gi.item.affixes || [], desc: gi.item.desc || '',
                    icon: gi.item.icon
                }
            }));
            // Save remaining chest positions (unopened only)
            saveData.remainingChests = [];
            for (let ty = 0; ty < MAP_H; ty++) {
                for (let tx = 0; tx < MAP_W; tx++) {
                    if (dungeon.get(tx, ty) === 3) {
                        saveData.remainingChests.push(tx * MAP_H + ty);
                    }
                }
            }
            localStorage.setItem(getSaveKey(slot), JSON.stringify(saveData));
            addLog(`ã‚²ãƒ¼ãƒ ã‚’ã‚»ãƒ¼ãƒ–ã—ã¾ã—ãŸï¼(ã‚¹ãƒ­ãƒƒãƒˆ${slot})`, '#00ff88');
            addFloatingText(player.x, player.y - 30, 'SAVED!', '#00ff88');
            emitParticles(player.x, player.y, '#00ff88', 15, 50, 0.5, 3, -40);
            playSound(600, 'sine', 0.1, 0.05);
            if (isPanelVisible(DOM.settingsPanel)) renderSettingsUI();
            return true;
        } catch (e) {
            addLog('ã‚»ãƒ¼ãƒ–ã«å¤±æ•—: ' + e.message, '#ff4444');
            return false;
        }
    }

    function loadGame(slot = G.saveSlot) {
        try {
            const raw = localStorage.getItem(getSaveKey(slot));
            if (!raw) { addLog('ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', '#ff4444'); return false; }
            const save = JSON.parse(raw);
            if (!save.version || save.version < 2) {
                addLog('å¤ã„ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã§ã™ã€‚æ–°ã—ãã‚²ãƒ¼ãƒ ã‚’å§‹ã‚ã¦ãã ã•ã„', '#ff4444');
                return false;
            }

            // Validate classKey before using it
            if (!save.playerClass || !CLASS_DEFS[save.playerClass]) {
                addLog('ç„¡åŠ¹ãªã‚¯ãƒ©ã‚¹ãƒ‡ãƒ¼ã‚¿ã§ã™', '#ff4444');
                return false;
            }

            G.floor = save.floor;
            G.time = save.time || 0;
            G.playerClass = save.playerClass;
            G.dungeonSeed = save.dungeonSeed || 0;
            G.autoPickup = save.autoPickup || false;
            G.autoPickupRarity = save.autoPickupRarity || 'normal';
            G.dead = false;
            setPaused(false);
            setPanelVisible(DOM.settingsPanel, false);
            G.started = true;

            const p = save.player;
            player.level = p.level;
            player.xp = p.xp;
            player.xpToNext = p.xpToNext;
            player.str = p.str; player.dex = p.dex;
            player.vit = p.vit; player.int = p.int;
            player.statPoints = p.statPoints || 0;
            player.skillPoints = p.skillPoints || 0;
            player.classKey = p.classKey;
            player.className = p.className;
            player.skillLevels = p.skillLevels || {};

            for (const [slot, item] of Object.entries(p.equipment)) {
                player.equipment[slot] = item;
            }
            player.inventory = p.inventory || [];

            player.recalcStats();
            player.hp = Math.min(p.hp, player.maxHP);
            player.mp = Math.min(p.mp, player.maxMP);

            DOM.titleScreen.style.display = 'none';
            DOM.deathScreen.style.display = 'none';

            // Generate dungeon with saved seed (reproduces same layout)
            // Skip entity spawning - we'll restore saved monsters/items
            initFloor({ useSeed: true, skipEntities: true });

            // Restore only alive monsters from save (dead ones are gone)
            monsters.length = 0;
            if (save.monsters && save.monsters.length > 0) {
                for (const sm of save.monsters) {
                    const m = new Monster(sm.x, sm.y, sm.type, G.floor);
                    m.hp = sm.hp; m.maxHP = sm.maxHP; m.dmg = sm.dmg;
                    m.alive = true; m.aggroed = sm.aggroed || false;
                    monsters.push(m);
                }
            }
            // Restore ground items from save
            groundItems.length = 0;
            if (save.groundItems && save.groundItems.length > 0) {
                for (const sgi of save.groundItems) {
                    groundItems.push(new GroundItem(sgi.x, sgi.y, sgi.item));
                }
            }
            // Restore opened chests: remove chests that were opened
            if (save.remainingChests) {
                const remaining = new Set(save.remainingChests);
                for (let ty = 0; ty < MAP_H; ty++) {
                    for (let tx = 0; tx < MAP_W; tx++) {
                        if (dungeon.get(tx, ty) === 3) {
                            const key = tx * MAP_H + ty;
                            if (!remaining.has(key)) {
                                dungeon.set(tx, ty, 1); // chest was opened
                            }
                        }
                    }
                }
            }

            // THEN restore player position
            player.x = p.x; player.y = p.y;
            if (!canWalk(player.x, player.y, 10)) {
                for (const room of dungeon.rooms) {
                    const rx = room.x * TILE + room.w * TILE / 2;
                    const ry = room.y * TILE + room.h * TILE / 2;
                    if (canWalk(rx, ry, 10)) { player.x = rx; player.y = ry; break; }
                }
            }
            G.camX = player.x - W / 2;
            G.camY = player.y - H / 2;

            // Restore skills with proper maxCD lookup
            player.skills = {}; // ä»–ã®ã‚»ãƒ¼ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«ã®ã‚¹ã‚­ãƒ«æ±šæŸ“ã‚’é˜²ã
            if (p.skills) {
                const allSkills = getAllAvailableSkills();
                for (let i = 1; i <= 6; i++) {
                    if (p.skills[i]) {
                        const skillDef = allSkills.find(sk => sk.id === p.skills[i].id);
                        const maxCD = skillDef ? skillDef.cd : (p.skills[i].maxCD || 0);
                        player.skills[i] = { ...p.skills[i], cooldown: 0, maxCD: maxCD };
                    }
                }
            }
            // ã‚»ãƒ¼ãƒ–ãƒ‡ãƒ¼ã‚¿ã«skillsãŒãªã„å ´åˆã‚‚ç©ºã®ã¾ã¾

            addLog(`ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼B${G.floor}F Lv.${player.level} (ã‚¹ãƒ­ãƒƒãƒˆ${slot})`, '#00ff88');
            addFloatingText(player.x, player.y - 30, 'LOADED!', '#00ff88');
            emitParticles(player.x, player.y, '#00ff88', 20, 60, 0.5, 4, -40);
            playSound(400, 'sine', 0.12, 0.06);
            const savedDate = new Date(save.timestamp);
            addLog(`ã‚»ãƒ¼ãƒ–æ—¥æ™‚: ${savedDate.toLocaleString('ja-JP')}`, '#888');
            if (isPanelVisible(DOM.settingsPanel)) renderSettingsUI();
            return true;
        } catch (e) {
            addLog('ãƒ­ãƒ¼ãƒ‰ã«å¤±æ•—: ' + e.message, '#ff4444');
            console.error('Load error:', e);
            return false;
        }
    }

    function hasSaveData(slot = G.saveSlot) {
        try { return !!localStorage.getItem(getSaveKey(slot)); } catch (e) { return false; }
    }

    function tryUseStairs(showBlocked) {
        if (!dungeon) return false;
        const ptx = Math.floor(player.x / TILE), pty = Math.floor(player.y / TILE);
        const onTile = dungeon.get(ptx, pty) === 2;
        const sd = dist(player.x, player.y, dungeon.stairsX * TILE + TILE/2, dungeon.stairsY * TILE + TILE/2);
        const nearStairs = sd < 45;
        if (!onTile && !nearStairs) return false;
        if (monsters.filter(m => m.alive).length > 0) {
            if (showBlocked) addLog('ã¾ã æ•µãŒæ®‹ã£ã¦ã„ã‚‹...', '#ff4444');
            return false;
        }
        sfxStairs();
        G.floor++;
        initFloor();
        return true;
    }

    // ========== MAIN GAME LOOP ==========
    let lastTime = 0;
    let fps = 0;
    let fpsAcc = 0;
    let fpsFrames = 0;
    function gameLoop(timestamp) {
        requestAnimationFrame(gameLoop);
        const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
        lastTime = timestamp;
        if (!G.started || G.dead) return;

        fpsAcc += dt;
        fpsFrames++;
        if (fpsAcc >= 0.5) { fps = fpsFrames / fpsAcc; fpsAcc = 0; fpsFrames = 0; }

        const canUpdate = !G.paused;
        if (canUpdate) {
            G.time += dt;
            sfxAmbient();
            if (G.hintTimer > 0) G.hintTimer -= dt;
            if (G.dmgFlashT > 0) G.dmgFlashT -= dt;
            updateAmbientParticles(dt);
            updateBloodPools(dt);
        }

        // Update
        if (canUpdate) {
            player.update(dt);
            for (const m of monsters) m.update(dt, player);

            // æ•µã®ç¶™ç¶šçš„ãªå‡ºç¾ï¼ˆãƒ¯ãƒ©ãƒ¯ãƒ©æ„Ÿï¼‰
            G.spawnTimer += dt;
            if (G.spawnTimer >= G.spawnInterval) {
                G.spawnTimer = 0;
                const aliveCount = monsters.filter(m => m.alive).length;
                const maxMonsters = 30 + G.floor * 5; // éšå±¤ã”ã¨ã«æœ€å¤§æ•°å¢—åŠ 
                if (aliveCount < maxMonsters && dungeon && dungeon.rooms.length > 1) {
                    const spawnCount = Math.min(3 + Math.floor(G.floor / 2), maxMonsters - aliveCount);
                    const types = G.floor <= 2 ? ['skeleton', 'zombie'] :
                                  G.floor <= 4 ? ['skeleton', 'zombie', 'imp'] :
                                  G.floor <= 6 ? ['zombie', 'imp', 'ghost'] :
                                  ['imp', 'ghost'];
                    for (let i = 0; i < spawnCount; i++) {
                        const room = dungeon.rooms[rand(1, dungeon.rooms.length - 1)];
                        const mx = room.x * TILE + rand(TILE, (room.w - 1) * TILE);
                        const my = room.y * TILE + rand(TILE, (room.h - 1) * TILE);
                        monsters.push(new Monster(mx, my, types[rand(0, types.length - 1)], G.floor));
                    }
                }
            }
        }

        // Remove dead monsters after animation
        if (canUpdate) {
            for (let i = monsters.length - 1; i >= 0; i--) {
                if (!monsters[i].alive && monsters[i].deathT <= 0) monsters.splice(i, 1);
            }
        }

        // Projectiles
        if (canUpdate) for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.update(dt);
            if (p.life <= 0) { projectiles.splice(i, 1); continue; }

                // Frozen Orb shard emission
                if (p.frozen_orb) {
                    p.shardTimer = (p.shardTimer || 0) + dt;
                    if (p.shardTimer >= 0.15) {
                        p.shardTimer = 0;
                        const numShards = p.shardCount || 6;
                        for (let si = 0; si < numShards; si++) {
                            const sa = (Math.PI * 2 / numShards) * si + G.time * 3;
                            const sx = p.x + Math.cos(sa) * 15;
                            const sy = p.y + Math.sin(sa) * 15;
                            const tx = p.x + Math.cos(sa) * 200;
                            const ty = p.y + Math.sin(sa) * 200;
                            const shard = new Projectile(sx, sy, tx, ty, p.shardDmg || 10, '#aaddff', 300, 4, 'ice');
                            shard.life = 0.4;
                            projectiles.push(shard);
                        }
                    }
                }

            // Check monster collision
            for (const m of monsters) {
                if (m.alive && dist(p.x, p.y, m.x, m.y) < p.r + m.r) {
                    const isCrit = Math.random() * 100 < player.getCritChance();
                    const d = isCrit ? p.dmg * 2 : p.dmg;
                    monsterTakeDmg(m, d, isCrit);
                    emitParticles(p.x, p.y, '#ffaa00', 10, 80, 0.4, 3, 0);
                    projectiles.splice(i, 1);
                    break;
                }
            }
        }

        // Traps
        if (canUpdate && G.traps) {
            for (let i = G.traps.length - 1; i >= 0; i--) {
                const tr = G.traps[i];
                tr.life -= dt;
                if (tr.life <= 0) { G.traps.splice(i, 1); continue; }
                if (!tr.triggered) {
                    for (const m of monsters) {
                        if (m.alive && dist(tr.x, tr.y, m.x, m.y) < tr.r) {
                            tr.triggered = true;
                            monsterTakeDmg(m, tr.dmg, false);
                            emitParticles(tr.x, tr.y, '#ff6600', 20, 100, 0.5, 4, 50);
                            playNoise(0.15, 0.1, 2000);
                            G.shakeT = 0.15; G.shakeAmt = 6; // Diabloé¢¨ï¼š2å€
                            addLog('ãƒˆãƒ©ãƒƒãƒ—ç™ºå‹•ï¼', '#ff6600');
                            G.traps.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }

        // Particles
        if (canUpdate) for (let i = particles.length - 1; i >= 0; i--) {
            particles[i].update(dt);
            if (!particles[i].alive()) particles.splice(i, 1);
        }

        // Floating texts
        if (canUpdate) for (let i = floatingTexts.length - 1; i >= 0; i--) {
            floatingTexts[i].life -= dt;
            if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1);
        }

                // Update summoned minions
        if (canUpdate && G.minions) {
            for (let mi = G.minions.length - 1; mi >= 0; mi--) {
                const mn = G.minions[mi];
                mn.life -= dt;
                if (mn.life <= 0 || mn.hp <= 0) {
                    emitParticles(mn.x, mn.y, '#88ddff', 10, 50, 0.3, 2, -20);
                    G.minions.splice(mi, 1); continue;
                }
                let nearM = null, nearD = 200;
                for (const m of monsters) {
                    if (!m.alive) continue;
                    const d = dist(mn.x, mn.y, m.x, m.y);
                    if (d < nearD) { nearD = d; nearM = m; }
                }
                if (nearM) {
                    const a = Math.atan2(nearM.y - mn.y, nearM.x - mn.x);
                    mn.x += Math.cos(a) * 140 * dt;
                    mn.y += Math.sin(a) * 140 * dt;
                    mn.attackCD -= dt;
                    if (nearD < 50 && mn.attackCD <= 0) {
                        mn.attackCD = 0.8;
                        monsterTakeDmg(nearM, mn.dmg, Math.random() < 0.1);
                        emitParticles(nearM.x, nearM.y, '#88ddff', 5, 30, 0.2, 2, 0);
                    }
                } else {
                    const pd = dist(mn.x, mn.y, player.x, player.y);
                    if (pd > 80) {
                        const a = Math.atan2(player.y - mn.y, player.x - mn.x);
                        mn.x += Math.cos(a) * 120 * dt;
                        mn.y += Math.sin(a) * 120 * dt;
                    }
                }
            }
        }

// Auto pickup
        if (canUpdate && G.autoPickup) {
            const rarityOrder = ['normal','magic','rare','legendary','unique'];
            const minRarity = rarityOrder.indexOf(G.autoPickupRarity);
            for (const gi of groundItems) {
                if (dist(player.x, player.y, gi.x, gi.y) < 60) {
                    if (gi.item.typeKey === 'potion') { player.pickupNearby(); break; }
                    const itemRarity = rarityOrder.indexOf(gi.item.rarityKey || 'normal');
                    if (itemRarity >= minRarity) { player.pickupNearby(); break; }
                }
            }
        } else if (canUpdate) {
            for (const gi of groundItems) {
                if (gi.item.typeKey === 'potion' && dist(player.x, player.y, gi.x, gi.y) < 40) {
                    player.pickupNearby(); break;
                }
            }
        }

        // Chest check - open chests when walked over
        const ptx = Math.floor(player.x / TILE), pty = Math.floor(player.y / TILE);
        if (canUpdate && dungeon.get(ptx, pty) === 3) {
            dungeon.set(ptx, pty, 1);
            sfxChestOpen();
            const numItems = rand(1, 3);
            for (let ci = 0; ci < numItems; ci++) {
                dropItem(player.x, player.y, generateItem(G.floor));
            }
            if (Math.random() < 0.5) dropItem(player.x, player.y, generatePotion());
            addLog('å®ç®±ã‚’é–‹ã‘ãŸï¼', '#ffd700');
            emitParticles(player.x, player.y, '#ffd700', 15, 60, 0.5, 3, -40);
        }

        // Stairs check
        if (canUpdate) tryUseStairs(false);

        // Level up notice
        if (canUpdate && levelUpTimer > 0) {
            levelUpTimer -= dt;
            if (levelUpTimer <= 0) DOM.levelUpNotice.style.display = 'none';
        }

        // Camera
        if (canUpdate) {
            G.camX = lerp(G.camX, player.x - W / 2, 0.1);
            G.camY = lerp(G.camY, player.y - H / 2, 0.1);
        }

        // Screen shake
        let shakeX = 0, shakeY = 0;
        if (G.shakeT > 0) {
            G.shakeT -= dt;
            if (SETTINGS.screenShake) {
                shakeX = randf(-G.shakeAmt, G.shakeAmt);
                shakeY = randf(-G.shakeAmt, G.shakeAmt);
            }
        }

        // ===== RENDER =====
        ctx.clearRect(0, 0, W, H);
        ctx.fillStyle = '#05050a';
        ctx.fillRect(0, 0, W, H);

        ctx.save();
        ctx.translate(shakeX, shakeY);

        dungeon.draw(G.camX, G.camY);

        // Blood pools (under everything else)
        drawBloodPools(G.camX, G.camY);

        // Ambient particles (dust/embers in the air)
        for (const ap of ambientParticles) ap.draw(G.camX, G.camY);

        // Meteor warning circle
        if (player.meteorT > 0 && G.meteorX) {
            const mx = G.meteorX - G.camX, my = G.meteorY - G.camY;
            const pulse = 0.3 + Math.sin(G.time * 12) * 0.2;
            ctx.strokeStyle = `rgba(255,80,0,${pulse})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(mx, my, 100, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = `rgba(255,60,0,${pulse * 0.15})`;
            ctx.beginPath();
            ctx.arc(mx, my, 100, 0, Math.PI * 2);
            ctx.fill();
            // Inner shrinking circle
            const shrink = player.meteorT / 0.8;
            ctx.strokeStyle = `rgba(255,200,0,${pulse})`;
            ctx.beginPath();
            ctx.arc(mx, my, 100 * shrink, 0, Math.PI * 2);
            ctx.stroke();
        }

        drawGroundItems();
        // Draw traps
        if (G.traps) {
            for (const tr of G.traps) {
                const tx = tr.x - G.camX, ty = tr.y - G.camY;
                const pulse = 0.4 + Math.sin(G.time * 5) * 0.15;
                ctx.strokeStyle = `rgba(255,100,0,${pulse})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(tx, ty, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.fillStyle = `rgba(255,80,0,${pulse * 0.3})`;
                ctx.beginPath();
                ctx.arc(tx, ty, 6, 0, Math.PI * 2);
                ctx.fill();
                // Spikes
                for (let a = 0; a < 6; a++) {
                    const angle = a * Math.PI / 3 + G.time;
                    ctx.fillStyle = `rgba(200,100,0,${pulse * 0.5})`;
                    ctx.fillRect(tx + Math.cos(angle) * 6 - 1, ty + Math.sin(angle) * 6 - 1, 2, 2);
                }
            }
        }
        for (const p of projectiles) p.draw(G.camX, G.camY);
        for (const m of monsters) m.draw(G.camX, G.camY);
        // Draw summoned minions
        if (G.minions) {
            for (const mn of G.minions) {
                const mx = mn.x - G.camX, my = mn.y - G.camY;
                const pulse = 0.5 + Math.sin(G.time * 4) * 0.2;
                ctx.globalAlpha = 0.7 + pulse * 0.3;
                ctx.fillStyle = '#88ccff';
                ctx.beginPath(); ctx.arc(mx, my - 4, 10, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = pulse * 0.3;
                ctx.fillStyle = '#aaddff';
                ctx.beginPath(); ctx.arc(mx, my - 4, 16, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1;
                const hpPct = mn.hp / mn.maxHP;
                ctx.fillStyle = '#333'; ctx.fillRect(mx - 12, my - 18, 24, 3);
                ctx.fillStyle = hpPct > 0.5 ? '#00cc00' : '#cc6600';
                ctx.fillRect(mx - 12, my - 18, 24 * hpPct, 3);
            }
        }
        player.draw(G.camX, G.camY);
        for (const p of particles) p.draw(G.camX, G.camY);
        drawFloatingTexts();
        drawLighting();

        // Film grain overlay (lightweight pre-rendered noise)
        if (SETTINGS.filmGrain && TILE_TEXTURES['grain']) {
            ctx.globalAlpha = 0.15;
            ctx.globalCompositeOperation = 'overlay';
            const gx = (Math.random() * 256) | 0;
            const gy = (Math.random() * 256) | 0;
            const gc = TILE_TEXTURES['grain'];
            for (let py = -gy; py < H; py += 256) {
                for (let px = -gx; px < W; px += 256) {
                    ctx.drawImage(gc, px, py);
                }
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
        }

        ctx.restore();

        // Screen flash effect for Level 5 skills
        if (G.flashT && G.flashT > 0) {
            ctx.globalAlpha = Math.min((G.flashAlpha || 0.3) * (G.flashT / 0.15), 1);
            ctx.fillStyle = G.flashColor || '#ffffff';
            ctx.fillRect(0, 0, W, H);
            ctx.globalAlpha = 1;
            G.flashT = Math.max(0, G.flashT - dt);
        }

        drawHUD();
        drawLog();

        // Update UI panels if open
        if (isPanelVisible(DOM.statsPanel)) updateStatsPanel();
        if (isPanelVisible(DOM.inventoryPanel)) updateInventoryPanel();
    }

    // Handle resize
    window.addEventListener('resize', () => {
        resizeCanvas();
    });

    // Capture R key even when focus is on UI elements
    // é‡è¤‡ãƒªã‚¹ãƒŠãƒ¼ã‚’å‰Šé™¤ - ãƒ¡ã‚¤ãƒ³ãƒãƒ³ãƒ‰ãƒ©ï¼ˆLine 5227ï¼‰ãŒæ­£ã—ãå‡¦ç†ã™ã‚‹

    document.addEventListener('visibilitychange', () => {
        if (document.hidden && G.started && !G.dead) setPaused(true);
    });

    // Tooltip on hover (ground items + skill bar)
    canvas.addEventListener('mousemove', e => {
        if (!G.started || G.paused || isPanelVisible(DOM.settingsPanel) || skillSelectOpen) { DOM.tooltip.style.display = 'none'; return; }
        const wx = e.clientX + G.camX, wy = e.clientY + G.camY;
        const tt = DOM.tooltip;
        let found = false;

        // Check skill bar hover
        const numSk = 6;
        const skW = 48, skGap = 5;
        const skTotalW = numSk * skW + (numSk - 1) * skGap;
        const skStartX = W / 2 - skTotalW / 2;
        const skY = H - 62;
        for (let i = 1; i <= numSk; i++) {
            const sx = skStartX + (i - 1) * (skW + skGap);
            if (e.clientX >= sx && e.clientX <= sx + skW && e.clientY >= skY && e.clientY <= skY + 48) {
                const sk = player.skills[i];
                if (!sk) {
                    tt.innerHTML = `<div class="tt-name" style="color:#888">ç©ºã‚¹ãƒ­ãƒƒãƒˆ</div><div class="tt-type">ã‚­ãƒ¼: ${i}</div>`;
                } else {
                    const allAvail = getAllAvailableSkills();
                    const skDef = allAvail.find(s => s.id === sk.id) || sk;
                    tt.innerHTML = buildSkillTooltipHTML({ ...skDef, mp: sk.mp, maxCD: sk.maxCD }, i);
                }
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 10) + 'px';
                tt.style.top = (skY - 90) + 'px';
                found = true;
                break;
            }
        }

        // Check ground items
        if (!found) {
        for (const gi of groundItems) {
            if (dist(wx, wy, gi.x, gi.y) < 25) {
                tt.innerHTML = buildTooltipHTML(gi.item);
                tt.style.display = 'block';
                tt.style.left = (e.clientX + 15) + 'px';
                tt.style.top = (e.clientY - 10) + 'px';
                found = true;
                break;
            }
        }
        if (!found && !e.target.closest('.ui-panel')) {
            tt.style.display = 'none';
        }
        } // close if(!found) for ground items
    });

    // ========== TEST RUNNER ==========
    function runTests() {
        const results = [];
        const assert = (name, cond) => results.push({ name, ok: !!cond });
        assert('clamp lower', clamp(-1, 0, 1) === 0);
        assert('clamp upper', clamp(2, 0, 1) === 1);
        assert('lerp midpoint', lerp(0, 10, 0.5) === 5);
        assert('pickRarity common', pickRarity(0.0) === 'common');
        assert('pickRarity magic boundary', pickRarity(0.5) === 'magic');
        assert('pickRarity rare boundary', pickRarity(0.78) === 'rare');
        assert('pickRarity legendary boundary', pickRarity(0.93) === 'legendary');
        assert('pickRarity unique boundary', pickRarity(0.99) === 'unique');
        assert('affix count common', getAffixCount(RARITY.common) === 0);

        const wrap = document.createElement('div');
        wrap.style.position = 'fixed';
        wrap.style.inset = '0';
        wrap.style.background = 'rgba(0,0,0,0.92)';
        wrap.style.color = '#e8d7b8';
        wrap.style.fontFamily = FONT_UI;
        wrap.style.padding = '24px';
        wrap.style.zIndex = '3000';
        wrap.innerHTML = `<div style="font-family:${FONT_TITLE};font-size:24px;margin-bottom:10px;letter-spacing:2px">TEST RESULTS</div>`;
        const list = document.createElement('div');
        for (const r of results) {
            const row = document.createElement('div');
            row.style.padding = '6px 0';
            row.textContent = `${r.ok ? 'PASS' : 'FAIL'} - ${r.name}`;
            row.style.color = r.ok ? '#40d97b' : '#d24b4b';
            list.appendChild(row);
        }
        wrap.appendChild(list);
        document.body.appendChild(wrap);
        return results.every(r => r.ok);
    }

    // Start the loop
    const TEST_MODE = new URLSearchParams(window.location.search).has('test');
    if (TEST_MODE) {
        runTests();
    } else {
        requestAnimationFrame(gameLoop);
    }
    </script>
</body>
</html>
